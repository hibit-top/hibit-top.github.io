<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>ANSI Common Lisp 中文版</title>
  <link rel="stylesheet" href="./pyramid.css" type="text/css" />
</head>
<body>
  <div class="document">
    <div class="documentwrapper">
      <div class="bodywrapper">
        <div class="body">
          <div class="section" id="ansi-common-lisp">
            <h1>ANSI Common Lisp 中文版</h1>
            <h3>目录</h3>
            <ul>
              <li><a href="#0">前言</a></li>
              <li><a href="#1">第一章：简介</a></li>
              <li><a href="#2">第二章：欢迎来到</a></li>
              <li><a href="#3">第三章：列表</a></li>
              <li><a href="#4">第四章：特殊数据结构</a></li>
              <li><a href="#5">第五章：控制流</a></li>
              <li><a href="#6">第六章：函数</a></li>
              <li><a href="#7">第七章：输入与输出</a></li>
              <li><a href="#8">第八章：符号</a></li>
              <li><a href="#9">第九章：数字</a></li>
              <li><a href="#10">第十章：宏</a></li>
              <li><a href="#11">第十一章：Common Lisp 对象系统</a></li>
              <li><a href="#12">第十二章：结构</a></li>
              <li><a href="#13">第十三章：速度</a></li>
              <li><a href="#14">第十四章：进阶议题</a></li>
              <li><a href="#15">第十五章：示例：推论</a></li>
              <li><a href="#16">第十六章：示例：生成 HTML</a></li>
              <li><a href="#17">第十七章：示例：对象</a></li>
            </ul>
            <table border="1" class="docutils">
              <tbody valign="top">
                <tr class="row-odd">
                  <td>
                    <div class="toctree-wrapper first last compound">
                      <div class="section">
                        <div class="toctree-wrapper compound">
                          <div class="section">
                            <h3 id="0">前言</h3>
                            <p>本书的目的是快速及全面的教你 Common Lisp 的有关知识。它实际上包含两本书。前半部分用大量的例子来解释 Common Lisp 里面重要的概念。后半部分是一个最新
                              Common Lisp 辞典，涵盖了所有 ANSI Common Lisp 的操作符。</p>
                            <div class="section" id="id2">
                              <h4>这本书面向的读者
                              </h4>
                              <p>ANSI Common Lisp 这本书适合学生或者是专业的程序员去读。本书假设读者阅读前没有 Lisp
                                的相关知识。有别的程序语言的编程经验也许对读本书有帮助，但也不是必须的。本书从解释 Lisp 中最基本的概念开始，并对于 Lisp 最容易迷惑初学者的地方进行特别的强调。
                              </p>
                              <p>本书也可以作为教授 Lisp 编程的课本，也可以作为人工智能课程和其他编程语言课程中，有关 Lisp 部分的参考书。想要学习 Lisp
                                的专业程序员肯定会很喜欢本书所采用的直截了当、注重实践的方法。那些已经在使用 Lisp 编程的人士将会在本书中发现许多有用的实例，此外，本书也是一本方便的 ANSI
                                Common Lisp 参考书。</p>
                            </div>
                            <div class="section" id="id3">
                              <h4>如何使用这本书</h4>
                              <p>学习 Lisp 最好的办法就是拿它来编程。况且在学习的同时用你学到的技术进行编程，也是非常有趣的一件事。编写本书的目的就是让读者尽快的入门，在对 Lisp
                                进行简短的介绍之后，
                                第 2 章开始用 21 页的内容，介绍了着手编写 Lisp 程序时可能会用到的所有知识。
                                3-9 章讲解了 Lisp 里面一些重要的知识点。这些章节特别强调了一些重要的概念，比如指针在 Lisp 中扮演的角色，如何使用递归来解决问题，以及第一级函数的重要性等等。
                              </p>
                              <p>针对那些想要更深入了解 Lisp 的读者：
                                10-14 章包含了宏、CLOS、列表操作、程序优化，以及一些更高级的课题，比如包和读取宏。</p>
                              <p>15-17 章通过 3 个 Common Lisp 的实际应用，总结了之前章节所讲解的知识：一个是进行逻辑推理的程序，另一个是 HTML
                                生成器，最后一个是针对面向对象编程的嵌入式语言。</p>
                              <p>本书的最后一部分包含了 4 个附录，这些附录应该对所有的读者都有用：
                                附录 A-D 包括了一个如何调试程序的指南， 58 个 Common Lisp 操作符的源程序，一个关于 ANSI Common Lisp 和以前的 Lisp
                                语言区别的总结，以及一个包括所有 ANSI Common Lisp 的参考手册。</p>
                              <p>本书还包括一节备注。这些备注包括一些说明，一些参考条目，一些额外的代码，以及一些对偶然出现的不正确表述的纠正。备注在文中用一个小圆圈来表示，像这样：○</p>
                              <div class="admonition note">
                                <p class="first admonition-title">Note</p>
                                <p class="last">译注: 由于小圈圈 ○ 实在太不明显了，译文中使用 λ 符号来表示备注。</p>
                              </div>
                              <p><a class="reference external"
                                  href="http://ansi-common-lisp.readthedocs.org/en/latest/zhCN/notes-cn.html#viii-notes-viii">λ</a>
                              </p>
                            </div>
                            <div class="section" id="id5">
                              <h4>代码</h4>
                              <p>虽然本书介绍的是 ANSI Common Lisp ，但是本书中的代码可以在任何版本的 Common Lisp 中运行。那些依赖 Lisp
                                语言新特性的例子的旁边，会有注释告诉你如何把它们运行于旧版本的 Lisp 中。</p>
                              <p>本书中所有的代码都可以在互联网上下载到。你可以在网络上找到这些代码，它们还附带着一个免费软件的链接，一些过去的论文，以及 Lisp 的 FAQ 。还有很多有关 Lisp
                                的资源可以在此找到：
                                <a class="reference external"
                                  href="http://www.eecs.harvard.edu/onlisp/">http://www.eecs.harvard.edu/onlisp/</a>
                                源代码可以在此 FTP 服务器上下载：
                                <a class="reference external"
                                  href="ftp://ftp.eecs.harvard.edu:/pub/onlisp/">ftp://ftp.eecs.harvard.edu:/pub/onlisp/</a>
                                读者的问题和意见可以发送到 <a class="reference external"
                                  href="mailto:pg&#37;&#52;&#48;eecs&#46;harvard&#46;edu">pg<span>&#64;</span>eecs<span>&#46;</span>harvard<span>&#46;</span>edu</a>
                                。
                              </p>
                              <div class="admonition tip">
                                <p class="first admonition-title">Tip</p>
                                <p class="last">译注：下载的链接都坏掉了，本书的代码可以到此下载：<a class="reference external"
                                    href="https://raw.github.com/acl-translation/acl-chinese/master/code/acl2.lisp">https://raw.github.com/acl-translation/acl-chinese/master/code/acl2.lisp</a>
                                </p>
                              </div>
                            </div>
                            <div class="section" id="on-lisp">
                              <h4>On Lisp
                              </h4>
                              <p>在整本 On Lisp 书中，我一直试着指出一些 Lisp 独一无二的特性，这些特性使得 Lisp 更像 “Lisp” 。并展示一些 Lisp 能让你完成的新事情。比如说宏：
                                Lisp 程序员能够并且经常编写一些能够写程序的程序。对于程序生成程序这种特性，因为 Lisp 是主流语言中唯一一个提供了相关抽象使得你能够方便地实现这种特性的编程语言，所以
                                Lisp 是主流语言中唯一一个广泛运用这个特性的语言。我非常乐意邀请那些想要更进一步了解宏和其他高级 Lisp 技术的读者，读一下本书的姐妹篇： <a
                                  class="reference external" href="http://www.paulgraham.com/onlisp.html">On Lisp</a> 。
                              </p>
                              <div class="admonition tip">
                                <p class="first admonition-title">Tip</p>
                                <p class="last">On Lisp 已经由知名 Lisp 黑客 ── 田春 ── 翻译完成，可以在网络上找到。
                                  ── 田春（知名 Lisp 黑客、Practical Common Lisp 译者）</p>
                              </div>
                            </div>
                            <div class="section" id="id7">
                              <h4>鸣谢</h4>
                              <p>在所有帮助我完成这本的朋友当中，我想特别的感谢一下 Robert Morris
                                。他的重要影响反应在整本书中。他的良好影响使这本书更加优秀。本书中好一些实例程序都源自他手。这些程序包括 138 页的 Henley 和 249 页的模式匹配器。</p>
                              <p>我很高兴能有一个高水平的技术审稿小组：Skona Brittain, John Foderaro, Nick Levine, Peter Norvig 和 Dave
                                Touretzky。本书中几乎所有部分都得益于它们的意见。 John Foderaro 甚至重写了本书 5.7 节中一些代码。</p>
                              <p>另外一些人通篇阅读了本书的手稿，它们是：Ken Anderson, Tom Cheatham, Richard Fateman, Steve Hain, Barry
                                Margolin, Waldo Pacheco, Wheeler Ruml 和 Stuart Russell。特别要提一下，Ken Anderson 和 Wheeler
                                Ruml 给予了很多有用的意见。</p>
                              <p>我非常感谢 Cheatham 教授，更广泛的说，哈佛，提供我编写这本书的一些必要条件。另外也要感谢 Aiken 实验室的人员：Tony Hartman, Dave
                                Mazieres, Janusz Juda, Harry Bochner 和 Joanne Klys。</p>
                              <p>我非常高兴能再一次有机会和 Alan Apt 合作。还有这些在 Prentice Hall 工作的人士： Alan, Mona, Pompili Shirley
                                McGuire 和 Shirley Michaels, 能与你们共事我很高兴。</p>
                              <p>本书用 Leslie Lamport 写的 LaTeX 进行排版。LaTeX 是在 Donald Knuth 编写的 TeX 的基础上，又加了 L.A.Carr, Van
                                Jacobson 和 Guy Steele 所编写的宏完成。书中的图表是由 John Vlissides 和 Scott Stanton 编写的 Idraw
                                完成的。整本书的预览是由 Tim Theisen 写的 Ghostview 完成的。 Ghostview 是根据 L. Peter Deutsch 的 Ghostscript
                                创建的。</p>
                              <p>我还需要感谢其他的许多人，包括：Henry Baker, Kim Barrett, Ingrid Bassett, Trevor Blackwell, Paul
                                Becker, Gary Bisbee, Frank Deutschmann, Frances Dickey, Rich 和 Scott Draves, Bill
                                Dubuque, Dan Friedman, Jenny Graham, Alice Hartley, David Hendler, Mike Hewett, Glenn
                                Holloway, Brad Karp, Sonya Keene, Ross Knights, Mutsumi Komuro, Steffi Kutzia, David
                                Kuznick, Madi Lord, Julie Mallozzi, Paul McNamee, Dave Moon, Howard Mullings, Mark
                                Nitzberg, Nancy Parmet 和其家人, Robert Penny, Mike Plusch, Cheryl Sacks, Hazem Sayed,
                                Shannon Spires, Lou Steinberg, Paul Stoddard, John Stone, Guy Steele, Steve Strassmann,
                                Jim Veitch, Dave Watkins, Idelle and Julian Weber, the Weickers, Dave Yost 和 Alan
                                Yuille。</p>
                              <p>另外，着重感谢我的父母和 Jackie。</p>
                              <p><a class="reference external"
                                  href="http://zh.wikipedia.org/zh-cn/%E9%AB%98%E5%BE%B7%E7%BA%B3">高德纳</a>给他的经典丛书起名为《计算机程序设计艺术》。在他的图灵奖获奖感言中，他解释说这本书的书名源自于内心深处的潜意识
                                ── 潜意识告诉他，编程其实就是追求编写最优美的程序。</p>
                              <p>就像建筑设计一样，编程既是一门工程技艺也是一门艺术。一个程序要遵循数学原理也要符合物理定律。但是建筑师的目的不仅仅是建一个不会倒塌的建筑。更重要的是，他们要建一个优美的建筑。
                              </p>
                              <p>像高德纳一样，很多程序员认为编程的真正目的，不仅仅是编写出正确的程序，更重要的是写出优美的代码。几乎所有的 Lisp 黑客也是这么想的。 Lisp
                                黑客精神可以用两句话来概括：编程应该是有趣的。程序应该是优美的。这就是我在这本书中想要传达的精神。</p>
                              <p><a class="reference external" href="http://paulgraham.com/">保罗•格雷厄姆 (Paul Graham)</a>
                              </p>
                            </div>
                          </div>
                          <div class="section">
                            <h3 id="1">第一章：简介</h3>
                            <p><a class="reference external"
                                href="http://zh.wikipedia.org/zh-cn/%E7%BA%A6%E7%BF%B0%C2%B7%E9%BA%A6%E5%8D%A1%E9%94%A1">约翰麦卡锡</a>和他的学生于
                              1958 年展开 Lisp 的初次实现工作。 Lisp 是继 FORTRAN 之后，仍在使用的最古老的程序语言。 <a class="reference external"
                                href="http://acl.readthedocs.org/en/latest/zhCN/notes-cn.html#notes-1">λ</a>
                              更值得注意的是，它仍走在程序语言技术的最前面。懂 Lisp 的程序员会告诉你，有某种东西使 Lisp 与众不同。</p>
                            <p>Lisp 与众不同的部分原因是，它被设计成能够自己进化。你能用 Lisp 定义新的 Lisp 操作符。当新的抽象概念风行时（如面向对象程序设计），我们总是发现这些新概念在
                              Lisp 是最容易来实现的。Lisp 就像生物的 DNA 一样，这样的语言永远不会过时。</p>
                            <div class="section" id="new-tools">
                              <h4>1.1 新的工具 (New Tools)</h4>
                              <p>为什么要学 Lisp？因为它让你能做一些其它语言做不到的事情。如果你只想写一个函数来返回小于 <code
                                  class="docutils literal"><span class="pre">n</span></code> 的数字总和，那么用 Lisp 和 C 是差不多的：
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="c1">; Lisp                   /* C */</span>
<span class="p">(</span><span class="nb">defun</span> <span class="nv">sum</span> <span class="p">(</span><span class="nv">n</span><span class="p">)</span>           <span class="nv">int</span> <span class="nv">sum</span><span class="p">(</span><span class="nv">int</span> <span class="nv">n</span><span class="p">)</span><span class="nv">{</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">s</span> <span class="mi">0</span><span class="p">))</span>             <span class="nv">int</span> <span class="nv">i,</span> <span class="nv">s</span> <span class="nb">=</span> <span class="mi">0</span><span class="c1">;</span>
    <span class="p">(</span><span class="nb">dotimes</span> <span class="p">(</span><span class="nv">i</span> <span class="nv">n</span> <span class="nv">s</span><span class="p">)</span>       <span class="nv">for</span><span class="p">(</span><span class="nv">i</span> <span class="nb">=</span> <span class="mi">0</span><span class="c1">; i &lt; n; i++)</span>
      <span class="p">(</span><span class="nb">incf</span> <span class="nv">s</span> <span class="nv">i</span><span class="p">))))</span>          <span class="nv">s</span> <span class="nv">+=</span> <span class="nv">i</span><span class="c1">;</span>
                            <span class="nb">return</span><span class="p">(</span><span class="nv">s</span><span class="p">)</span><span class="c1">;</span>
                          <span class="nv">}</span>
</pre>
                                </div>
                              </div>
                              <p>如果你只想做这种简单的事情，那用什么语言都不重要。假设你想写一个函数，输入一个数 <code
                                  class="docutils literal"><span class="pre">n</span></code> ，返回把 <code
                                  class="docutils literal"><span class="pre">n</span></code> 与传入参数 (argument)相加的函数。</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="c1">; Lisp</span>
<span class="p">(</span><span class="nb">defun</span> <span class="nv">addn</span> <span class="p">(</span><span class="nv">n</span><span class="p">)</span>
  <span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="nv">n</span><span class="p">)))</span>
</pre>
                                </div>
                              </div>
                              <p>在 C 语言中 <code class="docutils literal"><span class="pre">addn</span></code>
                                怎么实现？你根本写不出来。</p>
                              <p>你可能会想，谁会想做这样的事情？程序语言教你不要做它们没有提供的事情。你得针对每个程序语言，用其特定的思维来写程序，而且想得到你所不能描述的东西是很困难的。当我刚开始编程时
                                ── 用 Baisc ── 我不知道什么是递归，因为我根本不知道有这个东西。我是用 Basic 在思考。我只能用迭代的概念表达算法，所以我怎么会知道递归呢？</p>
                              <p>如果你没听过<a class="reference external"
                                  href="http://zh.wikipedia.org/zh-cn/%E9%97%AD%E5%8C%85_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)">词法闭包
                                  「Lexical Closure」</a> (上述 <code
                                  class="docutils literal"><span class="pre">addn</span></code> 的范例)，相信我， Lisp
                                程序员一直在使用它。很难找到任何长度的 Common Lisp 程序，没有用到闭包的好处。在 112 页前，你自己会持续使用它。</p>
                              <p>闭包仅是其中一个我们在别的语言找不到的抽象概念之一。另一个更有价值的 Lisp 特点是， Lisp 程序是用 Lisp
                                的数据结构来表示。这表示你可以写出会写程序的程序。人们真的需要这个吗？没错 ── 它们叫做宏，有经验的程序员也一直在使用它。学到 173 页你就可以自己写出自己的宏了。</p>
                              <p>有了宏、闭包以及运行期类型，Lisp 凌驾在面向对象程序设计之上。如果你了解上面那句话，也许你不应该阅读此书。你得充分了解 Lisp
                                才能明白为什么此言不虚。但这不是空泛之言。这是一个重要的论点，并且在 17 章用程序相当明确的证明了这点。</p>
                              <p>第二章到第十三章会循序渐进地介绍所有你需要理解第 17 章程序的概念。你的努力会有所回报：你会感到在 C++ 编程是窒碍难行的，就像有经验的 C++ 程序员用 Basic
                                编程会感到窒息一样。更加鼓舞人心的是，如果我们思考为什么会有这种感觉。 编写 Basic 对于平常用 C++ 编程是令人感到窒息的，是因为有经验的 C++ 程序员知道一些用
                                Basic 不可能表达出来的技术。同样地，学习 Lisp 不仅教你学会一门新的语言 ── 它教你崭新的并且更强大的程序思考方法。</p>
                            </div>
                            <div class="section" id="new-techniques">
                              <h4>1.2 新的技术 (New Techniques)</h4>
                              <p>如上一节所提到的， Lisp 赋予你别的语言所没有的工具。不仅仅如此，就 Lisp 带来的新特性来说 ── 自动内存管理 (automatic memory
                                management)，显式类型 (manifest typing)，闭包 (closures)等 ──
                                每一项都使得编程变得如此简单。结合起来，它们组成了一个关键的部分，使得一种新的编程方式是有可能的。</p>
                              <p>Lisp 被设计成可扩展的：让你定义自己的操作符。这是可能的，因为 Lisp 是由和你程序一样的函数与宏所构成的。所以扩展 Lisp 就和写一个 Lisp
                                程序一样简单。事实上，它是如此的容易（和有用），以至于扩展语言自身成了标准实践。当你在用 Lisp
                                语言編程时，你也在创造一个适合你的程序的语言。你由下而上地，也由上而下地工作。</p>
                              <p>
                                几乎所有的程序，都可以从订作适合自己所需的语言中受益。然而越复杂的程序，由下而上的程序设计就显得越有价值。一个由下而上所设计出来的程序，可写成一系列的层，每层担任上一层的程序语言。
                                <a class="reference external" href="http://en.wikipedia.org/wiki/TeX">TeX</a>
                                是最早使用这种方法所写的程序之一。你可以用任何语言由下而上地设计程序，但 Lisp 是本质上最适合这种方法的工具。
                              </p>
                              <p>由下而上的编程方法，自然发展出可扩展的软件。如果你把由下而上的程序设计的原则，想成你程序的最上层，那这层就成为使用者的程序语言。正因可扩展的思想深植于 Lisp 当中，使得
                                Lisp 成为实现可扩展软件的理想语言。三个 1980 年代最成功的程序提供 Lisp 作为扩展自身的语言: <a class="reference external"
                                  href="http://www.gnu.org/software/emacs/">GNU Emacs</a> ， <a
                                  class="reference external"
                                  href="http://www.autodesk.com.tw/adsk/servlet/pc/index?siteID=1170616&amp;id=14977606">Autocad</a>
                                ，和 <a class="reference external"
                                  href="http://en.wikipedia.org/wiki/Interleaf">Interleaf</a> 。</p>
                              <p>
                                由下而上的编程方法，也是得到可重用软件的最好方法。写可重用软件的本质是把共同的地方从细节中分离出来，而由下而上的编程方法本质地创造这种分离。与其努力撰写一个庞大的应用，不如努力创造一个语言，用相对小的努力在这语言上撰写你的应用。和应用相关的特性集中在最上层，以下的层可以组成一个适合这种应用的语言
                                ── 还有什么比程序语言更具可重用性的呢？</p>
                              <p>Lisp 让你不仅编写出更复杂的程序，而且写的更快。 Lisp 程序通常很简短 ── Lisp 给了你更高的抽象化，所以你不用写太多代码。就像 <a
                                  class="reference external" href="http://en.wikipedia.org/wiki/Fred_Brooks">Frederick
                                  Brooks</a> 所指出的，编程所花的时间主要取决于程序的长度。因此仅仅根据这个单独的事实，就可以推断出用 Lisp 编程所花的时间较少。这种效果被 Lisp
                                的动态特点放大了：在 Lisp 中，编辑-编译-测试循环短到使编程像是即时的。</p>
                              <p>更高的抽象化与互动的环境，能改变各个机构开发软件的方式。术语<em>快速建型</em>描述了一种始于 Lisp 的编程方法：在 Lisp
                                里，你可以用比写规格说明更短的时间，写一个原型出来，而这种原型是高度抽象化的，可作为一个比用英语所写的更好的规格说明。而且 Lisp
                                让你可以轻易的从原型转成产品软件。当写一个考虑到速度的 Common Lisp 程序时，通过现代编译器的编译，Lisp 与其他的高阶语言所写的程序运行得一样快。</p>
                              <p>除非你相当熟悉 Lisp ，这个简介像是无意义的言论和冠冕堂皇的声明。<em>Lisp 凌驾面向对象程序设计？</em> <em>你创造适合你程序的语言？</em>
                                <em>Lisp 编程是即时的？</em> 这些说法是什么意思？现在这些说法就像是枯竭的湖泊。随着你学到更多实际的 Lisp
                                特色，见过更多可运行的程序，这些说法就会被实际经验之水所充满，而有了明确的形状。
                              </p>
                            </div>
                            <div class="section" id="new-approach">
                              <h4>1.3 新的方法 (New Approach)</h4>
                              <p>本书的目标之一是不仅是教授 Lisp 语言，而是教授一种新的编程方法，这种方法因为有了 Lisp
                                而有可能实现。这是一种你在未来会见得更多的方法。随着开发环境变得更强大，程序语言变得更抽象， Lisp 的编程风格正逐渐取代旧的<em>规划-然后-实现</em>
                                (<em>plan-and-implement</em>)的模式。</p>
                              <p>在旧的模式中，错误永远不应该出现。事前辛苦订出缜密的规格说明，确保程序完美的运行。理论上听起来不错。不幸地，规格说明是人写的，也是人来实现的。实际上结果是，
                                <em>规划-然后-实现</em> 模型不太有效。
                              </p>
                              <p>身为 OS/360 的项目经理， <a class="reference external"
                                  href="http://en.wikipedia.org/wiki/Fred_Brooks">Frederick Brooks</a>
                                非常熟悉这种传统的模式。他也非常熟悉它的后果：</p>
                              <blockquote>
                                <div>任何 OS/360
                                  的用户很快的意识到它应该做得更好...再者，产品推迟，用了更多的内存，成本是估计的好几倍，效能一直不好，直到第一版后的好几个版本更新，效能才算还可以。</div>
                              </blockquote>
                              <p>而这却描述了那个时代最成功系统之一。</p>
                              <p>
                                旧模式的问题是它忽略了人的局限性。在旧模式中，你打赌规格说明不会有严重的缺失，实现它们不过是把规格转成代码的简单事情。经验显示这实在是非常坏的赌注。打赌规格说明是误导的，程序到处都是臭虫
                                (bug) 会更保险一点。</p>
                              <p>
                                这其实就是新的编程模式所假设的。设法尽量降低错误的成本，而不是希望人们不犯错。错误的成本是修补它所花费的时间。使用强大的语言跟好的开发环境，这种成本会大幅地降低。编程风格可以更多地依靠探索，较少地依靠事前规划。
                              </p>
                              <p>规划是一种必要之恶。它是评估风险的指标：越是危险，预先规划就显得更重要。强大的工具降低了风险，也降低了规划的需求。程序的设计可以从最有用的信息来源中受益：过去实作程序的经验。
                              </p>
                              <p>Lisp 风格从 1960 年代一直朝着这个方向演进。你在 Lisp
                                中可以如此快速地写出原型，以致于你已历经好几个设计和实现的循环，而在旧的模式当中，你可能才刚写完规格说明。你不必担心设计的缺失，因为你将更快地发现它们。你也不用担心有那么多臭虫。当你用函数式风格来编程，你的臭虫只有局部的影响。当你使用一种很抽象的语言，某些臭虫(如<a
                                  class="reference external"
                                  href="http://zh.wikipedia.org/zh-cn/%E8%BF%B7%E9%80%94%E6%8C%87%E9%92%88">迷途指针</a>)不再可能发生，而剩下的臭虫很容易找出，因为你的程序更短了。当你有一个互动的开发环境，你可以即时修补臭虫，不必经历
                                编辑，编译，测试的漫长过程。</p>
                              <p>Lisp
                                风格会这么演进是因为它产生的结果。听起来很奇怪，少的规划意味著更好的设计。技术史上相似的例子不胜枚举。一个相似的变革发生在十五世纪的绘画圈里。在油画流行前，画家使用一种叫做<a
                                  class="reference external"
                                  href="http://zh.wikipedia.org/zh-cn/%E8%9B%8B%E5%BD%A9%E7%95%AB">蛋彩</a>的材料来作画。蛋彩不能被混和或涂掉。犯错的代价非常高，也使得画家变得保守。后来随着油画颜料的出现，作画风格有了大幅地改变。油画“允许你再来一次”这对困难主题的处理，像是画人体，提供了决定性的有利条件。
                              </p>
                              <p>新的材料不仅使画家更容易作画了。它使新的更大胆的作画方式成为可能。 Janson 写道：</p>
                              <blockquote>
                                <div>
                                  如果没有油画颜料，弗拉芒大师们的征服可见的现实的口号就会大打折扣。于是，从技术的角度来说，也是如此，但他们当之无愧地称得上是“现代绘画之父”，油画颜料从此以后成为画家的基本颜料。
                                </div>
                              </blockquote>
                              <p>做为一种介质，蛋彩与油画颜料一样美丽。但油画颜料的弹性给想像力更大的发挥空间 ── 这是决定性的因素。</p>
                              <p>程序设计正经历着相同的改变。新的介质像是“动态的面向对象语言” ── 即 Lisp 。这不是说我们所有的软件在几年内都要用 Lisp
                                来写。从蛋彩到油画的转变也不是一夜完成的；油彩一开始只在领先的艺术中心流行，而且经常混合着蛋彩来使用。我们现在似乎正处于这个阶段。 Lisp
                                被大学，研究室和某些顶尖的公司所使用。同时，从 Lisp 借鉴的思想越来越多地出现在主流语言中：交互式编程环境 (interactive programming
                                environment)、<a class="reference external"
                                  href="http://zh.wikipedia.org/zh-cn/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_(%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8)">垃圾回收(garbage
                                  collection)</a>、运行期类型 (run-time typing)，仅举其中几个。</p>
                              <p>
                                强大的工具正降低探索的风险。这对程序员来说是好消息，因为意味者我们可以从事更有野心的项目。油画的确有这个效果。采用油画后的时期正是绘画的黄金时期。类似的迹象正在程序设计的领域中发生。
                              </p>
                            </div>
                          </div>
                          <div class="section" id="lisp">
                            <h3 id="2">第二章：欢迎来到 Lisp</h3>
                            <p>本章的目的是让你尽快开始编程。本章结束时，你会掌握足够多的 Common Lisp 知识来开始写程序。</p>
                            <div class="section" id="form">
                              <h4>2.1 形式 (Form)</h4>
                              <p>人可以通过实践来学习一件事，这对于 Lisp 来说特别有效，因为 Lisp 是一门交互式的语言。任何 Lisp
                                系统都含有一个交互式的前端，叫做<em>顶层</em>(toplevel)。你在顶层输入 Lisp 表达式，而系统会显示它们的值。</p>
                              <p>Lisp 通常会打印一个提示符告诉你，它正在等待你的输入。许多 Common Lisp 的实现用 <code
                                  class="docutils literal"><span class="pre">&gt;</span></code> 作为顶层提示符。本书也沿用这个符号。</p>
                              <p>一个最简单的 Lisp 表达式是整数。如果我们在提示符后面输入 <code
                                  class="docutils literal"><span class="pre">1</span></code> ，</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="mi">1</span>
<span class="mi">1</span>
<span class="nb">&gt;</span>
</pre>
                                </div>
                              </div>
                              <p>系统会打印出它的值，接着打印出另一个提示符，告诉你它在等待更多的输入。</p>
                              <p>在这个情况里，打印的值与输入的值相同。数字 <code class="docutils literal"><span class="pre">1</span></code>
                                称之为对自身求值。当我们输入需要做某些计算来求值的表达式时，生活变得更加有趣了。举例来说，如果我们想把两个数相加，我们输入像是：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">+</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span>
<span class="mi">5</span>
</pre>
                                </div>
                              </div>
                              <p>在表达式 <code
                                  class="docutils literal"><span class="pre">(+</span> <span class="pre">2</span> <span class="pre">3)</span></code>
                                里， <code class="docutils literal"><span class="pre">+</span></code> 称为操作符，而数字 <code
                                  class="docutils literal"><span class="pre">2</span></code> 跟 <code
                                  class="docutils literal"><span class="pre">3</span></code> 称为实参。</p>
                              <p>在日常生活中，我们会把表达式写作 <code
                                  class="docutils literal"><span class="pre">2</span> <span class="pre">+</span> <span class="pre">3</span></code>
                                ，但在 Lisp 里，我们把 <code class="docutils literal"><span class="pre">+</span></code>
                                操作符写在前面，接著写实参，再把整个表达式用一对括号包起来： <code
                                  class="docutils literal"><span class="pre">(+</span> <span class="pre">2</span> <span class="pre">3)</span></code>
                                。这称为<em>前序</em>表达式。一开始可能觉得这样写表达式有点怪，但事实上这种表示法是 Lisp 最美妙的东西之一。</p>
                              <p>举例来说，我们想把三个数加起来，用日常生活的表示法，要写两次 <code
                                  class="docutils literal"><span class="pre">+</span></code> 号，</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="mi">2</span> <span class="nb">+</span> <span class="mi">3</span> <span class="nb">+</span> <span class="mi">4</span>
</pre>
                                </div>
                              </div>
                              <p>而在 Lisp 里，只需要增加一个实参：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">+</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>日常生活中用 <code class="docutils literal"><span class="pre">+</span></code>
                                时，它必须有两个实参，一个在左，一个在右。前序表示法的灵活性代表著，在 Lisp 里， <code
                                  class="docutils literal"><span class="pre">+</span></code> 可以接受任意数量的实参，包含了没有实参：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">+</span><span class="p">)</span>
<span class="mi">0</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="nb">+</span> <span class="mi">2</span><span class="p">)</span>
<span class="mi">2</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="nb">+</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span>
<span class="mi">5</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="nb">+</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">)</span>
<span class="mi">9</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="nb">+</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">)</span>
<span class="mi">14</span>
</pre>
                                </div>
                              </div>
                              <p>由于操作符可接受不定数量的实参，我们需要用括号来标明表达式的开始与结束。</p>
                              <p>表达式可以嵌套。即表达式里的实参，可以是另一个复杂的表达式：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">/</span> <span class="p">(</span><span class="nb">-</span> <span class="mi">7</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">-</span> <span class="mi">4</span> <span class="mi">2</span><span class="p">))</span>
<span class="mi">3</span>
</pre>
                                </div>
                              </div>
                              <p>上面的表达式用中文来说是， (七减一) 除以 (四减二) 。</p>
                              <p>Lisp 表示法另一个美丽的地方是：它就是如此简单。所有的 Lisp 表达式，要么是 <code
                                  class="docutils literal"><span class="pre">1</span></code>
                                这样的数原子，要么是包在括号里，由零个或多个表达式所构成的列表。以下是合法的 Lisp 表达式：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="mi">2</span> <span class="p">(</span><span class="nb">+</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">)</span> <span class="p">(</span><span class="nb">/</span> <span class="p">(</span><span class="nb">-</span> <span class="mi">7</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">-</span> <span class="mi">4</span> <span class="mi">2</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p>稍后我们将理解到，所有的 Lisp 程序都采用这种形式。而像是 C
                                这种语言，有着更复杂的语法：算术表达式采用中序表示法；函数调用采用某种前序表示法，实参用逗号隔开；表达式用分号隔开；而一段程序用大括号隔开。</p>
                              <p>在 Lisp 里，我们用单一的表示法，来表达所有的概念。</p>
                            </div>
                            <div class="section" id="evaluation">
                              <h4>2.2 求值 (Evaluation)</h4>
                              <p>上一小节中，我们在顶层输入表达式，然后 Lisp 显示它们的值。在这节里我们深入理解一下表达式是如何被求值的。</p>
                              <p>在 Lisp 里， <code class="docutils literal"><span class="pre">+</span></code> 是函数，然而如
                                <code
                                  class="docutils literal"><span class="pre">(+</span> <span class="pre">2</span> <span class="pre">3)</span></code>
                                的表达式，是函数调用。
                              </p>
                              <p>当 Lisp 对函数调用求值时，它做下列两个步骤：</p>
                              <blockquote>
                                <div>
                                  <ol class="arabic simple">
                                    <li>首先从左至右对实参求值。在这个例子当中，实参对自身求值，所以实参的值分别是 <code
                                        class="docutils literal"><span class="pre">2</span></code> 跟 <code
                                        class="docutils literal"><span class="pre">3</span></code> 。</li>
                                    <li>实参的值传入以操作符命名的函数。在这个例子当中，将 <code
                                        class="docutils literal"><span class="pre">2</span></code> 跟 <code
                                        class="docutils literal"><span class="pre">3</span></code> 传给 <code
                                        class="docutils literal"><span class="pre">+</span></code> 函数，返回 <code
                                        class="docutils literal"><span class="pre">5</span></code> 。</li>
                                  </ol>
                                </div>
                              </blockquote>
                              <p>如果实参本身是函数调用的话，上述规则同样适用。以下是当 <code
                                  class="docutils literal"><span class="pre">(/</span> <span class="pre">(-</span> <span class="pre">7</span> <span class="pre">1)</span> <span class="pre">(-</span> <span class="pre">4</span> <span class="pre">2))</span></code>
                                表达式被求值时的情形：</p>
                              <blockquote>
                                <div>
                                  <ol class="arabic simple">
                                    <li>Lisp 对 <code
                                        class="docutils literal"><span class="pre">(-</span> <span class="pre">7</span> <span class="pre">1)</span></code>
                                      求值: <code class="docutils literal"><span class="pre">7</span></code> 求值为 <code
                                        class="docutils literal"><span class="pre">7</span></code> ， <code
                                        class="docutils literal"><span class="pre">1</span></code> 求值为 <code
                                        class="docutils literal"><span class="pre">1</span></code> ，它们被传给函数 <code
                                        class="docutils literal"><span class="pre">-</span></code> ，返回 <code
                                        class="docutils literal"><span class="pre">6</span></code> 。</li>
                                    <li>Lisp 对 <code
                                        class="docutils literal"><span class="pre">(-</span> <span class="pre">4</span> <span class="pre">2)</span></code>
                                      求值: <code class="docutils literal"><span class="pre">4</span></code> 求值为 <code
                                        class="docutils literal"><span class="pre">4</span></code> ， <code
                                        class="docutils literal"><span class="pre">2</span></code> 求值为 <code
                                        class="docutils literal"><span class="pre">2</span></code> ，它们被传给函数 <code
                                        class="docutils literal"><span class="pre">-</span></code> ，返回 <code
                                        class="docutils literal"><span class="pre">2</span></code> 。</li>
                                    <li>数值 <code class="docutils literal"><span class="pre">6</span></code> 与 <code
                                        class="docutils literal"><span class="pre">2</span></code> 被传入函数 <code
                                        class="docutils literal"><span class="pre">/</span></code> ，返回 <code
                                        class="docutils literal"><span class="pre">3</span></code> 。</li>
                                  </ol>
                                </div>
                              </blockquote>
                              <p>但不是所有的 Common Lisp 操作符都是函数，不过大部分是。函数调用都是这么求值。由左至右对实参求值，将它们的数值传入函数，来返回整个表达式的值。这称为 Common
                                Lisp 的求值规则。</p>
                              <div class="admonition note">
                                <p class="first admonition-title">Note</p>
                                <p>逃离麻烦</p>
                                <p>如果你试着输入 Lisp 不能理解的东西，它会打印一个错误讯息，接著带你到一种叫做<em>中断循环</em>（break loop）的顶层。
                                  中断循环给予有经验的程序员一个机会，来找出错误的原因，不过最初你只会想知道如何从中断循环中跳出。
                                  如何返回顶层取决于你所使用的 Common Lisp 实现。在这个假定的实现环境中，输入 <code
                                    class="docutils literal"><span class="pre">:abort</span></code> 跳出：</p>
                                <div class="highlight-cl">
                                  <div class="highlight">
                                    <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">/</span> <span class="mi">1</span> <span class="mi">0</span><span class="p">)</span>
<span class="nv">Error:</span> <span class="nv">Division</span> <span class="nv">by</span> <span class="nv">zero</span>
      <span class="nv">Options:</span> <span class="ss">:abort,</span> <span class="ss">:backtrace</span>
<span class="nv">&gt;&gt;</span> <span class="ss">:abort</span>
<span class="nb">&gt;</span>
</pre>
                                  </div>
                                </div>
                                <p class="last">附录 A 演示了如何调试 Lisp 程序，并给出一些常见的错误例子。</p>
                              </div>
                              <p>一个不遵守 Common Lisp 求值规则的操作符是 <code
                                  class="docutils literal"><span class="pre">quote</span></code> 。 <code
                                  class="docutils literal"><span class="pre">quote</span></code>
                                是一个特殊的操作符，意味着它自己有一套特别的求值规则。这个规则就是：什么也不做。 <code
                                  class="docutils literal"><span class="pre">quote</span></code> 操作符接受一个实参，并完封不动地返回它。
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="k">quote</span> <span class="p">(</span><span class="nb">+</span> <span class="mi">3</span> <span class="mi">5</span><span class="p">))</span>
<span class="p">(</span><span class="nb">+</span> <span class="mi">3</span> <span class="mi">5</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>为了方便起见，Common Lisp 定义 <code class="docutils literal"><span class="pre">'</span></code>
                                作为 <code class="docutils literal"><span class="pre">quote</span></code>
                                的缩写。你可以在任何的表达式前，贴上一个 <code class="docutils literal"><span class="pre">'</span></code>
                                ，与调用 <code class="docutils literal"><span class="pre">quote</span></code> 是同样的效果：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="o">&#39;</span><span class="p">(</span><span class="nb">+</span> <span class="mi">3</span> <span class="mi">5</span><span class="p">)</span>
<span class="p">(</span><span class="nb">+</span> <span class="mi">3</span> <span class="mi">5</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>使用缩写 <code class="docutils literal"><span class="pre">'</span></code> 比使用整个 <code
                                  class="docutils literal"><span class="pre">quote</span></code> 表达式更常见。</p>
                              <p>Lisp 提供 <code class="docutils literal"><span class="pre">quote</span></code>
                                作为一种<em>保护</em>表达式不被求值的方式。下一节将解释为什么这种保护很有用。</p>
                            </div>
                            <div class="section" id="data">
                              <h4>2.3 数据 (Data)<a class="headerlink" href="#data"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>Lisp 提供了所有在其他语言找的到的，以及其他语言所找不到的数据类型。一个我们已经使用过的类型是<em>整数</em>（integer），整数用一系列的数字来表示，比如：
                                <code class="docutils literal"><span class="pre">256</span></code> 。另一个 Common Lisp
                                与多数语言有关，并很常见的数据类型是<em>字符串</em>（string），字符串用一系列被双引号包住的字符串表示，比如： <code
                                  class="docutils literal"><span class="pre">&quot;ora</span> <span class="pre">et</span> <span class="pre">labora&quot;</span></code>
                                <a class="footnote-reference" href="#id2">[3]</a> 。整数与字符串一样，都是对自身求值的。
                              </p>
                              <table class="docutils footnote" frame="void" id="id2" rules="none">
                                <colgroup>
                                  <col class="label" />
                                  <col />
                                </colgroup>
                                <tbody valign="top">
                                  <tr>
                                    <td class="label"><a class="fn-backref" href="#id1">[3]</a></td>
                                    <td>“ora et labora” 是拉丁文，意思是祷告与工作。</td>
                                  </tr>
                                </tbody>
                              </table>
                              <p>有两个通常在别的语言所找不到的 Lisp 数据类型是<em>符号</em>（symbol）与<em>列表</em>（lists），<em>符号</em>是英语的单词
                                (words)。无论你怎么输入，通常会被转换为大写：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="ss">&#39;Artichoke</span>
<span class="nv">ARTICHOKE</span>
</pre>
                                </div>
                              </div>
                              <p>符号（通常）不对自身求值，所以要是想引用符号，应该像上例那样用 <code
                                  class="docutils literal"><span class="pre">'</span></code> 引用它。</p>
                              <p><em>列表</em>是由被括号包住的零个或多个元素来表示。元素可以是任何类型，包含列表本身。使用列表必须要引用，不然 Lisp 会以为这是个函数调用：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">my</span> <span class="mi">3</span> <span class="s">&quot;Sons&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="nv">MY</span> <span class="mi">3</span> <span class="s">&quot;Sons&quot;</span><span class="p">)</span>
<span class="nb">&gt;</span> <span class="o">&#39;</span><span class="p">(</span><span class="k">the</span> <span class="nb">list</span> <span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">)</span> <span class="nv">has</span> <span class="mi">3</span> <span class="nv">elements</span><span class="p">)</span>
<span class="p">(</span><span class="nv">THE</span> <span class="nv">LIST</span> <span class="p">(</span><span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span><span class="p">)</span> <span class="nv">HAS</span> <span class="mi">3</span> <span class="nv">ELEMENTS</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>注意引号保护了整个表达式（包含内部的子表达式）被求值。</p>
                              <p>你可以调用 <code class="docutils literal"><span class="pre">list</span></code> 来创建列表。由于
                                <code class="docutils literal"><span class="pre">list</span></code>
                                是函数，所以它的实参会被求值。这里我们看一个在函数 <code
                                  class="docutils literal"><span class="pre">list</span></code> 调用里面，调用 <code
                                  class="docutils literal"><span class="pre">+</span></code> 函数的例子：
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">list</span> <span class="ss">&#39;my</span> <span class="p">(</span><span class="nb">+</span> <span class="mi">2</span> <span class="mi">1</span><span class="p">)</span> <span class="s">&quot;Sons&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="nv">MY</span> <span class="mi">3</span> <span class="s">&quot;Sons&quot;</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>我们现在来到领悟 Lisp 最卓越特性的地方之一。<em>Lisp的程序是用列表来表示的</em>。如果实参的优雅与弹性不能说服你 Lisp
                                表示法是无价的工具，这里应该能使你信服。这代表着 Lisp 程序可以写出 Lisp 代码。 Lisp 程序员可以（并且经常）写出能为自己写程序的程序。</p>
                              <p>不过得到第 10 章，我们才来考虑这种程序，但现在了解到列表和表达式的关系是非常重要的，而不是被它们搞混。这也就是为什么我们需要 <code
                                  class="docutils literal"><span class="pre">quote</span></code>
                                。如果一个列表被引用了，则求值规则对列表自身来求值；如果没有被引用，则列表被视为是代码，依求值规则对列表求值后，返回它的值。</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">list</span> <span class="o">&#39;</span><span class="p">(</span><span class="nb">+</span> <span class="mi">2</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="mi">2</span> <span class="mi">1</span><span class="p">))</span>
<span class="p">((</span><span class="nb">+</span> <span class="mi">2</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">3</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>这里第一个实参被引用了，所以产生一个列表。第二个实参没有被引用，视为函数调用，经求值后得到一个数字。</p>
                              <p>在 Common Lisp 里有两种方法来表示空列表。你可以用一对不包括任何东西的括号来表示，或用符号 <code
                                  class="docutils literal"><span class="pre">nil</span></code>
                                来表示空表。你用哪种表示法来表示空表都没关系，但它们都会被显示为 <code
                                  class="docutils literal"><span class="pre">nil</span></code> ：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">()</span>
<span class="no">NIL</span>
<span class="nb">&gt;</span> <span class="no">nil</span>
<span class="no">NIL</span>
</pre>
                                </div>
                              </div>
                              <p>你不需要引用 <code class="docutils literal"><span class="pre">nil</span></code> （但引用也无妨），因为
                                <code class="docutils literal"><span class="pre">nil</span></code> 是对自身求值的。
                              </p>
                            </div>
                            <div class="section" id="list-operations">
                              <h4>2.4 列表操作 (List Operations)<a class="headerlink" href="#list-operations"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>用函数 <code class="docutils literal"><span class="pre">cons</span></code>
                                来构造列表。如果传入的第二个实参是列表，则返回由两个实参所构成的新列表，新列表为第一个实参加上第二个实参：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">cons</span> <span class="ss">&#39;a</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span><span class="p">))</span>
<span class="p">(</span><span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="nv">D</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>可以通过把新元素建立在空表之上，来构造一个新列表。上一节所看到的函数 <code
                                  class="docutils literal"><span class="pre">list</span></code> ，不过就是一个把几个元素加到 <code
                                  class="docutils literal"><span class="pre">nil</span></code> 上的快捷方式：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">cons</span> <span class="ss">&#39;a</span> <span class="p">(</span><span class="nb">cons</span> <span class="ss">&#39;b</span> <span class="no">nil</span><span class="p">))</span>
<span class="p">(</span><span class="nv">A</span> <span class="nv">B</span><span class="p">)</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="nb">list</span> <span class="ss">&#39;a</span> <span class="ss">&#39;b</span><span class="p">)</span>
<span class="p">(</span><span class="nv">A</span> <span class="nv">B</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>取出列表元素的基本函数是 <code class="docutils literal"><span class="pre">car</span></code> 和 <code
                                  class="docutils literal"><span class="pre">cdr</span></code> 。对列表取 <code
                                  class="docutils literal"><span class="pre">car</span></code> 返回第一个元素，而对列表取 <code
                                  class="docutils literal"><span class="pre">cdr</span></code> 返回第一个元素之后的所有元素：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">car</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">))</span>
<span class="nv">A</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="nb">cdr</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">))</span>
<span class="p">(</span><span class="nv">B</span> <span class="nv">C</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>你可以把 <code class="docutils literal"><span class="pre">car</span></code> 与 <code
                                  class="docutils literal"><span class="pre">cdr</span></code>
                                混合使用来取得列表中的任何元素。如果我们想要取得第三个元素，我们可以：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">car</span> <span class="p">(</span><span class="nb">cdr</span> <span class="p">(</span><span class="nb">cdr</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span><span class="p">))))</span>
<span class="nv">C</span>
</pre>
                                </div>
                              </div>
                              <p>不过，你可以用更简单的 <code class="docutils literal"><span class="pre">third</span></code>
                                来做到同样的事情：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">third</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span><span class="p">))</span>
<span class="nv">C</span>
</pre>
                                </div>
                              </div>
                            </div>
                            <div class="section" id="truth">
                              <h4>2.5 真与假 (Truth)<a class="headerlink" href="#truth"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>在 Common Lisp 里，符号 <code class="docutils literal"><span class="pre">t</span></code>
                                是表示逻辑 <code class="docutils literal"><span class="pre">真</span></code> 的缺省值。与 <code
                                  class="docutils literal"><span class="pre">nil</span></code> 相同， <code
                                  class="docutils literal"><span class="pre">t</span></code> 也是对自身求值的。如果实参是一个列表，则函数
                                <code class="docutils literal"><span class="pre">listp</span></code> 返回 <code
                                  class="docutils literal"><span class="pre">真</span></code> ：
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">listp</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">))</span>
<span class="no">T</span>
</pre>
                                </div>
                              </div>
                              <p>函数的返回值将会被解释成逻辑 <code class="docutils literal"><span class="pre">真</span></code> 或逻辑
                                <code class="docutils literal"><span class="pre">假</span></code>
                                时，则称此函数为谓词（<em>predicate</em>）。在 Common Lisp 里，谓词的名字通常以 <code
                                  class="docutils literal"><span class="pre">p</span></code> 结尾。
                              </p>
                              <p>逻辑 <code class="docutils literal"><span class="pre">假</span></code> 在 Common Lisp 里，用
                                <code class="docutils literal"><span class="pre">nil</span></code> ，即空表来表示。如果我们传给 <code
                                  class="docutils literal"><span class="pre">listp</span></code> 的实参不是列表，则返回 <code
                                  class="docutils literal"><span class="pre">nil</span></code> 。
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">listp</span> <span class="mi">27</span><span class="p">)</span>
<span class="no">NIL</span>
</pre>
                                </div>
                              </div>
                              <p>由于 <code class="docutils literal"><span class="pre">nil</span></code> 在 Common Lisp
                                里扮演两个角色，如果实参是一个空表，则函数 <code
                                  class="docutils literal"><span class="pre">null</span></code> 返回 <code
                                  class="docutils literal"><span class="pre">真</span></code> 。</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">null</span> <span class="no">nil</span><span class="p">)</span>
<span class="no">T</span>
</pre>
                                </div>
                              </div>
                              <p>而如果实参是逻辑 <code class="docutils literal"><span class="pre">假</span></code> ，则函数 <code
                                  class="docutils literal"><span class="pre">not</span></code> 返回 <code
                                  class="docutils literal"><span class="pre">真</span></code> ：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">not</span> <span class="no">nil</span><span class="p">)</span>
<span class="no">T</span>
</pre>
                                </div>
                              </div>
                              <p><code class="docutils literal"><span class="pre">null</span></code> 与 <code
                                  class="docutils literal"><span class="pre">not</span></code> 做的是一样的事情。</p>
                              <p>在 Common Lisp 里，最简单的条件式是 <code
                                  class="docutils literal"><span class="pre">if</span></code> 。通常接受三个实参：一个 <em>test</em>
                                表达式，一个 <em>then</em> 表达式和一个 <em>else</em> 表达式。若 <code
                                  class="docutils literal"><span class="pre">test</span></code> 表达式求值为逻辑 <code
                                  class="docutils literal"><span class="pre">真</span></code> ，则对 <code
                                  class="docutils literal"><span class="pre">then</span></code> 表达式求值，并返回这个值。若 <code
                                  class="docutils literal"><span class="pre">test</span></code> 表达式求值为逻辑 <code
                                  class="docutils literal"><span class="pre">假</span></code> ，则对 <code
                                  class="docutils literal"><span class="pre">else</span></code> 表达式求值，并返回这个值：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">listp</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">))</span>
      <span class="p">(</span><span class="nb">+</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">+</span> <span class="mi">5</span> <span class="mi">6</span><span class="p">))</span>
<span class="mi">3</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">listp</span> <span class="mi">27</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">+</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">+</span> <span class="mi">5</span> <span class="mi">6</span><span class="p">))</span>
<span class="mi">11</span>
</pre>
                                </div>
                              </div>
                              <p>与 <code class="docutils literal"><span class="pre">quote</span></code> 相同， <code
                                  class="docutils literal"><span class="pre">if</span></code>
                                是特殊的操作符。不能用函数来实现，因为实参在函数调用时永远会被求值，而 <code
                                  class="docutils literal"><span class="pre">if</span></code> 的特点是，只有最后两个实参的其中一个会被求值。
                                <code class="docutils literal"><span class="pre">if</span></code>
                                的最后一个实参是选择性的。如果忽略它的话，缺省值是 <code
                                  class="docutils literal"><span class="pre">nil</span></code> ：
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">listp</span> <span class="mi">27</span><span class="p">)</span>
     <span class="p">(</span><span class="nb">+</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">))</span>
<span class="no">NIL</span>
</pre>
                                </div>
                              </div>
                              <p>虽然 <code class="docutils literal"><span class="pre">t</span></code> 是逻辑 <code
                                  class="docutils literal"><span class="pre">真</span></code> 的缺省表示法，任何非 <code
                                  class="docutils literal"><span class="pre">nil</span></code> 的东西，在逻辑的上下文里通通被视为 <code
                                  class="docutils literal"><span class="pre">真</span></code> 。</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="k">if</span> <span class="mi">27</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">)</span>
<span class="mi">1</span>
</pre>
                                </div>
                              </div>
                              <p>逻辑操作符 <code class="docutils literal"><span class="pre">and</span></code> 和 <code
                                  class="docutils literal"><span class="pre">or</span></code>
                                与条件式类似。两者都接受任意数量的实参，但仅对能影响返回值的几个实参求值。如果所有的实参都为 <code
                                  class="docutils literal"><span class="pre">真</span></code> （即非 <code
                                  class="docutils literal"><span class="pre">nil</span></code> ），那么 <code
                                  class="docutils literal"><span class="pre">and</span></code> 会返回最后一个实参的值：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">and</span> <span class="no">t</span> <span class="p">(</span><span class="nb">+</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">))</span>
<span class="mi">3</span>
</pre>
                                </div>
                              </div>
                              <p>如果其中一个实参为 <code class="docutils literal"><span class="pre">假</span></code>
                                ，那之后的所有实参都不会被求值。 <code class="docutils literal"><span class="pre">or</span></code>
                                也是如此，只要碰到一个为 <code class="docutils literal"><span class="pre">真</span></code>
                                的实参，就停止对之后所有的实参求值。</p>
                              <p>以上这两个操作符称为<em>宏</em>。宏和特殊的操作符一样，可以绕过一般的求值规则。第十章解释了如何编写你自己的宏。</p>
                            </div>
                            <div class="section" id="functions">
                              <h4>2.6 函数 (Functions)<a class="headerlink" href="#functions"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>你可以用 <code class="docutils literal"><span class="pre">defun</span></code>
                                来定义新函数。通常接受三个以上的实参：一个名字，一组用列表表示的实参，以及一个或多个组成函数体的表达式。我们可能会这样定义 <code
                                  class="docutils literal"><span class="pre">third</span></code> ：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">defun</span> <span class="nv">our-third</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span>
   <span class="p">(</span><span class="nb">car</span> <span class="p">(</span><span class="nb">cdr</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">x</span><span class="p">))))</span>
<span class="nv">OUR-THIRD</span>
</pre>
                                </div>
                              </div>
                              <p>第一个实参说明此函数的名称将是 <code
                                  class="docutils literal"><span class="pre">our-third</span></code> 。第二个实参，一个列表 <code
                                  class="docutils literal"><span class="pre">(x)</span></code> ，说明这个函数会接受一个形参： <code
                                  class="docutils literal"><span class="pre">x</span></code>
                                。这样使用的占位符符号叫做<em>变量</em>。当变量代表了传入函数的实参时，如这里的 <code
                                  class="docutils literal"><span class="pre">x</span></code> ，又被叫做<em>形参</em>。</p>
                              <p>定义的剩余部分， <code
                                  class="docutils literal"><span class="pre">(car</span> <span class="pre">(cdr</span> <span class="pre">(cdr</span> <span class="pre">x)))</span></code>
                                ，即所谓的函数主体。它告诉 Lisp 该怎么计算此函数的返回值。所以调用一个 <code
                                  class="docutils literal"><span class="pre">our-third</span></code> 函数，对于我们作为实参传入的任何
                                <code class="docutils literal"><span class="pre">x</span></code> ，会返回 <code
                                  class="docutils literal"><span class="pre">(car</span> <span class="pre">(cdr</span> <span class="pre">(cdr</span> <span class="pre">x)))</span></code>
                                ：
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">our-third</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span><span class="p">))</span>
<span class="nv">C</span>
</pre>
                                </div>
                              </div>
                              <p>
                                既然我们已经讨论过了变量，理解符号是什么就更简单了。符号是变量的名字，符号本身就是以对象的方式存在。这也是为什么符号，必须像列表一样被引用。列表必须被引用，不然会被视为代码。符号必须要被引用，不然会被当作变量。
                              </p>
                              <p>你可以把函数定义想成广义版的 Lisp 表达式。下面的表达式测试 <code
                                  class="docutils literal"><span class="pre">1</span></code> 和 <code
                                  class="docutils literal"><span class="pre">4</span></code> 的和是否大于 <code
                                  class="docutils literal"><span class="pre">3</span></code> ：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">+</span> <span class="mi">1</span> <span class="mi">4</span><span class="p">)</span> <span class="mi">3</span><span class="p">)</span>
<span class="no">T</span>
</pre>
                                </div>
                              </div>
                              <p>通过将这些数字替换为变量，我们可以写个函数，测试任两数之和是否大于第三个数：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">defun</span> <span class="nv">sum-greater</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span><span class="p">)</span>
   <span class="p">(</span><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span> <span class="nv">z</span><span class="p">))</span>
<span class="nv">SUM-GREATER</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="nv">sum-greater</span> <span class="mi">1</span> <span class="mi">4</span> <span class="mi">3</span><span class="p">)</span>
<span class="no">T</span>
</pre>
                                </div>
                              </div>
                              <p>Lisp 不对程序、过程以及函数作区别。函数做了所有的事情（事实上，函数是语言的主要部分）。如果你想要把你的函数之一作为主函数（<em>main</em>
                                function），可以这么做，但平常你就能在顶层中调用任何函数。这表示当你编程时，你可以把程序拆分成一小块一小块地来做调试。</p>
                            </div>
                            <div class="section" id="recursion">
                              <h4>2.7 递归 (Recursion)<a class="headerlink" href="#recursion"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>上一节我们所定义的函数，调用了别的函数来帮它们做事。比如 <code
                                  class="docutils literal"><span class="pre">sum-greater</span></code> 调用了 <code
                                  class="docutils literal"><span class="pre">+</span></code> 和 <code
                                  class="docutils literal"><span class="pre">&gt;</span></code>
                                。函数可以调用任何函数，包括自己。自己调用自己的函数是<em>递归</em>的。 Common Lisp 函数 <code
                                  class="docutils literal"><span class="pre">member</span></code>
                                ，测试某个东西是否为列表的成员。下面是定义成递归函数的简化版：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">defun</span> <span class="nv">our-member</span> <span class="p">(</span><span class="nv">obj</span> <span class="nv">lst</span><span class="p">)</span>
   <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">null</span> <span class="nv">lst</span><span class="p">)</span>
       <span class="no">nil</span>
   <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">eql</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">lst</span><span class="p">)</span> <span class="nv">obj</span><span class="p">)</span>
       <span class="nv">lst</span>
       <span class="p">(</span><span class="nv">our-member</span> <span class="nv">obj</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">lst</span><span class="p">)))))</span>
<span class="nv">OUR-MEMBER</span>
</pre>
                                </div>
                              </div>
                              <p>谓词 <code class="docutils literal"><span class="pre">eql</span></code>
                                测试它的两个实参是否相等；此外，这个定义的所有东西我们之前都学过了。下面是运行的情形：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">our-member</span> <span class="ss">&#39;b</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">))</span>
<span class="p">(</span><span class="nv">B</span> <span class="nv">C</span><span class="p">)</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="nv">our-member</span> <span class="ss">&#39;z</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">))</span>
<span class="no">NIL</span>
</pre>
                                </div>
                              </div>
                              <p>下面是 <code class="docutils literal"><span class="pre">our-member</span></code>
                                的定义对应到英语的描述。为了知道一个对象 <code class="docutils literal"><span class="pre">obj</span></code>
                                是否为列表 <code class="docutils literal"><span class="pre">lst</span></code> 的成员，我们</p>
                              <blockquote>
                                <div>
                                  <ol class="arabic simple">
                                    <li>首先检查 <code class="docutils literal"><span class="pre">lst</span></code>
                                      列表是否为空列表。如果是空列表，那 <code
                                        class="docutils literal"><span class="pre">obj</span></code> 一定不是它的成员，结束。</li>
                                    <li>否则，若 <code class="docutils literal"><span class="pre">obj</span></code>
                                      是列表的第一个元素时，则它是列表的成员。</li>
                                    <li>不然只有当 <code class="docutils literal"><span class="pre">obj</span></code>
                                      是列表其余部分的元素时，它才是列表的成员。</li>
                                  </ol>
                                </div>
                              </blockquote>
                              <p>当你想要了解递归函数是怎么工作时，把它翻成这样的叙述有助于你理解。</p>
                              <p>
                                起初，许多人觉得递归函数很难理解。大部分的理解难处，来自于对函数使用了错误的比喻。人们倾向于把函数理解为某种机器。原物料像实参一样抵达；某些工作委派给其它函数；最后组装起来的成品，被作为返回值运送出去。如果我们用这种比喻来理解函数，那递归就自相矛盾了。机器怎可以把工作委派给自己？它已经在忙碌中了。
                              </p>
                              <p>
                                较好的比喻是，把函数想成一个处理的过程。在过程里，递归是在自然不过的事情了。日常生活中我们经常看到递归的过程。举例来说，假设一个历史学家，对欧洲历史上的人口变化感兴趣。研究文献的过程很可能是：
                              </p>
                              <blockquote>
                                <div>
                                  <ol class="arabic simple">
                                    <li>取得一个文献的复本</li>
                                    <li>寻找关于人口变化的资讯</li>
                                    <li>如果这份文献提到其它可能有用的文献，研究它们。</li>
                                  </ol>
                                </div>
                              </blockquote>
                              <p>过程是很容易理解的，而且它是递归的，因为第三个步骤可能带出一个或多个同样的过程。</p>
                              <p>所以，别把 <code class="docutils literal"><span class="pre">our-member</span></code>
                                想成是一种测试某个东西是否为列表成员的机器。而是把它想成是，决定某个东西是否为列表成员的规则。如果我们从这个角度来考虑函数，那么递归的矛盾就不复存在了。</p>
                            </div>
                            <div class="section" id="lisp-reading-lisp">
                              <h4>2.8 阅读 Lisp (Reading Lisp)<a class="headerlink" href="#lisp-reading-lisp"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>上一节我们所定义的 <code class="docutils literal"><span class="pre">our-member</span></code>
                                以五个括号结尾。更复杂的函数定义更可能以七、八个括号结尾。刚学 Lisp 的人看到这么多括号会感到气馁。这叫人怎么读这样的程序，更不用说编了？怎么知道哪个括号该跟哪个匹配？
                              </p>
                              <p>答案是，你不需要这么做。 Lisp 程序员用缩排来阅读及编写程序，而不是括号。当他们在写程序时，他们让文字编辑器显示哪个括号该与哪个匹配。任何好的文字编辑器，特别是 Lisp
                                系统自带的，都应该能做到括号匹配（paren-matching）。在这种编辑器中，当你输入一个括号时，编辑器指出与其匹配的那一个。如果你的编辑器不能匹配括号，别用了，想想如何让它做到，因为没有这个功能，你根本不可能编
                                Lisp 程序 <a class="footnote-reference" href="#id5" id="id3">[1]</a> 。</p>
                              <p>有了好的编辑器之后，括号匹配不再会是问题。而且由于 Lisp 缩排有通用的惯例，阅读程序也不是个问题。因为所有人都使用一样的习惯，你可以忽略那些括号，通过缩排来阅读程序。
                              </p>
                              <p>任何有经验的 Lisp 黑客，会发现如果是这样的 <code
                                  class="docutils literal"><span class="pre">our-member</span></code> 的定义很难阅读：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">our-member</span> <span class="p">(</span><span class="nv">obj</span> <span class="nv">lst</span><span class="p">)</span> <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">null</span> <span class="nv">lst</span><span class="p">)</span> <span class="no">nil</span> <span class="p">(</span><span class="k">if</span>
<span class="p">(</span><span class="nb">eql</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">lst</span><span class="p">)</span> <span class="nv">obj</span><span class="p">)</span> <span class="nv">lst</span> <span class="p">(</span><span class="nv">our-member</span> <span class="nv">obj</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">lst</span><span class="p">)))))</span>
</pre>
                                </div>
                              </div>
                              <p>但如果程序适当地缩排时，他就没有问题了。可以忽略大部分的括号而仍能读懂它：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">defun</span> <span class="nv">our-member</span> <span class="p">(</span><span class="nv">obj</span> <span class="nv">lst</span><span class="p">)</span>
 <span class="k">if</span> <span class="nb">null</span> <span class="nv">lst</span>
    <span class="no">nil</span>
    <span class="k">if</span> <span class="nb">eql</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">lst</span><span class="p">)</span> <span class="nv">obj</span>
       <span class="nv">lst</span>
       <span class="nv">our-member</span> <span class="nv">obj</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">lst</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>事实上，这是你在纸上写 Lisp 程序的实用方法。等输入程序至计算机的时候，可以利用编辑器匹配括号的功能。</p>
                            </div>
                            <div class="section" id="input-and-output">
                              <h4>2.9 输入输出 (Input and Output)<a class="headerlink" href="#input-and-output"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>到目前为止，我们已经利用顶层偷偷使用了 I/O 。对实际的交互程序来说，这似乎还是不太够。在这一节，我们来看几个输入输出的函数。</p>
                              <p>最普遍的 Common Lisp 输出函数是 <code
                                  class="docutils literal"><span class="pre">format</span></code>
                                。接受两个或两个以上的实参，第一个实参决定输出要打印到哪里，第二个实参是字符串模版，而剩余的实参，通常是要插入到字符串模版，用打印表示法（printed
                                representation）所表示的对象。下面是一个典型的例子：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;~A plus ~A equals ~A. ~%&quot;</span> <span class="mi">2</span> <span class="mi">3</span> <span class="p">(</span><span class="nb">+</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">))</span>
<span class="mi">2</span> <span class="nv">plus</span> <span class="mi">3</span> <span class="nv">equals</span> <span class="mi">5.</span>
<span class="no">NIL</span>
</pre>
                                </div>
                              </div>
                              <p>注意到有两个东西被打印出来。第一行是 <code
                                  class="docutils literal"><span class="pre">format</span></code> 印出来的。第二行是调用 <code
                                  class="docutils literal"><span class="pre">format</span></code>
                                函数的返回值，就像平常顶层会打印出来的一样。通常像 <code
                                  class="docutils literal"><span class="pre">format</span></code>
                                这种函数不会直接在顶层调用，而是在程序内部里使用，所以返回值不会被看到。</p>
                              <p><code class="docutils literal"><span class="pre">format</span></code> 的第一个实参 <code
                                  class="docutils literal"><span class="pre">t</span></code>
                                ，表示输出被送到缺省的地方去。通常是顶层。第二个实参是一个用作输出模版的字符串。在这字符串里，每一个 <code
                                  class="docutils literal"><span class="pre">~A</span></code> 表示了被填入的位置，而 <code
                                  class="docutils literal"><span class="pre">~%</span></code> 表示一个换行。这些被填入的位置依序由后面的实参填入。
                              </p>
                              <p>标准的输入函数是 <code class="docutils literal"><span class="pre">read</span></code>
                                。当没有实参时，会读取缺省的位置，通常是顶层。下面这个函数，提示使用者输入，并返回任何输入的东西：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">askem</span> <span class="p">(</span><span class="nb">string</span><span class="p">)</span>
 <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;~A&quot;</span> <span class="nb">string</span><span class="p">)</span>
 <span class="p">(</span><span class="nb">read</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p>它的行为如下：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">askem</span> <span class="s">&quot;How old are you?&quot;</span><span class="p">)</span>
<span class="nv">How</span> <span class="nv">old</span> <span class="nv">are</span> <span class="nv">you?29</span>

<span class="mi">29</span>
</pre>
                                </div>
                              </div>
                              <p>记住 <code class="docutils literal"><span class="pre">read</span></code>
                                会一直永远等在这里，直到你输入了某些东西，并且（通常要）按下回车。因此，不打印明确的提示信息是很不明智的，程序会给人已经死机的印象，但其实它是在等待输入。</p>
                              <p>第二件关于 <code class="docutils literal"><span class="pre">read</span></code>
                                所需要知道的事是，它很强大： <code class="docutils literal"><span class="pre">read</span></code>
                                是一个完整的 Lisp 解析器（parser）。不仅是可以读入字符，然后当作字符串返回它们。它解析它所读入的东西，并返回产生出来的 Lisp
                                对象。在上述的例子，它返回一个数字。</p>
                              <p><code class="docutils literal"><span class="pre">askem</span></code>
                                的定义虽然很短，但体现出一些我们在之前的函数没看过的东西。函数主体可以有不只一个表达式。函数主体可以有任意数量的表达式。当函数被调用时，会依序求值，函数会返回最后一个的值。
                              </p>
                              <p>在之前的每一节中，我们坚持所谓“纯粹的” Lisp ── 即没有副作用的 Lisp 。副作用是指，表达式被求值后，对外部世界的状态做了某些改变。当我们对一个如 <code
                                  class="docutils literal"><span class="pre">(+</span> <span class="pre">1</span> <span class="pre">2)</span></code>
                                这样纯粹的 Lisp 表达式求值时，没有产生副作用。它只返回一个值。但当我们调用 <code
                                  class="docutils literal"><span class="pre">format</span></code>
                                时，它不仅返回值，还印出了某些东西。这就是一种副作用。</p>
                              <p>
                                当我们想要写没有副作用的程序时，则定义多个表达式的函数主体就没有意义了。最后一个表达式的值，会被当成函数的返回值，而之前表达式的值都被舍弃了。如果这些表达式没有副作用，你没有任何理由告诉
                                Lisp ，为什么要去对它们求值。</p>
                            </div>
                            <div class="section" id="variables">
                              <h4>2.10 变量 (Variables)<a class="headerlink" href="#variables"
                                  title="Permalink to this headline">¶</a></h4>
                              <p><code class="docutils literal"><span class="pre">let</span></code> 是一个最常用的 Common Lisp
                                的操作符之一，它让你引入新的局部变量（local variable）：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">x</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nv">y</span> <span class="mi">2</span><span class="p">))</span>
     <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">))</span>
<span class="mi">3</span>
</pre>
                                </div>
                              </div>
                              <p>一个 <code class="docutils literal"><span class="pre">let</span></code>
                                表达式有两个部分。第一个部分是一组创建新变量的指令，指令的形式为 <em>(variable expression)</em>
                                。每一个变量会被赋予相对应表达式的值。上述的例子中，我们创造了两个变量， <code
                                  class="docutils literal"><span class="pre">x</span></code> 和 <code
                                  class="docutils literal"><span class="pre">y</span></code> ，分别被赋予初始值 <code
                                  class="docutils literal"><span class="pre">1</span></code> 和 <code
                                  class="docutils literal"><span class="pre">2</span></code> 。这些变量只在 <code
                                  class="docutils literal"><span class="pre">let</span></code> 的函数体内有效。</p>
                              <p>一组变量与数值之后，是一个有表达式的函数体，表达式依序被求值。但这个例子里，只有一个表达式，调用 <code
                                  class="docutils literal"><span class="pre">+</span></code> 函数。最后一个表达式的求值结果作为 <code
                                  class="docutils literal"><span class="pre">let</span></code> 的返回值。以下是一个用 <code
                                  class="docutils literal"><span class="pre">let</span></code> 所写的，更有选择性的 <code
                                  class="docutils literal"><span class="pre">askem</span></code> 函数：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">ask-number</span> <span class="p">()</span>
 <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;Please enter a number. &quot;</span><span class="p">)</span>
 <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">val</span> <span class="p">(</span><span class="nb">read</span><span class="p">)))</span>
   <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">numberp</span> <span class="nv">val</span><span class="p">)</span>
       <span class="nv">val</span>
       <span class="p">(</span><span class="nv">ask-number</span><span class="p">))))</span>
</pre>
                                </div>
                              </div>
                              <p>这个函数创建了变量 <code class="docutils literal"><span class="pre">val</span></code> 来储存 <code
                                  class="docutils literal"><span class="pre">read</span></code>
                                所返回的对象。因为它知道该如何处理这个对象，函数可以先观察你的输入，再决定是否返回它。你可能猜到了， <code
                                  class="docutils literal"><span class="pre">numberp</span></code> 是一个谓词，测试它的实参是否为数字。
                              </p>
                              <p>如果使用者不是输入一个数字， <code
                                  class="docutils literal"><span class="pre">ask-number</span></code>
                                会持续调用自己。最后得到一个只接受数字的函数：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">ask-number</span><span class="p">)</span>
<span class="nv">Please</span> <span class="nv">enter</span> <span class="nv">a</span> <span class="nv">number.</span> <span class="nv">a</span>
<span class="nv">Please</span> <span class="nv">enter</span> <span class="nv">a</span> <span class="nv">number.</span> <span class="p">(</span><span class="nv">ho</span> <span class="nv">hum</span><span class="p">)</span>
<span class="nv">Please</span> <span class="nv">enter</span> <span class="nv">a</span> <span class="nv">number.</span> <span class="mi">52</span>
<span class="mi">52</span>
</pre>
                                </div>
                              </div>
                              <p>我们已经看过的这些变量都叫做局部变量。它们只在特定的上下文里有效。另外还有一种变量叫做全局变量（global variable），是在任何地方都是可视的。 <a
                                  class="footnote-reference" href="#id6" id="id4">[2]</a></p>
                              <p>你可以给 <code class="docutils literal"><span class="pre">defparameter</span></code>
                                传入符号和值，来创建一个全局变量：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">defparameter</span> <span class="vg">*glob*</span> <span class="mi">99</span><span class="p">)</span>
<span class="vg">*GLOB*</span>
</pre>
                                </div>
                              </div>
                              <p>全局变量在任何地方都可以存取，除了在定义了相同名字的区域变量的表达式里。为了避免这种情形发生，通常我们在给全局变量命名时，以星号作开始与结束。刚才我们创造的变量可以念作
                                “星-glob-星” (star-glob-star)。</p>
                              <p>你也可以用 <code class="docutils literal"><span class="pre">defconstant</span></code>
                                来定义一个全局的常量：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defconstant</span> <span class="nv">limit</span> <span class="p">(</span><span class="nb">+</span> <span class="vg">*glob*</span> <span class="mi">1</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p>我们不需要给常量一个独一无二的名字，因为如果有相同名字存在，就会有错误产生 (error)。如果你想要检查某些符号，是否为一个全局变量或常量，使用 <code
                                  class="docutils literal"><span class="pre">boundp</span></code> 函数：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">boundp</span> <span class="ss">&#39;*glob*</span><span class="p">)</span>
<span class="no">T</span>
</pre>
                                </div>
                              </div>
                            </div>
                            <div class="section" id="assignment">
                              <h4>2.11 赋值 (Assignment)<a class="headerlink" href="#assignment"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>在 Common Lisp 里，最普遍的赋值操作符（assignment operator）是 <code
                                  class="docutils literal"><span class="pre">setf</span></code> 。可以用来给全局或局部变量赋值：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">setf</span> <span class="vg">*glob*</span> <span class="mi">98</span><span class="p">)</span>
<span class="mi">98</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">n</span> <span class="mi">10</span><span class="p">))</span>
   <span class="p">(</span><span class="nb">setf</span> <span class="nv">n</span> <span class="mi">2</span><span class="p">)</span>
   <span class="nv">n</span><span class="p">)</span>
<span class="mi">2</span>
</pre>
                                </div>
                              </div>
                              <p>如果 <code class="docutils literal"><span class="pre">setf</span></code>
                                的第一个实参是符号（symbol），且符号不是某个局部变量的名字，则 <code
                                  class="docutils literal"><span class="pre">setf</span></code> 把这个符号设为全局变量：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">setf</span> <span class="nv">x</span> <span class="p">(</span><span class="nb">list</span> <span class="ss">&#39;a</span> <span class="ss">&#39;b</span> <span class="ss">&#39;c</span><span class="p">))</span>
<span class="p">(</span><span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>也就是说，通过赋值，你可以隐式地创建全局变量。
                                不过，一般来说，还是使用 <code class="docutils literal"><span class="pre">defparameter</span></code>
                                明确地创建全局变量比较好。</p>
                              <p>你不仅可以给变量赋值。传入 <code class="docutils literal"><span class="pre">setf</span></code>
                                的第一个实参，还可以是表达式或变量名。在这种情况下，第二个实参的值被插入至第一个实参所引用的位置：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">x</span><span class="p">)</span> <span class="ss">&#39;n</span><span class="p">)</span>
<span class="nv">N</span>
<span class="nb">&gt;</span> <span class="nv">x</span>
<span class="p">(</span><span class="nv">N</span> <span class="nv">B</span> <span class="nv">C</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p><code class="docutils literal"><span class="pre">setf</span></code>
                                的第一个实参几乎可以是任何引用到特定位置的表达式。所有这样的操作符在附录 D 中被标注为 “可设置的”（“settable”）。你可以给 <code
                                  class="docutils literal"><span class="pre">setf</span></code> 传入（偶数）个实参。一个这样的表达式</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">setf</span> <span class="nv">a</span> <span class="ss">&#39;b</span>
      <span class="nv">c</span> <span class="ss">&#39;d</span>
      <span class="nv">e</span> <span class="ss">&#39;f</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>等同于依序调用三个单独的 <code class="docutils literal"><span class="pre">setf</span></code> 函数：
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">setf</span> <span class="nv">a</span> <span class="ss">&#39;b</span><span class="p">)</span>
<span class="p">(</span><span class="nb">setf</span> <span class="nv">c</span> <span class="ss">&#39;d</span><span class="p">)</span>
<span class="p">(</span><span class="nb">setf</span> <span class="nv">e</span> <span class="ss">&#39;f</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                            </div>
                            <div class="section" id="functional-programming">
                              <h4>2.12 函数式编程 (Functional Programming)<a class="headerlink"
                                  href="#functional-programming" title="Permalink to this headline">¶</a></h4>
                              <p>函数式编程意味着撰写利用返回值而工作的程序，而不是修改东西。它是 Lisp 的主流范式。大部分 Lisp 的内置函数被调用是为了取得返回值，而不是副作用。</p>
                              <p>举例来说，函数 <code class="docutils literal"><span class="pre">remove</span></code>
                                接受一个对象和一个列表，返回不含这个对象的新列表：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">setf</span> <span class="nv">lst</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">c</span> <span class="nv">a</span> <span class="nv">r</span> <span class="nv">a</span> <span class="no">t</span><span class="p">))</span>
<span class="p">(</span><span class="nv">C</span> <span class="nv">A</span> <span class="nv">R</span> <span class="nv">A</span> <span class="no">T</span><span class="p">)</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="nb">remove</span> <span class="ss">&#39;a</span> <span class="nv">lst</span><span class="p">)</span>
<span class="p">(</span><span class="nv">C</span> <span class="nv">R</span> <span class="no">T</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>为什么不干脆说 <code class="docutils literal"><span class="pre">remove</span></code>
                                从列表里移除一个对象？因为它不是这么做的。原来的表没有被改变：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="nv">lst</span>
<span class="p">(</span><span class="nv">C</span> <span class="nv">A</span> <span class="nv">R</span> <span class="nv">A</span> <span class="no">T</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>若你真的想从列表里移除某些东西怎么办？在 Lisp 通常你这么做，把这个列表当作实参，传入某个函数，并使用 <code
                                  class="docutils literal"><span class="pre">setf</span></code> 来处理返回值。要移除所有在列表 <code
                                  class="docutils literal"><span class="pre">x</span></code> 的 <code
                                  class="docutils literal"><span class="pre">a</span></code> ，我们可以说：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">setf</span> <span class="nv">x</span> <span class="p">(</span><span class="nb">remove</span> <span class="ss">&#39;a</span> <span class="nv">x</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p>函数式编程本质上意味着避免使用如 <code class="docutils literal"><span class="pre">setf</span></code>
                                的函数。起初可能觉得这根本不可能，更遑论去做了。怎么可以只凭返回值来建立程序？</p>
                              <p>完全不用到副作用是很不方便的。然而，随着你进一步阅读，会惊讶地发现需要用到副作用的地方很少。副作用用得越少，你就更上一层楼。</p>
                              <p>函数式编程最重要的优点之一是，它允许交互式测试（interactive
                                testing）。在纯函数式的程序里，你可以测试每个你写的函数。如果它返回你预期的值，你可以有信心它是对的。这额外的信心，集结起来，会产生巨大的差别。当你改动了程序里的任何一个地方，会得到即时的改变。而这种即时的改变，使我们有一种新的编程风格。类比于电话与信件，让我们有一种新的通讯方式。
                              </p>
                            </div>
                            <div class="section" id="iteration">
                              <h4>2.13 迭代 (Iteration)<a class="headerlink" href="#iteration"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>当我们想重复做一些事情时，迭代比递归来得更自然。典型的例子是用迭代来产生某种表格。这个函数</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">show-squares</span> <span class="p">(</span><span class="nv">start</span> <span class="nv">end</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">do</span> <span class="p">((</span><span class="nv">i</span> <span class="nv">start</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">i</span> <span class="mi">1</span><span class="p">)))</span>
      <span class="p">((</span><span class="nb">&gt;</span> <span class="nv">i</span> <span class="nv">end</span><span class="p">)</span> <span class="ss">&#39;done</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;~A ~A~%&quot;</span> <span class="nv">i</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">i</span> <span class="nv">i</span><span class="p">))))</span>
</pre>
                                </div>
                              </div>
                              <p>列印从 <code class="docutils literal"><span class="pre">start</span></code> 到 <code
                                  class="docutils literal"><span class="pre">end</span></code> 之间的整数的平方：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">show-squares</span> <span class="mi">2</span> <span class="mi">5</span><span class="p">)</span>
<span class="mi">2</span> <span class="mi">4</span>
<span class="mi">3</span> <span class="mi">9</span>
<span class="mi">4</span> <span class="mi">16</span>
<span class="mi">5</span> <span class="mi">25</span>
<span class="nv">DONE</span>
</pre>
                                </div>
                              </div>
                              <p><code class="docutils literal"><span class="pre">do</span></code> 宏是 Common Lisp
                                里最基本的迭代操作符。和 <code class="docutils literal"><span class="pre">let</span></code> 类似，
                                <code class="docutils literal"><span class="pre">do</span></code>
                                可以创建变量，而第一个实参是一组变量的规格说明列表。每个元素可以是以下的形式
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nv">variable</span> <span class="nv">initial</span> <span class="nv">update</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>其中 <em>variable</em> 是一个符号， <em>initial</em> 和 <em>update</em> 是表达式。最初每个变量会被赋予
                                <em>initial</em> 表达式的值；每一次迭代时，会被赋予 <em>update</em> 表达式的值。在 <code
                                  class="docutils literal"><span class="pre">show-squares</span></code> 函数里， <code
                                  class="docutils literal"><span class="pre">do</span></code> 只创建了一个变量 <code
                                  class="docutils literal"><span class="pre">i</span></code> 。第一次迭代时， <code
                                  class="docutils literal"><span class="pre">i</span></code> 被赋与 <code
                                  class="docutils literal"><span class="pre">start</span></code> 的值，在接下来的迭代里， <code
                                  class="docutils literal"><span class="pre">i</span></code> 的值每次增加 <code
                                  class="docutils literal"><span class="pre">1</span></code> 。
                              </p>
                              <p>第二个传给 <code class="docutils literal"><span class="pre">do</span></code>
                                的实参可包含一个或多个表达式。第一个表达式用来测试迭代是否结束。在上面的例子中，测试表达式是 <code
                                  class="docutils literal"><span class="pre">(&gt;</span> <span class="pre">i</span> <span class="pre">end)</span></code>
                                。接下来在列表中的表达式会依序被求值，直到迭代结束。而最后一个值会被当作 <code
                                  class="docutils literal"><span class="pre">do</span></code> 的返回值来返回。所以 <code
                                  class="docutils literal"><span class="pre">show-squares</span></code> 总是返回 <code
                                  class="docutils literal"><span class="pre">done</span></code> 。</p>
                              <p><code class="docutils literal"><span class="pre">do</span></code>
                                的剩余参数组成了循环的函数体。在每次迭代时，函数体会依序被求值。在每次迭代过程里，变量被更新，检查终止测试条件，接著（若测试失败）求值函数体。</p>
                              <p>作为对比，以下是递归版本的 <code
                                  class="docutils literal"><span class="pre">show-squares</span></code> ：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">show-squares</span> <span class="p">(</span><span class="nv">i</span> <span class="nv">end</span><span class="p">)</span>
   <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">&gt;</span> <span class="nv">i</span> <span class="nv">end</span><span class="p">)</span>
     <span class="ss">&#39;done</span>
     <span class="p">(</span><span class="k">progn</span>
       <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;~A ~A~%&quot;</span> <span class="nv">i</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">i</span> <span class="nv">i</span><span class="p">))</span>
       <span class="p">(</span><span class="nv">show-squares</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">i</span> <span class="mi">1</span><span class="p">)</span> <span class="nv">end</span><span class="p">))))</span>
</pre>
                                </div>
                              </div>
                              <p>唯一的新东西是 <code class="docutils literal"><span class="pre">progn</span></code> 。 <code
                                  class="docutils literal"><span class="pre">progn</span></code>
                                接受任意数量的表达式，依序求值，并返回最后一个表达式的值。</p>
                              <p>为了处理某些特殊情况， Common Lisp 有更简单的迭代操作符。举例来说，要遍历列表的元素，你可能会使用 <code
                                  class="docutils literal"><span class="pre">dolist</span></code> 。以下函数返回列表的长度：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">our-length</span> <span class="p">(</span><span class="nv">lst</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">len</span> <span class="mi">0</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">dolist</span> <span class="p">(</span><span class="nv">obj</span> <span class="nv">lst</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">setf</span> <span class="nv">len</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">len</span> <span class="mi">1</span><span class="p">)))</span>
    <span class="nv">len</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p>这里 <code class="docutils literal"><span class="pre">dolist</span></code>
                                接受这样形式的实参<em>(variable
                                  expression)</em>，跟着一个具有表达式的函数主体。函数主体会被求值，而变量相继与表达式所返回的列表元素绑定。因此上面的循环说，对于列表 <code
                                  class="docutils literal"><span class="pre">lst</span></code> 里的每一个 <code
                                  class="docutils literal"><span class="pre">obj</span></code> ，递增 <code
                                  class="docutils literal"><span class="pre">len</span></code> 。很显然这个函数的递归版本是：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">our-length</span> <span class="p">(</span><span class="nv">lst</span><span class="p">)</span>
 <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">null</span> <span class="nv">lst</span><span class="p">)</span>
     <span class="mi">0</span>
     <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nv">our-length</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">lst</span><span class="p">))</span> <span class="mi">1</span><span class="p">)))</span>
</pre>
                                </div>
                              </div>
                              <p>也就是说，如果列表是空表，则长度为 <code class="docutils literal"><span class="pre">0</span></code>
                                ；否则长度就是对列表取 <code class="docutils literal"><span class="pre">cdr</span></code>
                                的长度加一。递归版本的 <code class="docutils literal"><span class="pre">our-length</span></code>
                                比较易懂，但由于它不是尾递归（tail-recursive）的形式 (见 13.2 节)，效率不是那么高。</p>
                            </div>
                            <div class="section" id="functions-as-objects">
                              <h4>2.14 函数作为对象 (Functions as Objects)<a class="headerlink" href="#functions-as-objects"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>函数在 Lisp 里，和符号、字符串或列表一样，是稀松平常的对象。如果我们把函数的名字传给 <code
                                  class="docutils literal"><span class="pre">function</span></code> ，它会返回相关联的对象。和 <code
                                  class="docutils literal"><span class="pre">quote</span></code> 类似， <code
                                  class="docutils literal"><span class="pre">function</span></code>
                                是一个特殊操作符，所以我们无需引用（quote）它的实参：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre>&gt; (function +)
#&lt;Compiled-Function + 17BA4E&gt;
</pre>
                                </div>
                              </div>
                              <p>这看起来很奇怪的返回值，是在典型的 Common Lisp 实现里，函数可能的打印表示法。</p>
                              <p>到目前为止，我们仅讨论过，不管是 Lisp 打印它们，还是我们输入它们，看起来都是一样的对象。但这个惯例对函数不适用。一个像是 <code
                                  class="docutils literal"><span class="pre">+</span></code> 的内置函数
                                ，在内部可能是一段机器语言代码（machine language code）。每个 Common Lisp 实现，可以选择任何它喜欢的外部表示法（external
                                representation）。</p>
                              <p>如同我们可以用 <code class="docutils literal"><span class="pre">'</span></code> 作为 <code
                                  class="docutils literal"><span class="pre">quote</span></code> 的缩写，也可以用 <code
                                  class="docutils literal"><span class="pre">#'</span></code> 作为 <code
                                  class="docutils literal"><span class="pre">function</span></code> 的缩写：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre>&gt; #&#39;+
#&lt;Compiled-Function + 17BA4E&gt;
</pre>
                                </div>
                              </div>
                              <p>这个缩写称之为升引号（sharp-quote）。</p>
                              <p>和别种对象类似，可以把函数当作实参传入。有个接受函数作为实参的函数是 <code
                                  class="docutils literal"><span class="pre">apply</span></code> 。<code
                                  class="docutils literal"><span class="pre">apply</span></code>
                                接受一个函数和实参列表，并返回把传入函数应用在实参列表的结果：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">apply</span> <span class="nf">#&#39;</span><span class="nb">+</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">))</span>
<span class="mi">6</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="nb">+</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span>
<span class="mi">6</span>
</pre>
                                </div>
                              </div>
                              <p><code class="docutils literal"><span class="pre">apply</span></code>
                                可以接受任意数量的实参，只要最后一个实参是列表即可：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">apply</span> <span class="nf">#&#39;</span><span class="nb">+</span> <span class="mi">1</span> <span class="mi">2</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">))</span>
<span class="mi">15</span>
</pre>
                                </div>
                              </div>
                              <p>函数 <code class="docutils literal"><span class="pre">funcall</span></code>
                                做的是一样的事情，但不需要把实参包装成列表。</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">funcall</span> <span class="nf">#&#39;</span><span class="nb">+</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span>
<span class="mi">6</span>
</pre>
                                </div>
                              </div>
                              <div class="admonition note">
                                <p class="first admonition-title">Note</p>
                                <p>什么是 <code class="docutils literal"><span class="pre">lambda</span></code> ？</p>
                                <p><code class="docutils literal"><span class="pre">lambda</span></code> 表达式里的 <code
                                    class="docutils literal"><span class="pre">lambda</span></code> 不是一个操作符。而只是个符号。
                                  在早期的 Lisp 方言里， <code class="docutils literal"><span class="pre">lambda</span></code>
                                  存在的原因是：由于函数在内部是用列表来表示，
                                  因此辨别列表与函数的方法，就是检查第一个元素是否为 <code
                                    class="docutils literal"><span class="pre">lambda</span></code> 。</p>
                                <p>在 Common Lisp 里，你可以用列表来表达函数，
                                  函数在内部会被表示成独特的函数对象。因此不再需要 <cite>lambda</cite> 了。
                                  如果需要把函数记为</p>
                                <blockquote>
                                  <div>
                                    <div class="highlight-cl">
                                      <div class="highlight">
                                        <pre><span class="p">((</span><span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="mi">100</span><span class="p">))</span>
</pre>
                                      </div>
                                    </div>
                                  </div>
                                </blockquote>
                                <p>而不是</p>
                                <blockquote>
                                  <div>
                                    <div class="highlight-cl">
                                      <div class="highlight">
                                        <pre><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="mi">100</span><span class="p">))</span>
</pre>
                                      </div>
                                    </div>
                                  </div>
                                </blockquote>
                                <p>也是可以的。</p>
                                <p class="last">但 Lisp 程序员习惯用符号 <code
                                    class="docutils literal"><span class="pre">lambda</span></code> ，来撰写函数，
                                  因此 Common Lisp 为了传统，而保留了 <code
                                    class="docutils literal"><span class="pre">lambda</span></code> 。</p>
                              </div>
                              <p><code class="docutils literal"><span class="pre">defun</span></code>
                                宏，创建一个函数并给函数命名。但函数不需要有名字，而且我们不需要 <code
                                  class="docutils literal"><span class="pre">defun</span></code> 来定义他们。和大多数的 Lisp
                                对象一样，我们可以直接引用函数。</p>
                              <p>要直接引用整数，我们使用一系列的数字；要直接引用一个函数，我们使用所谓的<em>lambda 表达式</em>。一个 <code
                                  class="docutils literal"><span class="pre">lambda</span></code> 表达式是一个列表，列表包含符号 <code
                                  class="docutils literal"><span class="pre">lambda</span></code>
                                ，接著是形参列表，以及由零个或多个表达式所组成的函数体。</p>
                              <p>下面的 <code class="docutils literal"><span class="pre">lambda</span></code>
                                表达式，表示一个接受两个数字并返回两者之和的函数：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
 <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p>列表 <code
                                  class="docutils literal"><span class="pre">(x</span> <span class="pre">y)</span></code>
                                是形参列表，跟在它后面的是函数主体。</p>
                              <p>一个 <code class="docutils literal"><span class="pre">lambda</span></code>
                                表达式可以作为函数名。和普通的函数名称一样， lambda 表达式也可以是函数调用的第一个元素，</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">((</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="mi">100</span><span class="p">))</span> <span class="mi">1</span><span class="p">)</span>
<span class="mi">101</span>
</pre>
                                </div>
                              </div>
                              <p>而通过在 <code class="docutils literal"><span class="pre">lambda</span></code> 表达式前面贴上
                                <code class="docutils literal"><span class="pre">#'</span></code> ，我们得到对应的函数，
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">funcall</span> <span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="mi">100</span><span class="p">))</span>
          <span class="mi">1</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p><code class="docutils literal"><span class="pre">lambda</span></code>
                                表示法除上述用途以外，还允许我们使用匿名函数。</p>
                            </div>
                            <div class="section" id="types">
                              <h4>2.15 类型 (Types)<a class="headerlink" href="#types"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>Lisp 处理类型的方法非常灵活。在很多语言里，变量是有类型的，得声明变量的类型才能使用它。在 Common Lisp
                                里，数值才有类型，而变量没有。你可以想像每个对象，都贴有一个标明其类型的标签。这种方法叫做<em>显式类型</em>（<em>manifest
                                  typing</em>）。你不需要声明变量的类型，因为变量可以存放任何类型的对象。</p>
                              <p>虽然从来不需要声明类型，但出于效率的考量，你可能会想要声明变量的类型。类型声明在第 13.3 节时讨论。</p>
                              <p>Common Lisp 的内置类型，组成了一个类别的层级。对象总是不止属于一个类型。举例来说，数字 27 的类型，依普遍性的增加排序，依序是 <code
                                  class="docutils literal"><span class="pre">fixnum</span></code> 、 <code
                                  class="docutils literal"><span class="pre">integer</span></code> 、 <code
                                  class="docutils literal"><span class="pre">rational</span></code> 、 <code
                                  class="docutils literal"><span class="pre">real</span></code> 、 <code
                                  class="docutils literal"><span class="pre">number</span></code> 、 <code
                                  class="docutils literal"><span class="pre">atom</span></code> 和 <code
                                  class="docutils literal"><span class="pre">t</span></code> 类型。（数值类型将在第 9 章讨论。）类型 <code
                                  class="docutils literal"><span class="pre">t</span></code>
                                是所有类型的基类（supertype）。所以每个对象都属于 <code
                                  class="docutils literal"><span class="pre">t</span></code> 类型。</p>
                              <p>函数 <code class="docutils literal"><span class="pre">typep</span></code>
                                接受一个对象和一个类型，然后判定对象是否为该类型，是的话就返回真：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">typep</span> <span class="mi">27</span> <span class="ss">&#39;integer</span><span class="p">)</span>
<span class="no">T</span>
</pre>
                                </div>
                              </div>
                              <p>我们会在遇到各式内置类型时来讨论它们。</p>
                            </div>
                            <div class="section" id="looking-forward">
                              <h4>2.16 展望 (Looking Forward)<a class="headerlink" href="#looking-forward"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>本章仅谈到 Lisp 的表面。然而，一种非比寻常的语言形象开始出现了。首先，这个语言用单一的语法，来表达所有的程序结构。语法基于列表，列表是一种 Lisp 对象。函数本身也是
                                Lisp 对象，函数能用列表来表示。而 Lisp 本身就是 Lisp 程序。几乎所有你定义的函数，与内置的 Lisp 函数没有任何区别。</p>
                              <p>如果你对这些概念还不太了解，不用担心。 Lisp
                                介绍了这么多新颖的概念，在你能驾驭它们之前，得花时间去熟悉它们。不过至少要了解一件事：在这些概念当中，有着优雅到令人吃惊的概念。</p>
                              <p><a class="reference external"
                                  href="http://en.wikipedia.org/wiki/Richard_P._Gabriel">Richard Gabriel</a> 曾经半开玩笑的说， C
                                是拿来写 Unix 的语言。我们也可以说， Lisp 是拿来写 Lisp
                                的语言。但这是两种不同的论述。一个可以用自己编写的语言和一种适合编写某些特定类型应用的语言，是有着本质上的不同。这开创了新的编程方法：你不但在语言之中编程，还把语言改善成适合程序的语言。如果你想了解
                                Lisp 编程的本质，理解这个概念是个好的开始。</p>
                            </div>
                            <div class="section" id="chapter-2-summary">
                              <h4>Chapter 2 总结 (Summary)<a class="headerlink" href="#chapter-2-summary"
                                  title="Permalink to this headline">¶</a></h4>
                              <ol class="arabic simple">
                                <li>Lisp 是一种交互式语言。如果你在顶层输入一个表达式， Lisp 会显示它的值。</li>
                                <li>Lisp 程序由表达式组成。表达式可以是原子，或一个由操作符跟着零个或多个实参的列表。前序表示法代表操作符可以有任意数量的实参。</li>
                                <li>Common Lisp 函数调用的求值规则： 依序对实参从左至右求值，接著把它们的值传入由操作符表示的函数。 <code
                                    class="docutils literal"><span class="pre">quote</span></code>
                                  操作符有自己的求值规则，它完封不动地返回实参。</li>
                                <li>除了一般的数据类型， Lisp 还有符号跟列表。由于 Lisp 程序是用列表来表示的，很轻松就能写出能编程的程序。</li>
                                <li>三个基本的列表函数是 <code class="docutils literal"><span class="pre">cons</span></code>
                                  ，它创建一个列表； <code class="docutils literal"><span class="pre">car</span></code>
                                  ，它返回列表的第一个元素；以及 <code class="docutils literal"><span class="pre">cdr</span></code>
                                  ，它返回第一个元素之后的所有东西。</li>
                                <li>在 Common Lisp 里， <code class="docutils literal"><span class="pre">t</span></code>
                                  表示逻辑 <code class="docutils literal"><span class="pre">真</span></code> ，而 <code
                                    class="docutils literal"><span class="pre">nil</span></code> 表示逻辑 <code
                                    class="docutils literal"><span class="pre">假</span></code> 。在逻辑的上下文里，任何非 <code
                                    class="docutils literal"><span class="pre">nil</span></code> 的东西都视为 <code
                                    class="docutils literal"><span class="pre">真</span></code> 。基本的条件式是 <code
                                    class="docutils literal"><span class="pre">if</span></code> 。 <code
                                    class="docutils literal"><span class="pre">and</span></code> 与 <code
                                    class="docutils literal"><span class="pre">or</span></code> 是相似的条件式。</li>
                                <li>Lisp 主要由函数所组成。可以用 <code
                                    class="docutils literal"><span class="pre">defun</span></code> 来定义新的函数。</li>
                                <li>自己调用自己的函数是递归的。一个递归函数应该要被想成是过程，而不是机器。</li>
                                <li>括号不是问题，因为程序员通过缩排来阅读与编写 Lisp 程序。</li>
                                <li>基本的 I/O 函数是 <code class="docutils literal"><span class="pre">read</span></code>
                                  ，它包含了一个完整的 Lisp 语法分析器，以及 <code
                                    class="docutils literal"><span class="pre">format</span></code> ，它通过字符串模板来产生输出。</li>
                                <li>你可以用 <code class="docutils literal"><span class="pre">let</span></code> 来创造新的局部变量，用
                                  <code class="docutils literal"><span class="pre">defparameter</span></code> 来创造全局变量。
                                </li>
                                <li>赋值操作符是 <code class="docutils literal"><span class="pre">setf</span></code>
                                  。它的第一个实参可以是一个表达式。</li>
                                <li>函数式编程代表避免产生副作用，也是 Lisp 的主导思维。</li>
                                <li>基本的迭代操作符是 <code class="docutils literal"><span class="pre">do</span></code> 。</li>
                                <li>函数是 Lisp 的对象。可以被当成实参传入，并且可以用 lambda 表达式来表示。</li>
                                <li>在 Lisp 里，是数值才有类型，而不是变量。</li>
                              </ol>
                            </div>
                            <div class="section" id="chapter-2-exercises">
                              <h4>Chapter 2 习题 (Exercises)<a class="headerlink" href="#chapter-2-exercises"
                                  title="Permalink to this headline">¶</a></h4>
                              <ol class="arabic simple">
                                <li>描述下列表达式求值之后的结果：</li>
                              </ol>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nv">a</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nb">-</span> <span class="mi">5</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="mi">3</span> <span class="mi">7</span><span class="p">))</span>

<span class="p">(</span><span class="nv">b</span><span class="p">)</span> <span class="p">(</span><span class="nb">list</span> <span class="mi">1</span> <span class="p">(</span><span class="nb">+</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">))</span>

<span class="p">(</span><span class="nv">c</span><span class="p">)</span> <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">listp</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">))</span>

<span class="p">(</span><span class="nv">d</span><span class="p">)</span> <span class="p">(</span><span class="nb">list</span> <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nb">listp</span> <span class="mi">3</span><span class="p">)</span> <span class="no">t</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <ol class="arabic simple" start="2">
                                <li>给出 3 种不同表示 <code
                                    class="docutils literal"><span class="pre">(a</span> <span class="pre">b</span> <span class="pre">c)</span></code>
                                  的 <code
                                    class="docutils literal"><span class="pre">cons</span> <span class="pre">表达式</span></code>
                                  。</li>
                                <li>使用 <code class="docutils literal"><span class="pre">car</span></code> 与 <code
                                    class="docutils literal"><span class="pre">cdr</span></code> 来定义一个函数，返回一个列表的第四个元素。
                                </li>
                                <li>定义一个函数，接受两个实参，返回两者当中较大的那个。</li>
                                <li>这些函数做了什么？</li>
                              </ol>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nv">a</span><span class="p">)</span> <span class="p">(</span><span class="nb">defun</span> <span class="nv">enigma</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nb">not</span> <span class="p">(</span><span class="nb">null</span> <span class="nv">x</span><span class="p">))</span>
           <span class="p">(</span><span class="nb">or</span> <span class="p">(</span><span class="nb">null</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">x</span><span class="p">))</span>
               <span class="p">(</span><span class="nv">enigma</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">x</span><span class="p">)))))</span>

<span class="p">(</span><span class="nv">b</span><span class="p">)</span> <span class="p">(</span><span class="nb">defun</span> <span class="nv">mystery</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
      <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">null</span> <span class="nv">y</span><span class="p">)</span>
          <span class="no">nil</span>
          <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">eql</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">y</span><span class="p">)</span> <span class="nv">x</span><span class="p">)</span>
              <span class="mi">0</span>
              <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">z</span> <span class="p">(</span><span class="nv">mystery</span> <span class="nv">x</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">y</span><span class="p">))))</span>
                <span class="p">(</span><span class="nb">and</span> <span class="nv">z</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">z</span> <span class="mi">1</span><span class="p">))))))</span>
</pre>
                                </div>
                              </div>
                              <ol class="arabic simple" start="6">
                                <li>下列表达式， <code class="docutils literal"><span class="pre">x</span></code>
                                  该是什么，才会得到相同的结果？</li>
                              </ol>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nv">a</span><span class="p">)</span> <span class="nb">&gt;</span> <span class="p">(</span><span class="nb">car</span> <span class="p">(</span><span class="nv">x</span> <span class="p">(</span><span class="nb">cdr</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="p">(</span><span class="nv">b</span> <span class="nv">c</span><span class="p">)</span> <span class="nv">d</span><span class="p">))))</span>
    <span class="nv">B</span>
<span class="p">(</span><span class="nv">b</span><span class="p">)</span> <span class="nb">&gt;</span> <span class="p">(</span><span class="nv">x</span> <span class="mi">13</span> <span class="p">(</span><span class="nb">/</span> <span class="mi">1</span> <span class="mi">0</span><span class="p">))</span>
    <span class="mi">13</span>
<span class="p">(</span><span class="nv">c</span><span class="p">)</span> <span class="nb">&gt;</span> <span class="p">(</span><span class="nv">x</span> <span class="nf">#&#39;</span><span class="nb">list</span> <span class="mi">1</span> <span class="no">nil</span><span class="p">)</span>
    <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <ol class="arabic simple" start="7">
                                <li>只使用本章所介绍的操作符，定义一个函数，它接受一个列表作为实参，如果有一个元素是列表时，就返回真。</li>
                                <li>给出函数的迭代与递归版本：</li>
                              </ol>
                              <ol class="loweralpha simple">
                                <li>接受一个正整数，并打印出数字数量的点。</li>
                                <li>接受一个列表，并返回 <code class="docutils literal"><span class="pre">a</span></code>
                                  在列表里所出现的次数。</li>
                              </ol>
                              <ol class="arabic simple" start="9">
                                <li>一位朋友想写一个函数，返回列表里所有非 <code
                                    class="docutils literal"><span class="pre">nil</span></code>
                                  元素的和。他写了此函数的两个版本，但两个都不能工作。请解释每一个的错误在哪里，并给出正确的版本。</li>
                              </ol>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nv">a</span><span class="p">)</span> <span class="p">(</span><span class="nb">defun</span> <span class="nv">summit</span> <span class="p">(</span><span class="nv">lst</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">remove</span> <span class="no">nil</span> <span class="nv">lst</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">apply</span> <span class="nf">#&#39;</span><span class="nb">+</span> <span class="nv">lst</span><span class="p">))</span>

<span class="p">(</span><span class="nv">b</span><span class="p">)</span> <span class="p">(</span><span class="nb">defun</span> <span class="nv">summit</span> <span class="p">(</span><span class="nv">lst</span><span class="p">)</span>
      <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">x</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">lst</span><span class="p">)))</span>
        <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">null</span> <span class="nv">x</span><span class="p">)</span>
            <span class="p">(</span><span class="nv">summit</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">lst</span><span class="p">))</span>
            <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="p">(</span><span class="nv">summit</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">lst</span><span class="p">))))))</span>
</pre>
                                </div>
                              </div>
                              <p class="rubric">脚注</p>
                              <table class="docutils footnote" frame="void" id="id5" rules="none">
                                <colgroup>
                                  <col class="label" />
                                  <col />
                                </colgroup>
                                <tbody valign="top">
                                  <tr>
                                    <td class="label"><a class="fn-backref" href="#id3">[1]</a></td>
                                    <td>在 vi，你可以用 :set sm 来启用括号匹配。在 Emacs，M-x lisp-mode 是一个启用的好方法。</td>
                                  </tr>
                                </tbody>
                              </table>
                              <table class="docutils footnote" frame="void" id="id6" rules="none">
                                <colgroup>
                                  <col class="label" />
                                  <col />
                                </colgroup>
                                <tbody valign="top">
                                  <tr>
                                    <td class="label"><a class="fn-backref" href="#id4">[2]</a></td>
                                    <td>真正的区别是词法变量（lexical）与特殊变量（special variable），但到第六章才会讨论这个主题。</td>
                                  </tr>
                                </tbody>
                              </table>
                            </div>
                          </div>
                          <div class="section">
                            <h3 id="3">第三章：列表</h3>
                            <p>列表是 Lisp 的基本数据结构之一。在最早的 Lisp 方言里，列表是唯一的数据结构： “Lisp” 这个名字起初是 “LISt Processor” 的缩写。但 Lisp
                              已经超越这个缩写很久了。 Common Lisp 是一个有着各式各样数据结构的通用性程序语言。</p>
                            <p>Lisp 程序开发通常呼应着开发 Lisp 语言自身。在最初版本的 Lisp
                              程序，你可能使用很多列表。然而之后的版本，你可能换到快速、特定的数据结构。本章描述了你可以用列表所做的很多事情，以及使用它们来演示一些普遍的 Lisp 概念。</p>
                            <div class="section" id="conses">
                              <h4>3.1 构造 (Conses)<a class="headerlink" href="#conses"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>在 2.4 节我们介绍了 <code class="docutils literal"><span class="pre">cons</span></code> ,
                                <code class="docutils literal"><span class="pre">car</span></code> , 以及 <code
                                  class="docutils literal"><span class="pre">cdr</span></code> ，基本的 List 操作函数。 <code
                                  class="docutils literal"><span class="pre">cons</span></code>
                                真正所做的事情是，把两个对象结合成一个有两部分的对象，称之为 <em>Cons</em> 对象。概念上来说，一个 <em>Cons</em> 是一对指针；第一个是 <code
                                  class="docutils literal"><span class="pre">car</span></code> ，第二个是 <code
                                  class="docutils literal"><span class="pre">cdr</span></code> 。
                              </p>
                              <p><em>Cons</em> 对象提供了一个方便的表示法，来表示任何类型的对象。一个 <em>Cons</em> 对象里的一对指针，可以指向任何类型的对象，包括
                                <em>Cons</em> 对象本身。它利用到我们之后可以用 <code
                                  class="docutils literal"><span class="pre">cons</span></code> 来构造列表的可能性。
                              </p>
                              <p>我们往往不会把列表想成是成对的，但它们可以这样被定义。任何非空的列表，都可以被视为一对由列表第一个元素及列表其余元素所组成的列表。 Lisp 列表体现了这个概念。我们使用
                                <em>Cons</em> 的一半来指向列表的第一个元素，然后用另一半指向列表其余的元素(可能是别的 <em>Cons</em> 或 <code
                                  class="docutils literal"><span class="pre">nil</span></code> )。 Lisp 的惯例是使用 <code
                                  class="docutils literal"><span class="pre">car</span></code> 代表列表的第一个元素，而用 <code
                                  class="docutils literal"><span class="pre">cdr</span></code> 代表列表的其余的元素。所以现在 <code
                                  class="docutils literal"><span class="pre">car</span></code> 是列表的第一个元素的同义词，而 <code
                                  class="docutils literal"><span class="pre">cdr</span></code>
                                是列表的其余的元素的同义词。列表不是不同的对象，而是像 <em>Cons</em> 这样的方式连结起来。
                              </p>
                              <p>当我们想在 <code class="docutils literal"><span class="pre">nil</span></code> 上面建立东西时，</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">setf</span> <span class="nv">x</span> <span class="p">(</span><span class="nb">cons</span> <span class="ss">&#39;a</span> <span class="no">nil</span><span class="p">))</span>
<span class="p">(</span><span class="nv">A</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <div class="figure">
                                <img alt="_images/Figure-3.1.png" src="_images/Figure-3.1.png" />
                              </div>
                              <p>图 3.1 一个元素的列表</p>
                              <p>产生的列表由一个 <em>Cons</em> 所组成，见图 3.1。这种表达 <em>Cons</em> 的方式叫做箱子表示法 (box notation)，因为每一个
                                Cons 是用一个箱子表示，内含一个 <code class="docutils literal"><span class="pre">car</span></code> 和
                                <code class="docutils literal"><span class="pre">cdr</span></code> 的指针。当我们调用 <code
                                  class="docutils literal"><span class="pre">car</span></code> 与 <code
                                  class="docutils literal"><span class="pre">cdr</span></code> 时，我们得到指针指向的地方：
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">x</span><span class="p">)</span>
<span class="nv">A</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">x</span><span class="p">)</span>
<span class="no">NIL</span>
</pre>
                                </div>
                              </div>
                              <p>当我们构造一个多元素的列表时，我们得到一串 <em>Cons</em> (a chain of conses):</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">setf</span> <span class="nv">y</span> <span class="p">(</span><span class="nb">list</span> <span class="ss">&#39;a</span> <span class="ss">&#39;b</span> <span class="ss">&#39;c</span><span class="p">))</span>
<span class="p">(</span><span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>产生的结构见图 3.2。现在当我们想得到列表的 <code
                                  class="docutils literal"><span class="pre">cdr</span></code> 时，它是一个两个元素的列表。</p>
                              <div class="figure">
                                <img alt="_images/Figure-3.2.png" src="_images/Figure-3.2.png" />
                              </div>
                              <p>图 3.2 三个元素的列表</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">y</span><span class="p">)</span>
<span class="p">(</span><span class="nv">B</span> <span class="nv">C</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>在一个有多个元素的列表中， <code class="docutils literal"><span class="pre">car</span></code>
                                指针让你取得元素，而 <code class="docutils literal"><span class="pre">cdr</span></code>
                                让你取得列表内其余的东西。</p>
                              <p>一个列表可以有任何类型的对象作为元素，包括另一个列表：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">setf</span> <span class="nv">z</span> <span class="p">(</span><span class="nb">list</span> <span class="ss">&#39;a</span> <span class="p">(</span><span class="nb">list</span> <span class="ss">&#39;b</span> <span class="ss">&#39;c</span><span class="p">)</span> <span class="ss">&#39;d</span><span class="p">))</span>
<span class="p">(</span><span class="nv">A</span> <span class="p">(</span><span class="nv">B</span> <span class="nv">C</span><span class="p">)</span> <span class="nv">D</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>当这种情况发生时，它的结构如图 3.3 所示；第二个 <em>Cons</em> 的 <code
                                  class="docutils literal"><span class="pre">car</span></code> 指针也指向一个列表：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">car</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">z</span><span class="p">))</span>
<span class="p">(</span><span class="nv">B</span> <span class="nv">C</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <div class="figure">
                                <img alt="_images/Figure-3.3.png" src="_images/Figure-3.3.png" />
                              </div>
                              <p>图 3.3 嵌套列表</p>
                              <p>前两个我们构造的列表都有三个元素；只不过 <code class="docutils literal"><span class="pre">z</span></code>
                                列表的第二个元素也刚好是一个列表。像这样的列表称为<em>嵌套</em>列表，而像 <code
                                  class="docutils literal"><span class="pre">y</span></code> 这样的列表称之为<em>平坦</em>列表
                                (<em>flat</em>list)。</p>
                              <p>如果参数是一个 <em>Cons</em> 对象，函数 <code
                                  class="docutils literal"><span class="pre">consp</span></code> 返回真。所以我们可以这样定义 <code
                                  class="docutils literal"><span class="pre">listp</span></code> :</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">our-listp</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">or</span> <span class="p">(</span><span class="nb">null</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">consp</span> <span class="nv">x</span><span class="p">)))</span>
</pre>
                                </div>
                              </div>
                              <p>因为所有不是 <em>Cons</em> 对象的东西，就是一个原子 (atom)，判断式 <code
                                  class="docutils literal"><span class="pre">atom</span></code> 可以这样定义：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">our-atom</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">not</span> <span class="p">(</span><span class="nb">consp</span> <span class="nv">x</span><span class="p">)))</span>
</pre>
                                </div>
                              </div>
                              <p>注意， <code class="docutils literal"><span class="pre">nil</span></code> 既是一个原子，也是一个列表。
                              </p>
                            </div>
                            <div class="section" id="equality">
                              <h4>3.2 等式 (Equality)<a class="headerlink" href="#equality"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>每一次你调用 <code class="docutils literal"><span class="pre">cons</span></code> 时， Lisp
                                会配置一块新的内存给两个指针。所以如果我们用同样的参数调用 <code
                                  class="docutils literal"><span class="pre">cons</span></code>
                                两次，我们得到两个数值看起来一样，但实际上是两个不同的对象：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">eql</span> <span class="p">(</span><span class="nb">cons</span> <span class="ss">&#39;a</span> <span class="no">nil</span><span class="p">)</span> <span class="p">(</span><span class="nb">cons</span> <span class="ss">&#39;a</span> <span class="no">nil</span><span class="p">))</span>
<span class="no">NIL</span>
</pre>
                                </div>
                              </div>
                              <p>如果我们也可以询问两个列表是否有相同元素，那就很方便了。 Common Lisp 提供了这种目的另一个判断式： <code
                                  class="docutils literal"><span class="pre">equal</span></code> 。而另一方面 <code
                                  class="docutils literal"><span class="pre">eql</span></code> 只有在它的参数是相同对象时才返回真，</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">setf</span> <span class="nv">x</span> <span class="p">(</span><span class="nb">cons</span> <span class="ss">&#39;a</span> <span class="no">nil</span><span class="p">))</span>
<span class="p">(</span><span class="nv">A</span><span class="p">)</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="nb">eql</span> <span class="nv">x</span> <span class="nv">x</span><span class="p">)</span>
<span class="no">T</span>
</pre>
                                </div>
                              </div>
                              <p>本质上 <code class="docutils literal"><span class="pre">equal</span></code>
                                若它的参数打印出的值相同时，返回真：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">equal</span> <span class="nv">x</span> <span class="p">(</span><span class="nb">cons</span> <span class="ss">&#39;a</span> <span class="no">nil</span><span class="p">))</span>
<span class="no">T</span>
</pre>
                                </div>
                              </div>
                              <p>这个判断式对非列表结构的别种对象也有效，但一种仅对列表有效的版本可以这样定义：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">defun</span> <span class="nv">our-equal</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">or</span> <span class="p">(</span><span class="nb">eql</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
        <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nb">consp</span> <span class="nv">x</span><span class="p">)</span>
             <span class="p">(</span><span class="nb">consp</span> <span class="nv">y</span><span class="p">)</span>
             <span class="p">(</span><span class="nv">our-equal</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">y</span><span class="p">))</span>
             <span class="p">(</span><span class="nv">our-equal</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">y</span><span class="p">)))))</span>
</pre>
                                </div>
                              </div>
                              <p>这个定义意味着，如果某个 <code class="docutils literal"><span class="pre">x</span></code> 和 <code
                                  class="docutils literal"><span class="pre">y</span></code> 相等( <code
                                  class="docutils literal"><span class="pre">eql</span></code> )，那么他们也相等( <code
                                  class="docutils literal"><span class="pre">equal</span></code> )。</p>
                              <p><strong>勘误:</strong> 这个版本的 <code
                                  class="docutils literal"><span class="pre">our-equal</span></code> 可以用在符号的列表 (list of
                                symbols)，而不是列表 (list)。</p>
                            </div>
                            <div class="section" id="lisp-why-lisp-has-no-pointers">
                              <h4>3.3 为什么 Lisp 没有指针 (Why Lisp Has No Pointers)<a class="headerlink"
                                  href="#lisp-why-lisp-has-no-pointers" title="Permalink to this headline">¶</a></h4>
                              <p>一个理解 Lisp 的秘密之一是意识到变量是有值的，就像列表有元素一样。如同 <em>Cons</em> 对象有指针指向他们的元素，变量有指针指向他们的值。</p>
                              <p>你可能在别的语言中使用过显式指针 (explicitly pointer)。在
                                Lisp，你永远不用这么做，因为语言帮你处理好指针了。我们已经在列表看过这是怎么实现的。同样的事情发生在变量身上。举例来说，假设我们想要把两个变量设成同样的列表：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre> <span class="nb">&gt;</span> <span class="p">(</span><span class="nb">setf</span> <span class="nv">x</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">))</span>
<span class="p">(</span><span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span><span class="p">)</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="nb">setf</span> <span class="nv">y</span> <span class="nv">x</span><span class="p">)</span>
<span class="p">(</span><span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <div class="figure">
                                <img alt="_images/Figure-3.4.png" src="_images/Figure-3.4.png" />
                              </div>
                              <p>图 3.4 两个变量设为相同的列表</p>
                              <p>当我们把 <code class="docutils literal"><span class="pre">x</span></code> 的值赋给 <code
                                  class="docutils literal"><span class="pre">y</span></code> 时，究竟发生什么事呢？内存中与 <code
                                  class="docutils literal"><span class="pre">x</span></code>
                                有关的位置并没有包含这个列表，而是一个指针指向它。当我们给 <code
                                  class="docutils literal"><span class="pre">y</span></code> 赋一个相同的值时， Lisp
                                复制的是指针，而不是列表。（图 3.4 显式赋值 <code
                                  class="docutils literal"><span class="pre">x</span></code> 给 <code
                                  class="docutils literal"><span class="pre">y</span></code>
                                后的结果）无论何时，你将某个变量的值赋给另个变量时，两个变量的值将会是 <code
                                  class="docutils literal"><span class="pre">eql</span></code> 的：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">eql</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
<span class="no">T</span>
</pre>
                                </div>
                              </div>
                              <p>Lisp
                                没有指针的原因是因为每一个值，其实概念上来说都是一个指针。当你赋一个值给变量或将这个值存在数据结构中，其实被储存的是指向这个值的指针。当你要取得变量的值，或是存在数据结构中的内容时，
                                Lisp 返回指向这个值的指针。但这都在台面下发生。你可以不加思索地把值放在结构里，或放“在”变量里。</p>
                              <p>为了效率的原因， Lisp 有时会选择一个折衷的表示法，而不是指针。举例来说，因为一个小整数所需的内存空间，少于一个指针所需的空间，一个 Lisp
                                实现可能会直接处理这个小整数，而不是用指针来处理。但基本要点是，程序员预设可以把任何东西放在任何地方。除非你声明你不愿这么做，不然你能够在任何的数据结构，存放任何类型的对象，包括结构本身。
                              </p>
                            </div>
                            <div class="section" id="building-lists">
                              <h4>3.4 建立列表 (Building Lists)<a class="headerlink" href="#building-lists"
                                  title="Permalink to this headline">¶</a></h4>
                              <div class="figure">
                                <img alt="_images/Figure-3.5.png" src="_images/Figure-3.5.png" />
                              </div>
                              <p>图 3.5 复制的结果</p>
                              <p>函数 <code class="docutils literal"><span class="pre">copy-list</span></code>
                                接受一个列表，然后返回此列表的复本。新的列表会有同样的元素，但是装在新的 <em>Cons</em> 对象里：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">setf</span> <span class="nv">x</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">)</span>
        <span class="nv">y</span> <span class="p">(</span><span class="nb">copy-list</span> <span class="nv">x</span><span class="p">))</span>
<span class="p">(</span><span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>图 3.5 展示出结果的结构; 返回值像是有着相同乘客的新公交。我们可以把 <code
                                  class="docutils literal"><span class="pre">copy-list</span></code> 想成是这么定义的：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">our-copy-list</span> <span class="p">(</span><span class="nv">lst</span><span class="p">)</span>
 <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">atom</span> <span class="nv">lst</span><span class="p">)</span>
     <span class="nv">lst</span>
     <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">lst</span><span class="p">)</span> <span class="p">(</span><span class="nv">our-copy-list</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">lst</span><span class="p">)))))</span>
</pre>
                                </div>
                              </div>
                              <p>这个定义暗示着 <code class="docutils literal"><span class="pre">x</span></code> 与 <code
                                  class="docutils literal"><span class="pre">(copy-list</span> <span class="pre">x)</span></code>
                                会永远 <code class="docutils literal"><span class="pre">equal</span></code> ，并永远不 <code
                                  class="docutils literal"><span class="pre">eql</span></code> ，除非 <code
                                  class="docutils literal"><span class="pre">x</span></code> 是 <code
                                  class="docutils literal"><span class="pre">NIL</span></code> 。</p>
                              <p>最后，函数 <code class="docutils literal"><span class="pre">append</span></code> 返回任何数目的列表串接
                                (concatenation)：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">append</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">c</span> <span class="nv">d</span><span class="p">)</span> <span class="ss">&#39;e</span><span class="p">)</span>
<span class="p">(</span><span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="nv">D</span> <span class="o">.</span> <span class="nv">E</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>通过这么做，它复制所有的参数，除了最后一个</p>
                            </div>
                            <div class="section" id="example-compression">
                              <h4>3.5 示例：压缩 (Example: Compression)<a class="headerlink" href="#example-compression"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>作为一个例子，这节将演示如何实现简单形式的列表压缩。这个算法有一个令人印象深刻的名字，<em>游程编码</em>(run-length encoding)。</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">compress</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">consp</span> <span class="nv">x</span><span class="p">)</span>
      <span class="p">(</span><span class="nv">compr</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">x</span><span class="p">)</span> <span class="mi">1</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">x</span><span class="p">))</span>
      <span class="nv">x</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">compr</span> <span class="p">(</span><span class="nb">elt</span> <span class="nv">n</span> <span class="nv">lst</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">null</span> <span class="nv">lst</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">list</span> <span class="p">(</span><span class="nv">n-elts</span> <span class="nb">elt</span> <span class="nv">n</span><span class="p">))</span>
      <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">next</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">lst</span><span class="p">)))</span>
        <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">eql</span> <span class="nv">next</span> <span class="nb">elt</span><span class="p">)</span>
            <span class="p">(</span><span class="nv">compr</span> <span class="nb">elt</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">n</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">lst</span><span class="p">))</span>
            <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nv">n-elts</span> <span class="nb">elt</span> <span class="nv">n</span><span class="p">)</span>
                  <span class="p">(</span><span class="nv">compr</span> <span class="nv">next</span> <span class="mi">1</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">lst</span><span class="p">)))))))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">n-elts</span> <span class="p">(</span><span class="nb">elt</span> <span class="nv">n</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">&gt;</span> <span class="nv">n</span> <span class="mi">1</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">list</span> <span class="nv">n</span> <span class="nb">elt</span><span class="p">)</span>
      <span class="nb">elt</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p>图 3.6 游程编码 (Run-length encoding)：压缩</p>
                              <p>在餐厅的情境下，这个算法的工作方式如下。一个女服务生走向有四个客人的桌子。“你们要什么？” 她问。“我要特餐，” 第一个客人说。
                                “我也是，” 第二个客人说。“听起来不错，” 第三个客人说。每个人看着第四个客人。 “我要一个 cilantro soufflé，” 他小声地说。
                                (译注：蛋奶酥上面洒香菜跟酱料）</p>
                              <p>瞬息之间，女服务生就转身踩着高跟鞋走回柜台去了。 “三个特餐，” 她大声对厨师说，“还有一个香菜蛋奶酥。”</p>
                              <p>图 3.6 展示了如何实现这个压缩列表演算法。函数 <code
                                  class="docutils literal"><span class="pre">compress</span></code>
                                接受一个由原子组成的列表，然后返回一个压缩的列表：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">compress</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">1</span><span class="p">))</span>
<span class="p">((</span><span class="mi">3</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">0</span> <span class="mi">1</span> <span class="p">(</span><span class="mi">4</span> <span class="mi">0</span><span class="p">)</span> <span class="mi">1</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>当相同的元素连续出现好几次，这个连续出现的序列 (sequence)被一个列表取代，列表指明出现的次数及出现的元素。</p>
                              <p>主要的工作是由递归函数 <code class="docutils literal"><span class="pre">compr</span></code>
                                所完成。这个函数接受三个参数： <code class="docutils literal"><span class="pre">elt</span></code> ，
                                上一个我们看过的元素； <code class="docutils literal"><span class="pre">n</span></code> ，连续出现的次数；以及
                                <code class="docutils literal"><span class="pre">lst</span></code>
                                ，我们还没检查过的部分列表。如果没有东西需要检查了，我们调用 <code
                                  class="docutils literal"><span class="pre">n-elts</span></code> 来取得 <code
                                  class="docutils literal"><span class="pre">n</span> <span class="pre">elts</span></code>
                                的表示法。如果 <code class="docutils literal"><span class="pre">lst</span></code> 的第一个元素还是
                                <code class="docutils literal"><span class="pre">elt</span></code> ，我们增加出现的次数 <code
                                  class="docutils literal"><span class="pre">n</span></code>
                                并继续下去。否则我们得到，到目前为止的一个压缩的列表，然后 <code
                                  class="docutils literal"><span class="pre">cons</span></code> 这个列表在 <code
                                  class="docutils literal"><span class="pre">compr</span></code> 处理完剩下的列表所返回的东西之上。
                              </p>
                              <p>要复原一个压缩的列表，我们调用 <code
                                  class="docutils literal"><span class="pre">uncompress</span></code> (图 3.7)</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">uncompress</span> <span class="o">&#39;</span><span class="p">((</span><span class="mi">3</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">0</span> <span class="mi">1</span> <span class="p">(</span><span class="mi">4</span> <span class="mi">0</span><span class="p">)</span> <span class="mi">1</span><span class="p">))</span>
<span class="p">(</span><span class="mi">1</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">1</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">uncompress</span> <span class="p">(</span><span class="nv">lst</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">null</span> <span class="nv">lst</span><span class="p">)</span>
      <span class="no">nil</span>
      <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nb">elt</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">lst</span><span class="p">))</span>
            <span class="p">(</span><span class="nb">rest</span> <span class="p">(</span><span class="nv">uncompress</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">lst</span><span class="p">))))</span>
        <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">consp</span> <span class="nb">elt</span><span class="p">)</span>
            <span class="p">(</span><span class="nb">append</span> <span class="p">(</span><span class="nb">apply</span> <span class="nf">#&#39;</span><span class="nv">list-of</span> <span class="nb">elt</span><span class="p">)</span>
                    <span class="nb">rest</span><span class="p">)</span>
            <span class="p">(</span><span class="nb">cons</span> <span class="nb">elt</span> <span class="nb">rest</span><span class="p">)))))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">list-of</span> <span class="p">(</span><span class="nv">n</span> <span class="nb">elt</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">zerop</span> <span class="nv">n</span><span class="p">)</span>
      <span class="no">nil</span>
      <span class="p">(</span><span class="nb">cons</span> <span class="nb">elt</span> <span class="p">(</span><span class="nv">list-of</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">n</span> <span class="mi">1</span><span class="p">)</span> <span class="nb">elt</span><span class="p">))))</span>
</pre>
                                </div>
                              </div>
                              <p>图 3.7 游程编码 (Run-length encoding)：解压缩</p>
                              <p>这个函数递归地遍历这个压缩列表，逐字复制原子并调用 <code
                                  class="docutils literal"><span class="pre">list-of</span></code> ，展开成列表。</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">list-of</span> <span class="mi">3</span> <span class="ss">&#39;ho</span><span class="p">)</span>
<span class="p">(</span><span class="nv">HO</span> <span class="nv">HO</span> <span class="nv">HO</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>我们其实不需要自己写 <code class="docutils literal"><span class="pre">list-of</span></code> 。内置的
                                <code class="docutils literal"><span class="pre">make-list</span></code> 可以办到一样的事情 ──
                                但它使用了我们还没介绍到的关键字参数 (keyword argument)。
                              </p>
                              <p>图 3.6 跟 3.7 这种写法不是一个有经验的Lisp
                                程序员用的写法。它的效率很差，它没有尽可能的压缩，而且它只对由原子组成的列表有效。在几个章节内，我们会学到解决这些问题的技巧。</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre>载入程序

在这节的程序是我们第一个实质的程序。
当我们想要写超过数行的函数时，
通常我们会把程序写在一个文件，
然后使用 load 让 Lisp 读取函数的定义。
如果我们把图 3.6 跟 3.7 的程序，
存在一个文件叫做，“compress.lisp”然后输入

(load &quot;compress.lisp&quot;)

到顶层，或多或少的，
我们会像在直接输入顶层一样得到同样的效果。

注意：在某些实现中，Lisp 文件的扩展名会是“.lsp”而不是“.lisp”。
</pre>
                                </div>
                              </div>
                            </div>
                            <div class="section" id="access">
                              <h4>3.6 存取 (Access)<a class="headerlink" href="#access"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>Common Lisp 有额外的存取函数，它们是用 <code
                                  class="docutils literal"><span class="pre">car</span></code> 跟 <code
                                  class="docutils literal"><span class="pre">cdr</span></code> 所定义的。要找到列表特定位置的元素，我们可以调用
                                <code class="docutils literal"><span class="pre">nth</span></code> ，
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">nth</span> <span class="mi">0</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">))</span>
<span class="nv">A</span>
</pre>
                                </div>
                              </div>
                              <p>而要找到第 <code class="docutils literal"><span class="pre">n</span></code> 个 <code
                                  class="docutils literal"><span class="pre">cdr</span></code> ，我们调用 <code
                                  class="docutils literal"><span class="pre">nthcdr</span></code> ：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">nthcdr</span> <span class="mi">2</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">))</span>
<span class="p">(</span><span class="nv">C</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p><code class="docutils literal"><span class="pre">nth</span></code> 与 <code
                                  class="docutils literal"><span class="pre">nthcdr</span></code> 都是零索引的 (zero-indexed);
                                即元素从 <code class="docutils literal"><span class="pre">0</span></code> 开始编号，而不是从 <code
                                  class="docutils literal"><span class="pre">1</span></code> 开始。在 Common Lisp
                                里，无论何时你使用一个数字来参照一个数据结构中的元素时，都是从 <code
                                  class="docutils literal"><span class="pre">0</span></code> 开始编号的。</p>
                              <p>两个函数几乎做一样的事; <code class="docutils literal"><span class="pre">nth</span></code> 等同于取
                                <code class="docutils literal"><span class="pre">nthcdr</span></code> 的 <code
                                  class="docutils literal"><span class="pre">car</span></code> 。没有检查错误的情况下， <code
                                  class="docutils literal"><span class="pre">nthcdr</span></code> 可以这么定义：
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">our-nthcdr</span> <span class="p">(</span><span class="nv">n</span> <span class="nv">lst</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">zerop</span> <span class="nv">n</span><span class="p">)</span>
      <span class="nv">lst</span>
      <span class="p">(</span><span class="nv">our-nthcdr</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">n</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">lst</span><span class="p">))))</span>
</pre>
                                </div>
                              </div>
                              <p>函数 <code class="docutils literal"><span class="pre">zerop</span></code> 仅在参数为零时，才返回真。
                              </p>
                              <p>函数 <code class="docutils literal"><span class="pre">last</span></code> 返回列表的最后一个
                                <em>Cons</em> 对象：
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">last</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">))</span>
<span class="p">(</span><span class="nv">C</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>这跟取得最后一个元素不一样。要取得列表的最后一个元素，你要取得 <code
                                  class="docutils literal"><span class="pre">last</span></code> 的 <code
                                  class="docutils literal"><span class="pre">car</span></code> 。</p>
                              <p>Common Lisp 定义了函数 <code class="docutils literal"><span class="pre">first</span></code>
                                直到 <code class="docutils literal"><span class="pre">tenth</span></code>
                                可以取得列表对应的元素。这些函数不是 <em>零索引的</em> (zero-indexed)：</p>
                              <p><code
                                  class="docutils literal"><span class="pre">(second</span> <span class="pre">x)</span></code>
                                等同于 <code
                                  class="docutils literal"><span class="pre">(nth</span> <span class="pre">1</span> <span class="pre">x)</span></code>
                                。</p>
                              <p>此外， Common Lisp 定义了像是 <code
                                  class="docutils literal"><span class="pre">caddr</span></code> 这样的函数，它是 <code
                                  class="docutils literal"><span class="pre">cdr</span></code> 的 <code
                                  class="docutils literal"><span class="pre">cdr</span></code> 的 <code
                                  class="docutils literal"><span class="pre">car</span></code> 的缩写 ( <code
                                  class="docutils literal"><span class="pre">car</span></code> of <code
                                  class="docutils literal"><span class="pre">cdr</span></code> of <code
                                  class="docutils literal"><span class="pre">cdr</span></code> )。所有这样形式的函数 <code
                                  class="docutils literal"><span class="pre">cxr</span></code> ，其中 x 是一个字符串，最多四个 <code
                                  class="docutils literal"><span class="pre">a</span></code> 或 <code
                                  class="docutils literal"><span class="pre">d</span></code> ，在 Common Lisp 里都被定义好了。使用
                                <code class="docutils literal"><span class="pre">cadr</span></code> 可能会有异常
                                (exception)产生，在所有人都可能会读的代码里使用这样的函数，可能不是个好主意。
                              </p>
                            </div>
                            <div class="section" id="mapping-functions">
                              <h4>3.7 映射函数 (Mapping Functions)<a class="headerlink" href="#mapping-functions"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>Common Lisp 提供了数个函数来对一个列表的元素做函数调用。最常使用的是 <code
                                  class="docutils literal"><span class="pre">mapcar</span></code>
                                ，接受一个函数以及一个或多个列表，并返回把函数应用至每个列表的元素的结果，直到有的列表没有元素为止：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">mapcar</span> <span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="mi">10</span><span class="p">))</span>
          <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">))</span>
<span class="p">(</span><span class="mi">11</span> <span class="mi">12</span> <span class="mi">13</span><span class="p">)</span>

<span class="nb">&gt;</span> <span class="p">(</span><span class="nb">mapcar</span> <span class="nf">#&#39;</span><span class="nb">list</span>
          <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">)</span>
          <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">))</span>
<span class="p">((</span><span class="nv">A</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nv">B</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="nv">C</span> <span class="mi">3</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p>相关的 <code class="docutils literal"><span class="pre">maplist</span></code>
                                接受同样的参数，将列表的渐进的下一个 <code class="docutils literal"><span class="pre">cdr</span></code>
                                传入函数。</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">maplist</span> <span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span> <span class="nv">x</span><span class="p">)</span>
           <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">))</span>
<span class="p">((</span><span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span><span class="p">)</span> <span class="p">(</span><span class="nv">B</span> <span class="nv">C</span><span class="p">)</span> <span class="p">(</span><span class="nv">C</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p>其它的映射函数，包括 <code class="docutils literal"><span class="pre">mapc</span></code> 我们在 89
                                页讨论（译注：5.4 节最后），以及 <code class="docutils literal"><span class="pre">mapcan</span></code>
                                在 202 页（译注：12.4 节最后）讨论。</p>
                            </div>
                            <div class="section" id="trees">
                              <h4>3.8 树 (Trees)<a class="headerlink" href="#trees"
                                  title="Permalink to this headline">¶</a></h4>
                              <p><em>Cons</em> 对象可以想成是二叉树， <code
                                  class="docutils literal"><span class="pre">car</span></code> 代表左子树，而 <code
                                  class="docutils literal"><span class="pre">cdr</span></code> 代表右子树。举例来说，列表</p>
                              <p><code
                                  class="docutils literal"><span class="pre">(a</span> <span class="pre">(b</span> <span class="pre">c)</span> <span class="pre">d)</span></code>
                                也是一棵由图 3.8 所代表的树。 （如果你逆时针旋转 45 度，你会发现跟图 3.3 一模一样）</p>
                              <div class="figure">
                                <img alt="_images/Figure-3.8.png" src="_images/Figure-3.8.png" />
                              </div>
                              <p>图 3.8 二叉树 (Binary Tree)</p>
                              <p>Common Lisp 有几个内置的操作树的函数。举例来说， <code
                                  class="docutils literal"><span class="pre">copy-tree</span></code>
                                接受一个树，并返回一份副本。它可以这么定义：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">our-copy-tree</span> <span class="p">(</span><span class="nv">tr</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">atom</span> <span class="nv">tr</span><span class="p">)</span>
       <span class="nv">tr</span>
       <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nv">our-copy-tree</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">tr</span><span class="p">))</span>
             <span class="p">(</span><span class="nv">our-copy-tree</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">tr</span><span class="p">)))))</span>
</pre>
                                </div>
                              </div>
                              <p>把这跟 36 页的 <code class="docutils literal"><span class="pre">copy-list</span></code>
                                比较一下； <code class="docutils literal"><span class="pre">copy-tree</span></code> 复制每一个
                                <em>Cons</em> 对象的 <code class="docutils literal"><span class="pre">car</span></code> 与
                                <code class="docutils literal"><span class="pre">cdr</span></code> ，而 <code
                                  class="docutils literal"><span class="pre">copy-list</span></code> 仅复制 <code
                                  class="docutils literal"><span class="pre">cdr</span></code> 。
                              </p>
                              <p>没有内部节点的二叉树没有太大的用处。 Common Lisp
                                包含了操作树的函数，不只是因为我们需要树这个结构，而是因为我们需要一种方法，来操作列表及所有内部的列表。举例来说，假设我们有一个这样的列表：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nb">integerp</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">zerop</span> <span class="p">(</span><span class="nb">mod</span> <span class="nv">x</span> <span class="mi">2</span><span class="p">)))</span>
</pre>
                                </div>
                              </div>
                              <p>而我们想要把各处的 <code class="docutils literal"><span class="pre">x</span></code> 都换成 <code
                                  class="docutils literal"><span class="pre">y</span></code> 。调用 <code
                                  class="docutils literal"><span class="pre">substitute</span></code> 是不行的，它只能替换序列
                                (sequence)中的元素：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">substitute</span> <span class="ss">&#39;y</span> <span class="ss">&#39;x</span> <span class="o">&#39;</span><span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nb">integerp</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">zerop</span> <span class="p">(</span><span class="nb">mod</span> <span class="nv">x</span> <span class="mi">2</span><span class="p">))))</span>
<span class="p">(</span><span class="nv">AND</span> <span class="p">(</span><span class="nv">INTEGERP</span> <span class="nv">X</span><span class="p">)</span> <span class="p">(</span><span class="nv">ZEROP</span> <span class="p">(</span><span class="nv">MOD</span> <span class="nv">X</span> <span class="mi">2</span><span class="p">)))</span>
</pre>
                                </div>
                              </div>
                              <p>这个调用是无效的，因为列表有三个元素，没有一个元素是 <code
                                  class="docutils literal"><span class="pre">x</span></code> 。我们在这所需要的是 <code
                                  class="docutils literal"><span class="pre">subst</span></code> ，它替换树之中的元素。</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">subst</span> <span class="ss">&#39;y</span> <span class="ss">&#39;x</span> <span class="o">&#39;</span><span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nb">integerp</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">zerop</span> <span class="p">(</span><span class="nb">mod</span> <span class="nv">x</span> <span class="mi">2</span><span class="p">))))</span>
<span class="p">(</span><span class="nv">AND</span> <span class="p">(</span><span class="nv">INTEGERP</span> <span class="nv">Y</span><span class="p">)</span> <span class="p">(</span><span class="nv">ZEROP</span> <span class="p">(</span><span class="nv">MOD</span> <span class="nv">Y</span> <span class="mi">2</span><span class="p">)))</span>
</pre>
                                </div>
                              </div>
                              <p>如果我们定义一个 <code class="docutils literal"><span class="pre">subst</span></code> 的版本，它看起来跟
                                <code class="docutils literal"><span class="pre">copy-tree</span></code> 很相似：
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">defun</span> <span class="nv">our-subst</span> <span class="p">(</span><span class="nv">new</span> <span class="nv">old</span> <span class="nv">tree</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">eql</span> <span class="nv">tree</span> <span class="nv">old</span><span class="p">)</span>
        <span class="nv">new</span>
        <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">atom</span> <span class="nv">tree</span><span class="p">)</span>
            <span class="nv">tree</span>
            <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nv">our-subst</span> <span class="nv">new</span> <span class="nv">old</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">tree</span><span class="p">))</span>
                  <span class="p">(</span><span class="nv">our-subst</span> <span class="nv">new</span> <span class="nv">old</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">tree</span><span class="p">))))))</span>
</pre>
                                </div>
                              </div>
                              <p>操作树的函数通常有这种形式， <code class="docutils literal"><span class="pre">car</span></code> 与
                                <code class="docutils literal"><span class="pre">cdr</span></code> 同时做递归。这种函数被称之为是
                                <em>双重递归</em> (doubly recursive)。
                              </p>
                            </div>
                            <div class="section" id="understanding-recursion">
                              <h4>3.9 理解递归 (Understanding Recursion)<a class="headerlink"
                                  href="#understanding-recursion" title="Permalink to this headline">¶</a></h4>
                              <p>学生在学习递归时，有时候是被鼓励在纸上追踪 (trace)递归程序调用 (invocation)的过程。 (288页「译注：<a
                                  class="reference external"
                                  href="http://acl.readthedocs.org/en/latest/zhCN/appendix-A-cn.html">附录 A
                                  追踪与回溯</a>」可以看到一个递归函数的追踪过程。)但这种练习可能会误导你：一个程序员在定义一个递归函数时，通常不会特别地去想函数的调用顺序所导致的结果。</p>
                              <p>
                                如果一个人总是需要这样子思考程序，递归会是艰难的、没有帮助的。递归的优点是它精确地让我们更抽象地来设计算法。你不需要考虑真正函数时所有的调用过程，就可以判断一个递归函数是否是正确的。
                              </p>
                              <p>要知道一个递归函数是否做它该做的事，你只需要问，它包含了所有的情况吗？举例来说，下面是一个寻找列表长度的递归函数：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">defun</span> <span class="nv">len</span> <span class="p">(</span><span class="nv">lst</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">null</span> <span class="nv">lst</span><span class="p">)</span>
        <span class="mi">0</span>
        <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nv">len</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">lst</span><span class="p">))</span> <span class="mi">1</span><span class="p">)))</span>
</pre>
                                </div>
                              </div>
                              <p>我们可以借由检查两件事情，来确信这个函数是正确的：</p>
                              <ol class="arabic simple">
                                <li>对长度为 <code class="docutils literal"><span class="pre">0</span></code> 的列表是有效的。</li>
                                <li>给定它对于长度为 <code class="docutils literal"><span class="pre">n</span></code>
                                  的列表是有效的，它对长度是 <code class="docutils literal"><span class="pre">n+1</span></code>
                                  的列表也是有效的。</li>
                              </ol>
                              <p>如果这两点是成立的，我们知道这个函数对于所有可能的列表都是正确的。</p>
                              <p>我们的定义显然地满足第一点：如果列表( <code class="docutils literal"><span class="pre">lst</span></code>
                                ) 是空的( <code class="docutils literal"><span class="pre">nil</span></code> )，函数直接返回 <code
                                  class="docutils literal"><span class="pre">0</span></code> 。现在假定我们的函数对长度为 <code
                                  class="docutils literal"><span class="pre">n</span></code> 的列表是有效的。我们给它一个 <code
                                  class="docutils literal"><span class="pre">n+1</span></code> 长度的列表。这个定义说明了，函数会返回列表的
                                <code class="docutils literal"><span class="pre">cdr</span></code> 的长度再加上 <code
                                  class="docutils literal"><span class="pre">1</span></code> 。 <code
                                  class="docutils literal"><span class="pre">cdr</span></code> 是一个长度为 <code
                                  class="docutils literal"><span class="pre">n</span></code> 的列表。我们经由假定可知它的长度是 <code
                                  class="docutils literal"><span class="pre">n</span></code> 。所以整个列表的长度是 <code
                                  class="docutils literal"><span class="pre">n+1</span></code> 。
                              </p>
                              <p>我们需要知道的就是这些。理解递归的秘密就像是处理括号一样。你怎么知道哪个括号对上哪个？你不需要这么做。你怎么想像那些调用过程？你不需要这么做。</p>
                              <p>更复杂的递归函数，可能会有更多的情况需要讨论，但是流程是一样的。举例来说， 41 页的 <code
                                  class="docutils literal"><span class="pre">our-copy-tree</span></code> ，我们需要讨论三个情况：
                                原子，单一的 <em>Cons</em> 对象， <code
                                  class="docutils literal"><span class="pre">n+1</span></code> 的 <em>Cons</em> 树。</p>
                              <p>第一个情况（长度零的列表）称之为<em>基本用例</em>( <em>base case</em>
                                )。当一个递归函数不像你想的那样工作时，通常是处理基本用例就错了。下面这个不正确的 <code
                                  class="docutils literal"><span class="pre">member</span></code> 定义，是一个常见的错误，整个忽略了基本用例：
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">our-member</span> <span class="p">(</span><span class="nv">obj</span> <span class="nv">lst</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">eql</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">lst</span><span class="p">)</span> <span class="nv">obj</span><span class="p">)</span>
      <span class="nv">lst</span>
      <span class="p">(</span><span class="nv">our-member</span> <span class="nv">obj</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">lst</span><span class="p">))))</span>
</pre>
                                </div>
                              </div>
                              <p>我们需要初始一个 <code class="docutils literal"><span class="pre">null</span></code>
                                测试，确保在到达列表底部时，没有找到目标时要停止递归。如果我们要找的对象没有在列表里，这个版本的 <code
                                  class="docutils literal"><span class="pre">member</span></code> 会陷入无穷循环。附录 A
                                更详细地讨论了这种问题。</p>
                              <p>能够判断一个递归函数是否正确只不过是理解递归的上半场，下半场是能够写出一个做你想做的事情的递归函数。 6.9 节讨论了这个问题。</p>
                            </div>
                            <div class="section" id="sets">
                              <h4>3.10 集合 (Sets)<a class="headerlink" href="#sets"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>列表是表示小集合的好方法。列表中的每个元素都代表了一个集合的成员：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">member</span> <span class="ss">&#39;b</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">))</span>
<span class="p">(</span><span class="nv">B</span> <span class="nv">C</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>当 <code class="docutils literal"><span class="pre">member</span></code> 要返回“真”时，与其仅仅返回
                                <code class="docutils literal"><span class="pre">t</span></code>
                                ，它返回由寻找对象所开始的那部分。逻辑上来说，一个 <em>Cons</em> 扮演的角色和 <code
                                  class="docutils literal"><span class="pre">t</span></code> 一样，而经由这么做，函数返回了更多资讯。
                              </p>
                              <p>一般情况下， <code class="docutils literal"><span class="pre">member</span></code> 使用 <code
                                  class="docutils literal"><span class="pre">eql</span></code>
                                来比较对象。你可以使用一种叫做关键字参数的东西来重写缺省的比较方法。多数的 Common Lisp
                                函数接受一个或多个关键字参数。这些关键字参数不同的地方是，他们不是把对应的参数放在特定的位置作匹配，而是在函数调用中用特殊标签，称为关键字，来作匹配。一个关键字是一个前面有冒号的符号。
                              </p>
                              <p>一个 <code class="docutils literal"><span class="pre">member</span></code> 函数所接受的关键字参数是
                                <code class="docutils literal"><span class="pre">:test</span></code> 参数。
                              </p>
                              <p>如果你在调用 <code class="docutils literal"><span class="pre">member</span></code> 时，传入某个函数作为
                                <code class="docutils literal"><span class="pre">:test</span></code>
                                参数，那么那个函数就会被用来比较是否相等，而不是用 <code
                                  class="docutils literal"><span class="pre">eql</span></code>
                                。所以如果我们想找到一个给定的对象与列表中的成员是否相等( <code
                                  class="docutils literal"><span class="pre">equal</span></code> )，我们可以：
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">member</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">((</span><span class="nv">a</span><span class="p">)</span> <span class="p">(</span><span class="nv">z</span><span class="p">))</span> <span class="ss">:test</span> <span class="nf">#&#39;</span><span class="nb">equal</span><span class="p">)</span>
<span class="p">((</span><span class="nv">A</span><span class="p">)</span> <span class="p">(</span><span class="nv">Z</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p>关键字参数总是选择性添加的。如果你在一个调用中包含了任何的关键字参数，他们要摆在最后; 如果使用了超过一个的关键字参数，摆放的顺序无关紧要。</p>
                              <p>另一个 <code class="docutils literal"><span class="pre">member</span></code> 接受的关键字参数是
                                <code class="docutils literal"><span class="pre">:key</span></code>
                                参数。借由提供这个参数，你可以在作比较之前，指定一个函数运用在每一个元素：
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">member</span> <span class="ss">&#39;a</span> <span class="o">&#39;</span><span class="p">((</span><span class="nv">a</span> <span class="nv">b</span><span class="p">)</span> <span class="p">(</span><span class="nv">c</span> <span class="nv">d</span><span class="p">))</span> <span class="ss">:key</span> <span class="nf">#&#39;</span><span class="nb">car</span><span class="p">)</span>
<span class="p">((</span><span class="nv">A</span> <span class="nv">B</span><span class="p">)</span> <span class="p">(</span><span class="nv">C</span> <span class="nv">D</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p>在这个例子里，我们询问是否有一个元素的 <code class="docutils literal"><span class="pre">car</span></code>
                                是 <code class="docutils literal"><span class="pre">a</span></code> 。</p>
                              <p>如果我们想要使用两个关键字参数，我们可以使用其中一个顺序。下面这两个调用是等价的：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">member</span> <span class="mi">2</span> <span class="o">&#39;</span><span class="p">((</span><span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="mi">2</span><span class="p">))</span> <span class="ss">:key</span> <span class="nf">#&#39;</span><span class="nb">car</span> <span class="ss">:test</span> <span class="nf">#&#39;</span><span class="nb">equal</span><span class="p">)</span>
<span class="p">((</span><span class="mi">2</span><span class="p">))</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="nb">member</span> <span class="mi">2</span> <span class="o">&#39;</span><span class="p">((</span><span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="mi">2</span><span class="p">))</span> <span class="ss">:test</span> <span class="nf">#&#39;</span><span class="nb">equal</span> <span class="ss">:key</span> <span class="nf">#&#39;</span><span class="nb">car</span><span class="p">)</span>
<span class="p">((</span><span class="mi">2</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p>两者都询问是否有一个元素的 <code class="docutils literal"><span class="pre">car</span></code> 等于(
                                <code class="docutils literal"><span class="pre">equal</span></code> ) 2。
                              </p>
                              <p>如果我们想要找到一个元素满足任意的判断式像是── <code
                                  class="docutils literal"><span class="pre">oddp</span></code> ，奇数返回真──我们可以使用相关的 <code
                                  class="docutils literal"><span class="pre">member-if</span></code> ：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">member-if</span> <span class="nf">#&#39;</span><span class="nb">oddp</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">))</span>
<span class="p">(</span><span class="mi">3</span> <span class="mi">4</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>我们可以想像一个限制性的版本 <code class="docutils literal"><span class="pre">member-if</span></code>
                                是这样写成的：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">our-member-if</span> <span class="p">(</span><span class="nv">fn</span> <span class="nv">lst</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nb">consp</span> <span class="nv">lst</span><span class="p">)</span>
       <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">funcall</span> <span class="nv">fn</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">lst</span><span class="p">))</span>
           <span class="nv">lst</span>
           <span class="p">(</span><span class="nv">our-member-if</span> <span class="nv">fn</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">lst</span><span class="p">)))))</span>
</pre>
                                </div>
                              </div>
                              <p>函数 <code class="docutils literal"><span class="pre">adjoin</span></code> 像是条件式的 <code
                                  class="docutils literal"><span class="pre">cons</span></code>
                                。它接受一个对象及一个列表，如果对象还不是列表的成员，才构造对象至列表上。</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">adjoin</span> <span class="ss">&#39;b</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">))</span>
<span class="p">(</span><span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span><span class="p">)</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="nb">adjoin</span> <span class="ss">&#39;z</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">))</span>
<span class="p">(</span><span class="nv">Z</span> <span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>通常的情况下它接受与 <code class="docutils literal"><span class="pre">member</span></code>
                                函数同样的关键字参数。</p>
                              <p>集合论中的并集 (union)、交集 (intersection)以及补集 (complement)的实现，是由函数 <code
                                  class="docutils literal"><span class="pre">union</span></code> 、 <code
                                  class="docutils literal"><span class="pre">intersection</span></code> 以及 <code
                                  class="docutils literal"><span class="pre">set-difference</span></code> 。</p>
                              <p>这些函数期望两个（正好 2 个）列表（一样接受与 <code
                                  class="docutils literal"><span class="pre">member</span></code> 函数同样的关键字参数）。</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">union</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">c</span> <span class="nv">b</span> <span class="nv">s</span><span class="p">))</span>
<span class="p">(</span><span class="nv">A</span> <span class="nv">C</span> <span class="nv">B</span> <span class="nv">S</span><span class="p">)</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="nb">intersection</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">b</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">))</span>
<span class="p">(</span><span class="nv">B</span> <span class="nv">C</span><span class="p">)</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="nb">set-difference</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span> <span class="nv">e</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">b</span> <span class="nv">e</span><span class="p">))</span>
<span class="p">(</span><span class="nv">A</span> <span class="nv">C</span> <span class="nv">D</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>因为集合中没有顺序的概念，这些函数不需要保留原本元素在列表被找到的顺序。举例来说，调用 <code
                                  class="docutils literal"><span class="pre">set-difference</span></code> 也有可能返回 <code
                                  class="docutils literal"><span class="pre">(d</span> <span class="pre">c</span> <span class="pre">a)</span></code>
                                。</p>
                            </div>
                            <div class="section" id="sequences">
                              <h4>3.11 序列 (Sequences)<a class="headerlink" href="#sequences"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>另一种考虑一个列表的方式是想成一系列有特定顺序的对象。在 Common Lisp 里，<em>序列</em>( <em>sequences</em> )包括了列表与向量
                                (vectors)。本节介绍了一些可以运用在列表上的序列函数。更深入的序列操作在 4.4 节讨论。</p>
                              <p>函数 <code class="docutils literal"><span class="pre">length</span></code> 返回序列中元素的数目。
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">length</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">))</span>
<span class="mi">3</span>
</pre>
                                </div>
                              </div>
                              <p>我们在 24 页 (译注：2.13节 <code
                                  class="docutils literal"><span class="pre">our-length</span></code>
                                )写过这种函数的一个版本（仅可用于列表）。</p>
                              <p>要复制序列的一部分，我们使用 <code class="docutils literal"><span class="pre">subseq</span></code>
                                。第二个（需要的）参数是第一个开始引用进来的元素位置，第三个（选择性）参数是第一个不引用进来的元素位置。</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">subseq</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span><span class="p">)</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">)</span>
<span class="p">(</span><span class="nv">B</span><span class="p">)</span>
<span class="nb">&gt;</span><span class="p">(</span><span class="nb">subseq</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span><span class="p">)</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">(</span><span class="nv">B</span> <span class="nv">C</span> <span class="nv">D</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>如果省略了第三个参数，子序列会从第二个参数给定的位置引用到序列尾端。</p>
                              <p>函数 <code class="docutils literal"><span class="pre">reverse</span></code>
                                返回与其参数相同元素的一个序列，但顺序颠倒。</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">reverse</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">))</span>
<span class="p">(</span><span class="nv">C</span> <span class="nv">B</span> <span class="nv">A</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>一个回文 (palindrome) 是一个正读反读都一样的序列 —— 举例来说， <code
                                  class="docutils literal"><span class="pre">(abba)</span></code>
                                。如果一个回文有偶数个元素，那么后半段会是前半段的镜射 (mirror)。使用 <code
                                  class="docutils literal"><span class="pre">length</span></code> 、 <code
                                  class="docutils literal"><span class="pre">subseq</span></code> 以及 <code
                                  class="docutils literal"><span class="pre">reverse</span></code> ，我们可以定义一个函数</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">mirror?</span> <span class="p">(</span><span class="nv">s</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">len</span> <span class="p">(</span><span class="nb">length</span> <span class="nv">s</span><span class="p">)))</span>
    <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nb">evenp</span> <span class="nv">len</span><span class="p">)</span>
         <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">mid</span> <span class="p">(</span><span class="nb">/</span> <span class="nv">len</span> <span class="mi">2</span><span class="p">)))</span>
           <span class="p">(</span><span class="nb">equal</span> <span class="p">(</span><span class="nb">subseq</span> <span class="nv">s</span> <span class="mi">0</span> <span class="nv">mid</span><span class="p">)</span>
                  <span class="p">(</span><span class="nb">reverse</span> <span class="p">(</span><span class="nb">subseq</span> <span class="nv">s</span> <span class="nv">mid</span><span class="p">)))))))</span>
</pre>
                                </div>
                              </div>
                              <p>来检测是否是回文：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">mirror?</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">b</span> <span class="nv">a</span><span class="p">))</span>
<span class="no">T</span>
</pre>
                                </div>
                              </div>
                              <p>Common Lisp 有一个内置的排序函数叫做 <code
                                  class="docutils literal"><span class="pre">sort</span></code>
                                。它接受一个序列及一个比较两个参数的函数，返回一个有同样元素的序列，根据比较函数来排序：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">sort</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">0</span> <span class="mi">2</span> <span class="mi">1</span> <span class="mi">3</span> <span class="mi">8</span><span class="p">)</span> <span class="nf">#&#39;</span><span class="nb">&gt;</span><span class="p">)</span>
<span class="p">(</span><span class="mi">8</span> <span class="mi">3</span> <span class="mi">2</span> <span class="mi">1</span> <span class="mi">0</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>你要小心使用 <code class="docutils literal"><span class="pre">sort</span></code>
                                ，因为它是<em>破坏性的</em>(<em>destructive</em>)。考虑到效率的因素， <code
                                  class="docutils literal"><span class="pre">sort</span></code>
                                被允许修改传入的序列。所以如果你不想你本来的序列被改动，传入一个副本。</p>
                              <p>使用 <code class="docutils literal"><span class="pre">sort</span></code> 及 <code
                                  class="docutils literal"><span class="pre">nth</span></code> ，我们可以写一个函数，接受一个整数 <code
                                  class="docutils literal"><span class="pre">n</span></code> ，返回列表中第 <code
                                  class="docutils literal"><span class="pre">n</span></code> 大的元素：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">nthmost</span> <span class="p">(</span><span class="nv">n</span> <span class="nv">lst</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">nth</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">n</span> <span class="mi">1</span><span class="p">)</span>
       <span class="p">(</span><span class="nb">sort</span> <span class="p">(</span><span class="nb">copy-list</span> <span class="nv">lst</span><span class="p">)</span> <span class="nf">#&#39;</span><span class="nb">&gt;</span><span class="p">)))</span>
</pre>
                                </div>
                              </div>
                              <p>我们把整数减一因为 <code class="docutils literal"><span class="pre">nth</span></code> 是零索引的，但如果
                                <code class="docutils literal"><span class="pre">nthmost</span></code> 是这样的话，会变得很不直观。
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nv">nthmost</span> <span class="mi">2</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">0</span> <span class="mi">2</span> <span class="mi">1</span> <span class="mi">3</span> <span class="mi">8</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p>多努力一点，我们可以写出这个函数的一个更有效率的版本。</p>
                              <p>函数 <code class="docutils literal"><span class="pre">every</span></code> 和 <code
                                  class="docutils literal"><span class="pre">some</span></code>
                                接受一个判断式及一个或多个序列。当我们仅输入一个序列时，它们测试序列元素是否满足判断式：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">every</span> <span class="nf">#&#39;</span><span class="nb">oddp</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">3</span> <span class="mi">5</span><span class="p">))</span>
<span class="no">T</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="nb">some</span> <span class="nf">#&#39;</span><span class="nb">evenp</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">))</span>
<span class="no">T</span>
</pre>
                                </div>
                              </div>
                              <p>如果它们输入多于一个序列时，判断式必须接受与序列一样多的元素作为参数，而参数从所有序列中一次提取一个：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">every</span> <span class="nf">#&#39;</span><span class="nb">&gt;</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">3</span> <span class="mi">5</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">0</span> <span class="mi">2</span> <span class="mi">4</span><span class="p">))</span>
<span class="no">T</span>
</pre>
                                </div>
                              </div>
                              <p>如果序列有不同的长度，最短的那个序列，决定需要测试的次数。</p>
                            </div>
                            <div class="section" id="stacks">
                              <h4>3.12 栈 (Stacks)<a class="headerlink" href="#stacks"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>用 <em>Cons</em> 对象来表示的列表，很自然地我们可以拿来实现下推栈 (pushdown stack)。这太常见了，以致于 Common Lisp
                                提供了两个宏给堆使用： <code
                                  class="docutils literal"><span class="pre">(push</span> <span class="pre">x</span> <span class="pre">y)</span></code>
                                把 <code class="docutils literal"><span class="pre">x</span></code> 放入列表 <code
                                  class="docutils literal"><span class="pre">y</span></code> 的前端。而 <code
                                  class="docutils literal"><span class="pre">(pop</span> <span class="pre">x)</span></code>
                                则是将列表 x 的第一个元素移除，并返回这个元素。</p>
                              <p>两个函数都是由 <code class="docutils literal"><span class="pre">setf</span></code>
                                定义的。如果参数是常数或变量，很简单就可以翻译出对应的函数调用。</p>
                              <p>表达式</p>
                              <p><code
                                  class="docutils literal"><span class="pre">(push</span> <span class="pre">obj</span> <span class="pre">lst)</span></code>
                              </p>
                              <p>等同于</p>
                              <p><code
                                  class="docutils literal"><span class="pre">(setf</span> <span class="pre">lst</span> <span class="pre">(cons</span> <span class="pre">obj</span> <span class="pre">lst))</span></code>
                              </p>
                              <p>而表达式</p>
                              <p><code
                                  class="docutils literal"><span class="pre">(pop</span> <span class="pre">lst)</span></code>
                              </p>
                              <p>等同于</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">x</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">lst</span><span class="p">)))</span>
  <span class="p">(</span><span class="nb">setf</span> <span class="nv">lst</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">lst</span><span class="p">))</span>
  <span class="nv">x</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>所以，举例来说：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">setf</span> <span class="nv">x</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">b</span><span class="p">))</span>
<span class="p">(</span><span class="nv">B</span><span class="p">)</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="nb">push</span> <span class="ss">&#39;a</span> <span class="nv">x</span><span class="p">)</span>
<span class="p">(</span><span class="nv">A</span> <span class="nv">B</span><span class="p">)</span>
<span class="nb">&gt;</span> <span class="nv">x</span>
<span class="p">(</span><span class="nv">A</span> <span class="nv">B</span><span class="p">)</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="nb">setf</span> <span class="nv">y</span> <span class="nv">x</span><span class="p">)</span>
<span class="p">(</span><span class="nv">A</span> <span class="nv">B</span><span class="p">)</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="nb">pop</span> <span class="nv">x</span><span class="p">)</span>
<span class="p">(</span><span class="nv">A</span><span class="p">)</span>
<span class="nb">&gt;</span> <span class="nv">x</span>
<span class="p">(</span><span class="nv">B</span><span class="p">)</span>
<span class="nb">&gt;</span> <span class="nv">y</span>
<span class="p">(</span><span class="nv">A</span> <span class="nv">B</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>以上，全都遵循上述由 <code class="docutils literal"><span class="pre">setf</span></code>
                                所给出的相等式。图 3.9 展示了这些表达式被求值后的结构。</p>
                              <div class="figure">
                                <img alt="_images/Figure-3.9.png" src="_images/Figure-3.9.png" />
                              </div>
                              <p>图 3.9 push 及 pop 的效果</p>
                              <p>你可以使用 <code class="docutils literal"><span class="pre">push</span></code>
                                来定义一个给列表使用的互动版 <code class="docutils literal"><span class="pre">reverse</span></code> 。
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">our-reverse</span> <span class="p">(</span><span class="nv">lst</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">acc</span> <span class="no">nil</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">dolist</span> <span class="p">(</span><span class="nb">elt</span> <span class="nv">lst</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">push</span> <span class="nb">elt</span> <span class="nv">acc</span><span class="p">))</span>
    <span class="nv">acc</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p>在这个版本，我们从一个空列表开始，然后把 <code class="docutils literal"><span class="pre">lst</span></code>
                                的每一个元素放入空表里。等我们完成时，<code class="docutils literal"><span class="pre">lst</span></code>
                                最后一个元素会在最前端。</p>
                              <p><code class="docutils literal"><span class="pre">pushnew</span></code> 宏是 <code
                                  class="docutils literal"><span class="pre">push</span></code> 的变种，使用了 <code
                                  class="docutils literal"><span class="pre">adjoin</span></code> 而不是 <code
                                  class="docutils literal"><span class="pre">cons</span></code> ：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre> <span class="nb">&gt;</span> <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">x</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span><span class="p">)))</span>
     <span class="p">(</span><span class="nb">pushnew</span> <span class="ss">&#39;c</span> <span class="nv">x</span><span class="p">)</span>
     <span class="p">(</span><span class="nb">pushnew</span> <span class="ss">&#39;a</span> <span class="nv">x</span><span class="p">)</span>
     <span class="nv">x</span><span class="p">)</span>
<span class="p">(</span><span class="nv">C</span> <span class="nv">A</span> <span class="nv">B</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>在这里， <code class="docutils literal"><span class="pre">c</span></code> 被放入列表，但是 <code
                                  class="docutils literal"><span class="pre">a</span></code> 没有，因为它已经是列表的一个成员了。</p>
                            </div>
                            <div class="section" id="dotted-lists">
                              <h4>3.13 点状列表 (Dotted Lists)<a class="headerlink" href="#dotted-lists"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>调用 <code class="docutils literal"><span class="pre">list</span></code>
                                所构造的列表，这种列表精确地说称之为正规列表(<em>proper</em>list )。一个正规列表可以是 <code
                                  class="docutils literal"><span class="pre">NIL</span></code> 或是 <code
                                  class="docutils literal"><span class="pre">cdr</span></code> 是正规列表的 <em>Cons</em>
                                对象。也就是说，我们可以定义一个只对正规列表返回真的判断式： <a class="footnote-reference" href="#id5"
                                  id="id2">[3]</a></p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">proper-list?</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">or</span> <span class="p">(</span><span class="nb">null</span> <span class="nv">x</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nb">consp</span> <span class="nv">x</span><span class="p">)</span>
           <span class="p">(</span><span class="nv">proper-list?</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">x</span><span class="p">)))))</span>
</pre>
                                </div>
                              </div>
                              <p>至目前为止，我们构造的列表都是正规列表。</p>
                              <p>然而， <code class="docutils literal"><span class="pre">cons</span></code>
                                不仅是构造列表。无论何时你需要一个具有两个字段 (field)的列表，你可以使用一个 <em>Cons</em> 对象。你能够使用 <code
                                  class="docutils literal"><span class="pre">car</span></code> 来参照第一个字段，用 <code
                                  class="docutils literal"><span class="pre">cdr</span></code> 来参照第二个字段。</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">setf</span> <span class="nv">pair</span> <span class="p">(</span><span class="nb">cons</span> <span class="ss">&#39;a</span> <span class="ss">&#39;b</span><span class="p">))</span>
<span class="p">(</span><span class="nv">A</span> <span class="o">.</span> <span class="nv">B</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>因为这个 <em>Cons</em> 对象不是一个正规列表，它用点状表示法来显示。在点状表示法，每个 <em>Cons</em> 对象的 <code
                                  class="docutils literal"><span class="pre">car</span></code> 与 <code
                                  class="docutils literal"><span class="pre">cdr</span></code> 由一个句点隔开来表示。这个
                                <em>Cons</em> 对象的结构展示在图 3.10 。
                              </p>
                              <div class="figure">
                                <img alt="_images/Figure-3.10.png" src="_images/Figure-3.10.png" />
                              </div>
                              <p>图3.10 一个成对的 <em>Cons</em> 对象 (A cons used as a pair)</p>
                              <p>一个非正规列表的 <em>Cons</em> 对象称之为点状列表 (dotted list)。这不是个好名字，因为非正规列表的 Cons 对象通常不是用来表示列表：
                                <code
                                  class="docutils literal"><span class="pre">(a</span> <span class="pre">.</span> <span class="pre">b)</span></code>
                                只是一个有两部分的数据结构。
                              </p>
                              <p>你也可以用点状表示法表示正规列表，但当 Lisp 显示一个正规列表时，它会使用普通的列表表示法：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="o">.</span> <span class="p">(</span><span class="nv">b</span> <span class="o">.</span> <span class="p">(</span><span class="nv">c</span> <span class="o">.</span> <span class="no">nil</span><span class="p">)))</span>
<span class="p">(</span><span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>顺道一提，注意列表由点状表示法与图 3.2 箱子表示法的关联性。</p>
                              <p>还有一个过渡形式 (intermediate form)的表示法，介于列表表示法及纯点状表示法之间，对于 <code
                                  class="docutils literal"><span class="pre">cdr</span></code> 是点状列表的 <em>Cons</em> 对象：
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">cons</span> <span class="ss">&#39;a</span> <span class="p">(</span><span class="nb">cons</span> <span class="ss">&#39;b</span> <span class="p">(</span><span class="nb">cons</span> <span class="ss">&#39;c</span> <span class="ss">&#39;d</span><span class="p">)))</span>
<span class="p">(</span><span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="o">.</span> <span class="nv">D</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <div class="figure">
                                <img alt="_images/Figure-3.11.png" src="_images/Figure-3.11.png" />
                              </div>
                              <p>图 3.11 一个点状列表 (A dotted list)</p>
                              <p>这样的 <em>Cons</em> 对象看起来像正规列表，除了最后一个 cdr 前面有一个句点。这个列表的结构展示在图 3.11 ; 注意它跟图3.2 是多么的相似。</p>
                              <p>所以实际上你可以这么表示列表 <code
                                  class="docutils literal"><span class="pre">(a</span> <span class="pre">b)</span></code>
                                ，</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nv">a</span> <span class="o">.</span> <span class="p">(</span><span class="nv">b</span> <span class="o">.</span> <span class="no">nil</span><span class="p">))</span>
<span class="p">(</span><span class="nv">a</span> <span class="o">.</span> <span class="p">(</span><span class="nv">b</span><span class="p">))</span>
<span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="o">.</span> <span class="no">nil</span><span class="p">)</span>
<span class="p">(</span><span class="nv">a</span> <span class="nv">b</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>虽然 Lisp 总是使用后面的形式，来显示这个列表。</p>
                            </div>
                            <div class="section" id="assoc-lists">
                              <h4>3.14 关联列表 (Assoc-lists)<a class="headerlink" href="#assoc-lists"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>用 <em>Cons</em> 对象来表示映射 (mapping)也是很自然的。一个由 <em>Cons</em>
                                对象组成的列表称之为<em>关联列表</em>(<em>assoc-list</em>or <em>alist</em>)。这样的列表可以表示一个翻译的集合，举例来说：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">setf</span> <span class="nv">trans</span> <span class="o">&#39;</span><span class="p">((</span><span class="nb">+</span> <span class="o">.</span> <span class="s">&quot;add&quot;</span><span class="p">)</span> <span class="p">(</span><span class="nb">-</span> <span class="o">.</span> <span class="s">&quot;subtract&quot;</span><span class="p">)))</span>
<span class="p">((</span><span class="nb">+</span> <span class="o">.</span> <span class="s">&quot;add&quot;</span><span class="p">)</span> <span class="p">(</span><span class="nb">-</span> <span class="o">.</span> <span class="s">&quot;subtract&quot;</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p>关联列表很慢，但是在初期的程序中很方便。 Common Lisp 有一个内置的函数 <code
                                  class="docutils literal"><span class="pre">assoc</span></code> ，用来取出在关联列表中，与给定的键值有关联的
                                <em>Cons</em> 对：
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">assoc</span> <span class="ss">&#39;+</span> <span class="nv">trans</span><span class="p">)</span>
<span class="p">(</span><span class="nb">+</span> <span class="o">.</span> <span class="s">&quot;add&quot;</span><span class="p">)</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="nb">assoc</span> <span class="ss">&#39;*</span> <span class="nv">trans</span><span class="p">)</span>
<span class="no">NIL</span>
</pre>
                                </div>
                              </div>
                              <p>如果 <code class="docutils literal"><span class="pre">assoc</span></code> 没有找到要找的东西时，返回
                                <code class="docutils literal"><span class="pre">nil</span></code> 。
                              </p>
                              <p>我们可以定义一个受限版本的 <code class="docutils literal"><span class="pre">assoc</span></code> ：
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">our-assoc</span> <span class="p">(</span><span class="nv">key</span> <span class="nv">alist</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nb">consp</span> <span class="nv">alist</span><span class="p">)</span>
       <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">pair</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">alist</span><span class="p">)))</span>
        <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">eql</span> <span class="nv">key</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">pair</span><span class="p">))</span>
            <span class="nv">pair</span>
            <span class="p">(</span><span class="nv">our-assoc</span> <span class="nv">key</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">alist</span><span class="p">))))))</span>
</pre>
                                </div>
                              </div>
                              <p>和 <code class="docutils literal"><span class="pre">member</span></code> 一样，实际上的 <code
                                  class="docutils literal"><span class="pre">assoc</span></code> 接受关键字参数，包括 <code
                                  class="docutils literal"><span class="pre">:test</span></code> 和 <code
                                  class="docutils literal"><span class="pre">:key</span></code> 。 Common Lisp 也定义了一个
                                <code class="docutils literal"><span class="pre">assoc-if</span></code> 之于 <code
                                  class="docutils literal"><span class="pre">assoc</span></code> ，如同 <code
                                  class="docutils literal"><span class="pre">member-if</span></code> 之于 <code
                                  class="docutils literal"><span class="pre">member</span></code> 一样。
                              </p>
                            </div>
                            <div class="section" id="example-shortest-path">
                              <h4>3.15 示例：最短路径 (Example: Shortest Path)<a class="headerlink"
                                  href="#example-shortest-path" title="Permalink to this headline">¶</a></h4>
                              <p>图 3.12 包含一个搜索网络中最短路径的程序。函数 <code
                                  class="docutils literal"><span class="pre">shortest-path</span></code>
                                接受一个起始节点，目的节点以及一个网络，并返回最短路径，如果有的话。</p>
                              <p>在这个范例中，节点用符号表示，而网络用含以下元素形式的关联列表来表示：</p>
                              <p><em>(node . neighbors)</em></p>
                              <p>所以由图 3.13 展示的最小网络 (minimal network)可以这样来表示：</p>
                              <p><code
                                  class="docutils literal"><span class="pre">(setf</span> <span class="pre">min</span> <span class="pre">'((a</span> <span class="pre">b</span> <span class="pre">c)</span> <span class="pre">(b</span> <span class="pre">c)</span> <span class="pre">(c</span> <span class="pre">d)))</span></code>
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">shortest-path</span> <span class="p">(</span><span class="nv">start</span> <span class="nv">end</span> <span class="nv">net</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">bfs</span> <span class="nv">end</span> <span class="p">(</span><span class="nb">list</span> <span class="p">(</span><span class="nb">list</span> <span class="nv">start</span><span class="p">))</span> <span class="nv">net</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">bfs</span> <span class="p">(</span><span class="nv">end</span> <span class="nv">queue</span> <span class="nv">net</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">null</span> <span class="nv">queue</span><span class="p">)</span>
      <span class="no">nil</span>
      <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">path</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">queue</span><span class="p">)))</span>
        <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">node</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">path</span><span class="p">)))</span>
          <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">eql</span> <span class="nv">node</span> <span class="nv">end</span><span class="p">)</span>
              <span class="p">(</span><span class="nb">reverse</span> <span class="nv">path</span><span class="p">)</span>
              <span class="p">(</span><span class="nv">bfs</span> <span class="nv">end</span>
                   <span class="p">(</span><span class="nb">append</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">queue</span><span class="p">)</span>
                           <span class="p">(</span><span class="nv">new-paths</span> <span class="nv">path</span> <span class="nv">node</span> <span class="nv">net</span><span class="p">))</span>
                   <span class="nv">net</span><span class="p">))))))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">new-paths</span> <span class="p">(</span><span class="nv">path</span> <span class="nv">node</span> <span class="nv">net</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">mapcar</span> <span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">n</span><span class="p">)</span>
              <span class="p">(</span><span class="nb">cons</span> <span class="nv">n</span> <span class="nv">path</span><span class="p">))</span>
          <span class="p">(</span><span class="nb">cdr</span> <span class="p">(</span><span class="nb">assoc</span> <span class="nv">node</span> <span class="nv">net</span><span class="p">))))</span>
</pre>
                                </div>
                              </div>
                              <p>图 3.12 广度优先搜索(breadth-first search)</p>
                              <div class="figure">
                                <img alt="_images/Figure-3.13.png" src="_images/Figure-3.13.png" />
                              </div>
                              <p>图 3.13 最小网络</p>
                              <p>要找到从节点 <code class="docutils literal"><span class="pre">a</span></code> 可以到达的节点，我们可以：
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">cdr</span> <span class="p">(</span><span class="nb">assoc</span> <span class="ss">&#39;a</span> <span class="nb">min</span><span class="p">))</span>
<span class="p">(</span><span class="nv">B</span> <span class="nv">C</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>图 3.12
                                程序使用广度优先的方式搜索网络。要使用广度优先搜索，你需要维护一个含有未探索节点的队列。每一次你到达一个节点，检查这个节点是否是你要的。如果不是，你把这个节点的子节点加入队列的尾端，并从队列起始选一个节点，从这继续搜索。借由总是把较深的节点放在队列尾端，我们确保网络一次被搜索一层。
                              </p>
                              <p>图 3.12 中的代码较不复杂地表示这个概念。我们不仅想要找到节点，还想保有我们怎么到那的纪录。所以与其维护一个具有节点的队列
                                (queue)，我们维护一个已知路径的队列，每个已知路径都是一列节点。当我们从队列取出一个元素继续搜索时，它是一个含有队列前端节点的列表，而不只是一个节点而已。</p>
                              <p>函数 <code class="docutils literal"><span class="pre">bfs</span></code>
                                负责搜索。起初队列只有一个元素，一个表示从起点开始的路径。所以 <code
                                  class="docutils literal"><span class="pre">shortest-path</span></code> 调用 <code
                                  class="docutils literal"><span class="pre">bfs</span></code> ，并传入 <code
                                  class="docutils literal"><span class="pre">(list</span> <span class="pre">(list</span> <span class="pre">start))</span></code>
                                作为初始队列。</p>
                              <p><code class="docutils literal"><span class="pre">bfs</span></code>
                                函数第一件要考虑的事是，是否还有节点需要探索。如果队列为空， <code
                                  class="docutils literal"><span class="pre">bfs</span></code> 返回 <code
                                  class="docutils literal"><span class="pre">nil</span></code> 指出没有找到路径。如果还有节点需要搜索，
                                <code class="docutils literal"><span class="pre">bfs</span></code> 检查队列前端的节点。如果节点的 <code
                                  class="docutils literal"><span class="pre">car</span></code>
                                部分是我们要找的节点，我们返回这个找到的路径，并且为了可读性的原因我们反转它。如果我们没有找到我们要找的节点，它有可能在现在节点之后，所以我们把它的子节点（或是每一个子路径）加入队列尾端。然后我们递回地调用
                                <code class="docutils literal"><span class="pre">bfs</span></code> 来继续搜寻剩下的队列。
                              </p>
                              <p>因为 <code class="docutils literal"><span class="pre">bfs</span></code>
                                广度优先地搜索，第一个找到的路径会是最短的，或是最短之一：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">shortest-path</span> <span class="ss">&#39;a</span> <span class="ss">&#39;d</span> <span class="nb">min</span><span class="p">)</span>
<span class="p">(</span><span class="nv">A</span> <span class="nv">C</span> <span class="nv">D</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>这是队列在我们连续调用 <code class="docutils literal"><span class="pre">bfs</span></code> 看起来的样子：
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">((</span><span class="nv">A</span><span class="p">))</span>
<span class="p">((</span><span class="nv">B</span> <span class="nv">A</span><span class="p">)</span> <span class="p">(</span><span class="nv">C</span> <span class="nv">A</span><span class="p">))</span>
<span class="p">((</span><span class="nv">C</span> <span class="nv">A</span><span class="p">)</span> <span class="p">(</span><span class="nv">C</span> <span class="nv">B</span> <span class="nv">A</span><span class="p">))</span>
<span class="p">((</span><span class="nv">C</span> <span class="nv">B</span> <span class="nv">A</span><span class="p">)</span> <span class="p">(</span><span class="nv">D</span> <span class="nv">C</span> <span class="nv">A</span><span class="p">))</span>
<span class="p">((</span><span class="nv">D</span> <span class="nv">C</span> <span class="nv">A</span><span class="p">)</span> <span class="p">(</span><span class="nv">D</span> <span class="nv">C</span> <span class="nv">B</span> <span class="nv">A</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p>在队列中的第二个元素变成下一个队列的第一个元素。队列的第一个元素变成下一个队列尾端元素的 <code
                                  class="docutils literal"><span class="pre">cdr</span></code> 部分。</p>
                              <p>在图 3.12
                                的代码不是搜索一个网络最快的方法，但它给出了列表具有多功能的概念。在这个简单的程序中，我们用三种不同的方式使用了列表：我们使用一个符号的列表来表示路径，一个路径的列表来表示在广度优先搜索中的队列
                                <a class="footnote-reference" href="#id6" id="id3">[4]</a> ，以及一个关联列表来表示网络本身。
                              </p>
                            </div>
                            <div class="section" id="garbages">
                              <h4>3.16 垃圾 (Garbages)<a class="headerlink" href="#garbages"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>有很多原因可以使列表变慢。列表提供了顺序存取而不是随机存取，所以列表取出一个指定的元素比数组慢，同样的原因，录音带取出某些东西比在光盘上慢。电脑内部里，
                                <em>Cons</em> 对象倾向于用指针表示，所以走访一个列表意味着走访一系列的指针，而不是简单地像数组一样增加索引值。但这两个所花的代价与配置及回收
                                <em>Cons</em> 核 (cons cells)比起来小多了。
                              </p>
                              <p><em>自动内存管理</em>(<em>Automatic memory management</em>)是 Lisp 最有价值的特色之一。 Lisp
                                系统维护着一段內存称之为堆(<em>Heap</em>)。系统持续追踪堆当中没有使用的内存，把这些内存发放给新产生的对象。举例来说，函数 <code
                                  class="docutils literal"><span class="pre">cons</span></code> ，返回一个新配置的 <em>Cons</em>
                                对象。从堆中配置内存有时候通称为 <em>consing</em> 。</p>
                              <p>如果内存永远没有释放， Lisp 会因为创建新对象把内存用完，而必须要关闭。所以系统必须周期性地通过搜索堆 (heap)，寻找不需要再使用的内存。不需要再使用的内存称之为垃圾
                                (<em>garbage</em>)，而清除垃圾的动作称为垃圾回收 (<em>garbage collection</em>或 GC)。</p>
                              <p>垃圾是从哪来的？让我们来创造一些垃圾：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">setf</span> <span class="nv">lst</span> <span class="p">(</span><span class="nb">list</span> <span class="ss">&#39;a</span> <span class="ss">&#39;b</span> <span class="ss">&#39;c</span><span class="p">))</span>
<span class="p">(</span><span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span><span class="p">)</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="nb">setf</span> <span class="nv">lst</span> <span class="no">nil</span><span class="p">)</span>
<span class="no">NIL</span>
</pre>
                                </div>
                              </div>
                              <p>一开始我们调用 <code class="docutils literal"><span class="pre">list</span></code> ， <code
                                  class="docutils literal"><span class="pre">list</span></code> 调用 <code
                                  class="docutils literal"><span class="pre">cons</span></code> ，在堆上配置了一个新的
                                <em>Cons</em> 对象。在这个情况我们创出三个 <em>Cons</em> 对象。之后当我们把 <code
                                  class="docutils literal"><span class="pre">lst</span></code> 设为 <code
                                  class="docutils literal"><span class="pre">nil</span></code> ，我们没有任何方法可以再存取 <code
                                  class="docutils literal"><span class="pre">lst</span></code> ，列表 <code
                                  class="docutils literal"><span class="pre">(a</span> <span class="pre">b</span> <span class="pre">c)</span></code>
                                。 <a class="footnote-reference" href="#id7" id="id4">[5]</a>
                              </p>
                              <p>因为我们没有任何方法再存取列表，它也有可能是不存在的。我们不再有任何方式可以存取的对象叫做垃圾。系统可以安全地重新使用这三个 <em>Cons</em> 核。</p>
                              <p>这种管理內存的方法，给程序員带来极大的便利性。你不用显式地配置 (allocate)或释放
                                (dellocate)內存。这也表示了你不需要处理因为这么做而可能产生的臭虫。內存泄漏 (Memory leaks)以及迷途指针 (dangling pointer)在
                                Lisp 中根本不可能发生。</p>
                              <p>但是像任何的科技进步，如果你不小心的话，自动內存管理也有可能对你不利。使用及回收堆所带来的代价有时可以看做 <code
                                  class="docutils literal"><span class="pre">cons</span></code>
                                的代价。这是有理的，除非一个程序从来不丢弃任何东西，不然所有的 <em>Cons</em> 对象终究要变成垃圾。 Consing
                                的问题是，配置空间与清除內存，与程序的常规运作比起来花费昂贵。近期的研究提出了大幅改善內存回收的演算法，但是 consing 总是需要代价的，在某些现有的 Lisp
                                系统中，代价是昂贵的。</p>
                              <p>除非你很小心，不然很容易写出过度显式创建 cons 对象的程序。举例来说， <code
                                  class="docutils literal"><span class="pre">remove</span></code> 需要复制所有的 <code
                                  class="docutils literal"><span class="pre">cons</span></code>
                                核，直到最后一个元素从列表中移除。你可以借由使用破坏性的函数避免某些 consing，它试着去重用列表的结构作为参数传给它们。破坏性函数会在 12.4 节讨论。</p>
                              <p>当写出 <code class="docutils literal"><span class="pre">cons</span></code>
                                很多的程序是如此简单时，我们还是可以写出不使用 <code
                                  class="docutils literal"><span class="pre">cons</span></code>
                                的程序。典型的方法是写出一个纯函数风格，使用很多列表的第一版程序。当程序进化时，你可以在代码的关键部分使用破坏性函数以及/或别种数据结构。但这很难给出通用的建议，因为有些
                                Lisp 实现，內存管理处理得相当好，以致于使用 <code
                                  class="docutils literal"><span class="pre">cons</span></code> 有时比不使用 <code
                                  class="docutils literal"><span class="pre">cons</span></code> 还快。这整个议题在 13.4
                                做更进一步的细部讨论。</p>
                              <p>无论如何 consing 在原型跟实验时是好的。而且如果你利用了列表给你带来的灵活性，你有较高的可能写出后期可存活下来的程序。</p>
                            </div>
                            <div class="section" id="chapter-3-summary">
                              <h4>Chapter 3 总结 (Summary)<a class="headerlink" href="#chapter-3-summary"
                                  title="Permalink to this headline">¶</a></h4>
                              <ol class="arabic simple">
                                <li>一个 <em>Cons</em> 是一个含两部分的数据结构。列表用链结在一起的 <em>Cons</em> 组成。</li>
                                <li>判断式 <code class="docutils literal"><span class="pre">equal</span></code> 比 <code
                                    class="docutils literal"><span class="pre">eql</span></code>
                                  来得不严谨。基本上，如果传入参数印出来的值一样时，返回真。</li>
                                <li>所有 Lisp 对象表现得像指针。你永远不需要显式操作指针。</li>
                                <li>你可以使用 <code class="docutils literal"><span class="pre">copy-list</span></code>
                                  复制列表，并使用 <code class="docutils literal"><span class="pre">append</span></code>
                                  来连接它们的元素。</li>
                                <li>游程编码是一个餐厅中使用的简单压缩演算法。</li>
                                <li>Common Lisp 有由 <code class="docutils literal"><span class="pre">car</span></code> 与
                                  <code class="docutils literal"><span class="pre">cdr</span></code> 定义的多种存取函数。
                                </li>
                                <li>映射函数将函数应用至逐项的元素，或逐项的列表尾端。</li>
                                <li>嵌套列表的操作有时被考虑为树的操作。</li>
                                <li>要判断一个递归函数是否正确，你只需要考虑是否包含了所有情况。</li>
                                <li>列表可以用来表示集合。数个内置函数把列表当作集合。</li>
                                <li>关键字参数是选择性的，并不是由位置所识别，是用符号前面的特殊标签来识别。</li>
                                <li>列表是序列的子类型。 Common Lisp 有大量的序列函数。</li>
                                <li>一个不是正规列表的 <em>Cons</em> 称之为点状列表。</li>
                                <li>用 cons 对象作为元素的列表，可以拿来表示对应关系。这样的列表称为关联列表(assoc-lists)。</li>
                                <li>自动内存管理拯救你处理内存配置的烦恼，但制造过多的垃圾会使程序变慢。</li>
                              </ol>
                            </div>
                            <div class="section" id="chapter-3-exercises">
                              <h4>Chapter 3 习题 (Exercises)<a class="headerlink" href="#chapter-3-exercises"
                                  title="Permalink to this headline">¶</a></h4>
                              <ol class="arabic simple">
                                <li>用箱子表示法表示以下列表：</li>
                              </ol>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nv">a</span><span class="p">)</span> <span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="p">(</span><span class="nv">c</span> <span class="nv">d</span><span class="p">))</span>
<span class="p">(</span><span class="nv">b</span><span class="p">)</span> <span class="p">(</span><span class="nv">a</span> <span class="p">(</span><span class="nv">b</span> <span class="p">(</span><span class="nv">c</span> <span class="p">(</span><span class="nv">d</span><span class="p">))))</span>
<span class="p">(</span><span class="nv">c</span><span class="p">)</span> <span class="p">(((</span><span class="nv">a</span> <span class="nv">b</span><span class="p">)</span> <span class="nv">c</span><span class="p">)</span> <span class="nv">d</span><span class="p">)</span>
<span class="p">(</span><span class="nv">d</span><span class="p">)</span> <span class="p">(</span><span class="nv">a</span> <span class="p">(</span><span class="nv">b</span> <span class="o">.</span> <span class="nv">c</span><span class="p">)</span> <span class="nv">d</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <ol class="arabic simple" start="2">
                                <li>写一个保留原本列表中元素顺序的 <code class="docutils literal"><span class="pre">union</span></code>
                                  版本：</li>
                              </ol>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">new-union</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">b</span> <span class="nv">a</span> <span class="nv">d</span><span class="p">))</span>
<span class="p">(</span><span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="nv">D</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <ol class="arabic simple" start="3">
                                <li>定义一个函数，接受一个列表并返回一个列表，指出相等元素出现的次数，并由最常见至最少见的排序：</li>
                              </ol>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">occurrences</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">a</span> <span class="nv">d</span> <span class="nv">a</span> <span class="nv">c</span> <span class="nv">d</span> <span class="nv">c</span> <span class="nv">a</span><span class="p">))</span>
<span class="p">((</span><span class="nv">A</span> <span class="o">.</span> <span class="mi">4</span><span class="p">)</span> <span class="p">(</span><span class="nv">C</span> <span class="o">.</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="nv">D</span> <span class="o">.</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="nv">B</span> <span class="o">.</span> <span class="mi">1</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <ol class="arabic simple" start="4">
                                <li>为什么 <code
                                    class="docutils literal"><span class="pre">(member</span> <span class="pre">'(a)</span> <span class="pre">'((a)</span> <span class="pre">(b)))</span></code>
                                  返回 nil？</li>
                                <li>假设函数 <code class="docutils literal"><span class="pre">pos+</span></code>
                                  接受一个列表并返回把每个元素加上自己的位置的列表：</li>
                              </ol>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">pos+</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">7</span> <span class="mi">5</span> <span class="mi">1</span> <span class="mi">4</span><span class="p">))</span>
<span class="p">(</span><span class="mi">7</span> <span class="mi">6</span> <span class="mi">3</span> <span class="mi">7</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>使用 (a) 递归 (b) 迭代 (c) <code
                                  class="docutils literal"><span class="pre">mapcar</span></code> 来定义这个函数。</p>
                              <ol class="arabic simple" start="6">
                                <li>经过好几年的审议，政府委员会决定列表应该由 <code
                                    class="docutils literal"><span class="pre">cdr</span></code> 指向第一个元素，而 <code
                                    class="docutils literal"><span class="pre">car</span></code> 指向剩下的列表。定义符合政府版本的以下函数：
                                </li>
                              </ol>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nv">a</span><span class="p">)</span> <span class="nb">cons</span>
<span class="p">(</span><span class="nv">b</span><span class="p">)</span> <span class="nb">list</span>
<span class="p">(</span><span class="nv">c</span><span class="p">)</span> <span class="nb">length</span> <span class="p">(</span><span class="nv">for</span> <span class="nv">lists</span><span class="p">)</span>
<span class="p">(</span><span class="nv">d</span><span class="p">)</span> <span class="nb">member</span> <span class="p">(</span><span class="nv">for</span> <span class="nv">lists</span><span class="c1">; no keywords)</span>
</pre>
                                </div>
                              </div>
                              <p><strong>勘误:</strong> 要解决 3.6 (b)，你需要使用到 6.3 节的参数 <code
                                  class="docutils literal"><span class="pre">&amp;rest</span></code> 。</p>
                              <ol class="arabic simple" start="7">
                                <li>修改图 3.6 的程序，使它使用更少 cons 核。 （提示：使用点状列表）</li>
                                <li>定义一个函数，接受一个列表并用点状表示法印出：</li>
                              </ol>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">showdots</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">))</span>
<span class="p">(</span><span class="nv">A</span> <span class="o">.</span> <span class="p">(</span><span class="nv">B</span> <span class="o">.</span> <span class="p">(</span><span class="nv">C</span> <span class="o">.</span> <span class="no">NIL</span><span class="p">)))</span>
<span class="no">NIL</span>
</pre>
                                </div>
                              </div>
                              <ol class="arabic simple" start="9">
                                <li>写一个程序来找到 3.15 节里表示的网络中，最长有限的路径 (不重复)。网络可能包含循环。</li>
                              </ol>
                              <p class="rubric">脚注</p>
                              <table class="docutils footnote" frame="void" id="id5" rules="none">
                                <colgroup>
                                  <col class="label" />
                                  <col />
                                </colgroup>
                                <tbody valign="top">
                                  <tr>
                                    <td class="label"><a class="fn-backref" href="#id2">[3]</a></td>
                                    <td>这个叙述有点误导，因为只要是对任何东西都不返回 nil 的函数，都不是正规列表。如果给定一个环状 cdr 列表(cdr-circular
                                      list)，它会无法终止。环状列表在 12.7 节 讨论。</td>
                                  </tr>
                                </tbody>
                              </table>
                              <table class="docutils footnote" frame="void" id="id6" rules="none">
                                <colgroup>
                                  <col class="label" />
                                  <col />
                                </colgroup>
                                <tbody valign="top">
                                  <tr>
                                    <td class="label"><a class="fn-backref" href="#id3">[4]</a></td>
                                    <td>12.3 小节会展示更有效率的队列实现方式。</td>
                                  </tr>
                                </tbody>
                              </table>
                              <table class="docutils footnote" frame="void" id="id7" rules="none">
                                <colgroup>
                                  <col class="label" />
                                  <col />
                                </colgroup>
                                <tbody valign="top">
                                  <tr>
                                    <td class="label"><a class="fn-backref" href="#id4">[5]</a></td>
                                    <td>事实上，我们有一种方式来存取列表。全局变量 <code
                                        class="docutils literal"><span class="pre">*</span></code> , <code
                                        class="docutils literal"><span class="pre">**</span></code> , 以及 <code
                                        class="docutils literal"><span class="pre">***</span></code>
                                      总是设定为最后三个顶层所返回的值。这些变量在除错的时候很有用。</td>
                                  </tr>
                                </tbody>
                              </table>
                            </div>
                          </div>
                          <div class="section">
                            <h3 id="4">第四章：特殊数据结构
                            </h3>
                            <p>在之前的章节里，我们讨论了列表，Lisp 最多功能的数据结构。本章将演示如何使用 Lisp
                              其它的数据结构：数组（包含向量与字符串），结构以及哈希表。它们或许不像列表这么灵活，但存取速度更快并使用了更少空间。</p>
                            <p>Common Lisp 还有另一种数据结构：实例（instance）。实例将在 11 章讨论，讲述 CLOS。</p>
                            <div class="section" id="array">
                              <h4>4.1 数组 (Array)<a class="headerlink" href="#array"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>在 Common Lisp 里，你可以调用 <code
                                  class="docutils literal"><span class="pre">make-array</span></code>
                                来构造一个数组，第一个实参为一个指定数组维度的列表。要构造一个 <code
                                  class="docutils literal"><span class="pre">2</span> <span class="pre">x</span> <span class="pre">3</span></code>
                                的数组，我们可以：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre>&gt; (setf arr (make-array &#39;(2 3) :initial-element nil))
#&lt;Simple-Array T (2 3) BFC4FE&gt;
</pre>
                                </div>
                              </div>
                              <p>Common Lisp 的数组至少可以达到七个维度，每个维度至少可以容纳 1023 个元素。</p>
                              <p><code class="docutils literal"><span class="pre">:initial-element</span></code>
                                实参是选择性的。如果有提供这个实参，整个数组会用这个值作为初始值。若试著取出未初始化的数组内的元素，其结果为未定义（undefined）。</p>
                              <p>用 <code class="docutils literal"><span class="pre">aref</span></code> 取出数组内的元素。与 Common
                                Lisp 的存取函数一样， <code class="docutils literal"><span class="pre">aref</span></code>
                                是零索引的（zero-indexed）：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">aref</span> <span class="nv">arr</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">)</span>
<span class="no">NIL</span>
</pre>
                                </div>
                              </div>
                              <p>要替换数组的某个元素，我们使用 <code class="docutils literal"><span class="pre">setf</span></code> 与
                                <code class="docutils literal"><span class="pre">aref</span></code> ：
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nb">aref</span> <span class="nv">arr</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">)</span> <span class="ss">&#39;b</span><span class="p">)</span>
<span class="nv">B</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="nb">aref</span> <span class="nv">arr</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">)</span>
<span class="nv">B</span>
</pre>
                                </div>
                              </div>
                              <p>要表示字面常量的数组（literal array），使用 <code
                                  class="docutils literal"><span class="pre">#na</span></code> 语法，其中 <code
                                  class="docutils literal"><span class="pre">n</span></code> 是数组的维度。举例来说，我们可以这样表示 <code
                                  class="docutils literal"><span class="pre">arr</span></code> 这个数组：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="l-Other">#2a</span><span class="p">((</span><span class="nv">b</span> <span class="no">nil</span> <span class="no">nil</span><span class="p">)</span> <span class="p">(</span><span class="no">nil</span> <span class="no">nil</span> <span class="no">nil</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p>如果全局变量 <code class="docutils literal"><span class="pre">*print-array*</span></code>
                                为真，则数组会用以下形式来显示：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">setf</span> <span class="vg">*print-array*</span> <span class="no">t</span><span class="p">)</span>
<span class="no">T</span>
<span class="nb">&gt;</span> <span class="nv">arr</span>
<span class="l-Other">#2A</span><span class="p">((</span><span class="nv">B</span> <span class="no">NIL</span> <span class="no">NIL</span><span class="p">)</span> <span class="p">(</span><span class="no">NIL</span> <span class="no">NIL</span> <span class="no">NIL</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p>如果我们只想要一维的数组，你可以给 <code
                                  class="docutils literal"><span class="pre">make-array</span></code>
                                第一个实参传一个整数，而不是一个列表：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">setf</span> <span class="nv">vec</span> <span class="p">(</span><span class="nb">make-array</span> <span class="mi">4</span> <span class="ss">:initial-element</span> <span class="no">nil</span><span class="p">))</span>
<span class="o">#(</span><span class="no">NIL</span> <span class="no">NIL</span> <span class="no">NIL</span> <span class="no">NIL</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>一维数组又称为向量（<em>vector</em>）。你可以通过调用 <code
                                  class="docutils literal"><span class="pre">vector</span></code>
                                来一步骤构造及填满向量，向量的元素可以是任何类型：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">vector</span> <span class="s">&quot;a&quot;</span> <span class="ss">&#39;b</span> <span class="mi">3</span><span class="p">)</span>
<span class="o">#(</span><span class="s">&quot;a&quot;</span> <span class="nv">b</span> <span class="mi">3</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>字面常量的数组可以表示成 <code class="docutils literal"><span class="pre">#na</span></code>
                                ，字面常量的向量也可以用这种语法表达。</p>
                              <p>可以用 <code class="docutils literal"><span class="pre">aref</span></code>
                                来存取向量，但有一个更快的函数叫做 <code class="docutils literal"><span class="pre">svref</span></code>
                                ，专门用来存取向量。</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">svref</span> <span class="nv">vec</span> <span class="mi">0</span><span class="p">)</span>
<span class="no">NIL</span>
</pre>
                                </div>
                              </div>
                              <p>在 <code class="docutils literal"><span class="pre">svref</span></code> 内的 “sv”
                                代表“简单向量”（“simple vector”），所有的向量缺省是简单向量。 <a class="footnote-reference" href="#id5"
                                  id="id2">[1]</a></p>
                            </div>
                            <div class="section" id="example-binary-search">
                              <h4>4.2 示例：二叉搜索 (Example: Binary Search)<a class="headerlink"
                                  href="#example-binary-search" title="Permalink to this headline">¶</a></h4>
                              <p>作为一个示例，这小节演示如何写一个在排序好的向量里搜索对象的函数。如果我们知道一个向量是排序好的，我们可以比（65页） <code
                                  class="docutils literal"><span class="pre">find</span></code> 做的更好， <code
                                  class="docutils literal"><span class="pre">find</span></code>
                                必须依序检查每一个元素。我们可以直接跳到向量中间开始找。如果中间的元素是我们要找的对象，搜索完毕。要不然我们持续往左半部或往右半部搜索，取决于对象是小于或大于中间的元素。
                              </p>
                              <p>图 4.1 包含了一个这么工作的函数。其实这两个函数： <code
                                  class="docutils literal"><span class="pre">bin-search</span></code> 设置初始范围及发送控制信号给
                                <code class="docutils literal"><span class="pre">finder</span></code> ， <code
                                  class="docutils literal"><span class="pre">finder</span></code> 寻找向量 <code
                                  class="docutils literal"><span class="pre">vec</span></code> 内 <code
                                  class="docutils literal"><span class="pre">obj</span></code> 是否介于 <code
                                  class="docutils literal"><span class="pre">start</span></code> 及 <code
                                  class="docutils literal"><span class="pre">end</span></code> 之间。
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">bin-search</span> <span class="p">(</span><span class="nv">obj</span> <span class="nv">vec</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">len</span> <span class="p">(</span><span class="nb">length</span> <span class="nv">vec</span><span class="p">)))</span>
    <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nb">not</span> <span class="p">(</span><span class="nb">zerop</span> <span class="nv">len</span><span class="p">))</span>
         <span class="p">(</span><span class="nv">finder</span> <span class="nv">obj</span> <span class="nv">vec</span> <span class="mi">0</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">len</span> <span class="mi">1</span><span class="p">)))))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">finder</span> <span class="p">(</span><span class="nv">obj</span> <span class="nv">vec</span> <span class="nv">start</span> <span class="nv">end</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">range</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">end</span> <span class="nv">start</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">zerop</span> <span class="nv">range</span><span class="p">)</span>
        <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">eql</span> <span class="nv">obj</span> <span class="p">(</span><span class="nb">aref</span> <span class="nv">vec</span> <span class="nv">start</span><span class="p">))</span>
            <span class="nv">obj</span>
            <span class="no">nil</span><span class="p">)</span>
        <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">mid</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">start</span> <span class="p">(</span><span class="nb">round</span> <span class="p">(</span><span class="nb">/</span> <span class="nv">range</span> <span class="mi">2</span><span class="p">)))))</span>
          <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">obj2</span> <span class="p">(</span><span class="nb">aref</span> <span class="nv">vec</span> <span class="nv">mid</span><span class="p">)))</span>
            <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">&lt;</span> <span class="nv">obj</span> <span class="nv">obj2</span><span class="p">)</span>
                <span class="p">(</span><span class="nv">finder</span> <span class="nv">obj</span> <span class="nv">vec</span> <span class="nv">start</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">mid</span> <span class="mi">1</span><span class="p">))</span>
                <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">&gt;</span> <span class="nv">obj</span> <span class="nv">obj2</span><span class="p">)</span>
                    <span class="p">(</span><span class="nv">finder</span> <span class="nv">obj</span> <span class="nv">vec</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">mid</span> <span class="mi">1</span><span class="p">)</span> <span class="nv">end</span><span class="p">)</span>
                    <span class="nv">obj</span><span class="p">)))))))</span>
</pre>
                                </div>
                              </div>
                              <p>图 4.1: 搜索一个排序好的向量</p>
                              <p>如果要找的 <code class="docutils literal"><span class="pre">range</span></code>
                                缩小至一个元素，而如果这个元素是 <code class="docutils literal"><span class="pre">obj</span></code> 的话，则
                                <code class="docutils literal"><span class="pre">finder</span></code> 直接返回这个元素，反之返回
                                <code class="docutils literal"><span class="pre">nil</span></code> 。如果 <code
                                  class="docutils literal"><span class="pre">range</span></code> 大于 <code
                                  class="docutils literal"><span class="pre">1</span></code> ，我们設置 <code
                                  class="docutils literal"><span class="pre">middle</span></code> ( <code
                                  class="docutils literal"><span class="pre">round</span></code> 返回离实参最近的整数) 為 <code
                                  class="docutils literal"><span class="pre">obj2</span></code> 。如果 <code
                                  class="docutils literal"><span class="pre">obj</span></code> 小于 <code
                                  class="docutils literal"><span class="pre">obj2</span></code> ，则递归地往向量的左半部寻找。如果 <code
                                  class="docutils literal"><span class="pre">obj</span></code> 大于 <code
                                  class="docutils literal"><span class="pre">obj2</span></code> ，则递归地往向量的右半部寻找。剩下的一个选择是
                                <code class="docutils literal"><span class="pre">obj=obj2</span></code>
                                ，在这个情况我们找到要找的元素，直接返回这个元素。
                              </p>
                              <p>如果我们插入下面这行至 <code class="docutils literal"><span class="pre">finder</span></code> 的起始处：
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;~A~%&quot;</span> <span class="p">(</span><span class="nb">subseq</span> <span class="nv">vec</span> <span class="nv">start</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">end</span> <span class="mi">1</span><span class="p">)))</span>
</pre>
                                </div>
                              </div>
                              <p>我们可以观察被搜索的元素的数量，是每一步往左减半的：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">bin-search</span> <span class="mi">3</span> <span class="o">#(</span><span class="mi">0</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span><span class="p">))</span>
<span class="o">#(</span><span class="mi">0</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span><span class="p">)</span>
<span class="o">#(</span><span class="mi">0</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span>
<span class="o">#(</span><span class="mi">3</span><span class="p">)</span>
<span class="mi">3</span>
</pre>
                                </div>
                              </div>
                            </div>
                            <div class="section" id="strings-and-characters">
                              <h4>4.3 字符与字符串 (Strings and Characters)<a class="headerlink"
                                  href="#strings-and-characters" title="Permalink to this headline">¶</a></h4>
                              <p>字符串是字符组成的向量。我们用一系列由双引号包住的字符，来表示一个字符串常量，而字符 <code
                                  class="docutils literal"><span class="pre">c</span></code> 用 <code
                                  class="docutils literal"><span class="pre">#\c</span></code> 表示。</p>
                              <p>每个字符都有一个相关的整数 ── 通常是 ASCII 码，但不一定是。在多数的 Lisp 实现里，函数 <code
                                  class="docutils literal"><span class="pre">char-code</span></code> 返回与字符相关的数字，而 <code
                                  class="docutils literal"><span class="pre">code-char</span></code> 返回与数字相关的字符。</p>
                              <p>字符比较函数 <code class="docutils literal"><span class="pre">char&lt;</span></code> （小于），
                                <code class="docutils literal"><span class="pre">char&lt;=</span></code> （小于等于)， <code
                                  class="docutils literal"><span class="pre">char=</span></code> （等于)， <code
                                  class="docutils literal"><span class="pre">char&gt;=</span></code> （大于等于) ， <code
                                  class="docutils literal"><span class="pre">char&gt;</span></code> （大于)，以及 <code
                                  class="docutils literal"><span class="pre">char/=</span></code> （不同)。他们的工作方式和 146 页（译注
                                9.3 节)比较数字用的操作符一样。
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">sort</span> <span class="s">&quot;elbow&quot;</span> <span class="nf">#&#39;</span><span class="nb">char&lt;</span><span class="p">)</span>
<span class="s">&quot;below&quot;</span>
</pre>
                                </div>
                              </div>
                              <p>由于字符串是字符向量，序列与数组的函数都可以用在字符串。你可以用 <code
                                  class="docutils literal"><span class="pre">aref</span></code> 来取出元素，举例来说，</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">aref</span> <span class="s">&quot;abc&quot;</span> <span class="mi">1</span><span class="p">)</span>
<span class="sc">#\b</span>
</pre>
                                </div>
                              </div>
                              <p>但针对字符串可以使用更快的 <code class="docutils literal"><span class="pre">char</span></code> 函数：
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">char</span> <span class="s">&quot;abc&quot;</span> <span class="mi">1</span><span class="p">)</span>
<span class="sc">#\b</span>
</pre>
                                </div>
                              </div>
                              <p>可以使用 <code class="docutils literal"><span class="pre">setf</span></code> 搭配 <code
                                  class="docutils literal"><span class="pre">char</span></code> （或 <code
                                  class="docutils literal"><span class="pre">aref</span></code> ）来替换字符串的元素：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">str</span> <span class="p">(</span><span class="nb">copy-seq</span> <span class="s">&quot;Merlin&quot;</span><span class="p">)))</span>
   <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nb">char</span> <span class="nv">str</span> <span class="mi">3</span><span class="p">)</span> <span class="sc">#\k</span><span class="p">)</span>
   <span class="nv">str</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>如果你想要比较两个字符串，你可以使用通用的 <code
                                  class="docutils literal"><span class="pre">equal</span></code> 函数，但还有一个比较函数，是忽略字母大小写的
                                <code class="docutils literal"><span class="pre">string-equal</span></code> ：
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">equal</span> <span class="s">&quot;fred&quot;</span> <span class="s">&quot;fred&quot;</span><span class="p">)</span>
<span class="no">T</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="nb">equal</span> <span class="s">&quot;fred&quot;</span> <span class="s">&quot;Fred&quot;</span><span class="p">)</span>
<span class="no">NIL</span>
<span class="nb">&gt;</span><span class="p">(</span><span class="nb">string-equal</span> <span class="s">&quot;fred&quot;</span> <span class="s">&quot;Fred&quot;</span><span class="p">)</span>
<span class="no">T</span>
</pre>
                                </div>
                              </div>
                              <p>Common Lisp 提供大量的操控、比较字符串的函数。收录在附录 D，从 364 页开始。</p>
                              <p>有许多方式可以创建字符串。最普遍的方式是使用 <code
                                  class="docutils literal"><span class="pre">format</span></code> 。将第一个参数设为 <code
                                  class="docutils literal"><span class="pre">nil</span></code> 来调用 <code
                                  class="docutils literal"><span class="pre">format</span></code> ，使它返回一个原本会印出来的字符串：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">format</span> <span class="no">nil</span> <span class="s">&quot;~A or ~A&quot;</span> <span class="s">&quot;truth&quot;</span> <span class="s">&quot;dare&quot;</span><span class="p">)</span>
<span class="s">&quot;truth or dare&quot;</span>
</pre>
                                </div>
                              </div>
                              <p>但若你只想把数个字符串连结起来，你可以使用 <code
                                  class="docutils literal"><span class="pre">concatenate</span></code>
                                ，它接受一个特定类型的符号，加上一个或多个序列：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">concatenate</span> <span class="ss">&#39;string</span> <span class="s">&quot;not &quot;</span> <span class="s">&quot;to worry&quot;</span><span class="p">)</span>
<span class="s">&quot;not to worry&quot;</span>
</pre>
                                </div>
                              </div>
                            </div>
                            <div class="section" id="sequences">
                              <h4>4.4 序列 (Sequences)<a class="headerlink" href="#sequences"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>在 Common Lisp 里，序列类型包含了列表与向量（因此也包含了字符串）。有些用在列表的函数，实际上是序列函数，包括 <code
                                  class="docutils literal"><span class="pre">remove</span></code> 、 <code
                                  class="docutils literal"><span class="pre">length</span></code> 、 <code
                                  class="docutils literal"><span class="pre">subseq</span></code> 、 <code
                                  class="docutils literal"><span class="pre">reverse</span></code> 、 <code
                                  class="docutils literal"><span class="pre">sort</span></code> 、 <code
                                  class="docutils literal"><span class="pre">every</span></code> 以及 <code
                                  class="docutils literal"><span class="pre">some</span></code> 。所以 46 页（译注 3.11 小节的
                                <code class="docutils literal"><span class="pre">mirror?</span></code>
                                函数）我们所写的函数，也可以用在其他种类的序列上：
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">mirror?</span> <span class="s">&quot;abba&quot;</span><span class="p">)</span>
<span class="no">T</span>
</pre>
                                </div>
                              </div>
                              <p>我们已经看过四种用来取出序列元素的函数： 给列表使用的 <code
                                  class="docutils literal"><span class="pre">nth</span></code> ， 给向量使用的 <code
                                  class="docutils literal"><span class="pre">aref</span></code> 及 <code
                                  class="docutils literal"><span class="pre">svref</span></code> ，以及给字符串使用的 <code
                                  class="docutils literal"><span class="pre">char</span></code> 。 Common Lisp 也提供了通用的
                                <code class="docutils literal"><span class="pre">elt</span></code> ，对任何种类的序列都有效：
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">elt</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">)</span> <span class="mi">1</span><span class="p">)</span>
<span class="nv">B</span>
</pre>
                                </div>
                              </div>
                              <p>针对特定类型的序列，特定的存取函数会比较快，所以使用 <code
                                  class="docutils literal"><span class="pre">elt</span></code>
                                是没有意义的，除非在代码当中，有需要支持通用序列的地方。</p>
                              <p>使用 <code class="docutils literal"><span class="pre">elt</span></code>
                                ，我们可以写一个针对向量来说更有效率的 <code
                                  class="docutils literal"><span class="pre">mirror?</span></code> 版本：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">mirror?</span> <span class="p">(</span><span class="nv">s</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">len</span> <span class="p">(</span><span class="nb">length</span> <span class="nv">s</span><span class="p">)))</span>
    <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nb">evenp</span> <span class="nv">len</span><span class="p">)</span>
         <span class="p">(</span><span class="nb">do</span> <span class="p">((</span><span class="nv">forward</span> <span class="mi">0</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">forward</span> <span class="mi">1</span><span class="p">))</span>
              <span class="p">(</span><span class="nv">back</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">len</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">back</span> <span class="mi">1</span><span class="p">)))</span>
             <span class="p">((</span><span class="nb">or</span> <span class="p">(</span><span class="nb">&gt;</span> <span class="nv">forward</span> <span class="nv">back</span><span class="p">)</span>
                  <span class="p">(</span><span class="nb">not</span> <span class="p">(</span><span class="nb">eql</span> <span class="p">(</span><span class="nb">elt</span> <span class="nv">s</span> <span class="nv">forward</span><span class="p">)</span>
                            <span class="p">(</span><span class="nb">elt</span> <span class="nv">s</span> <span class="nv">back</span><span class="p">))))</span>
              <span class="p">(</span><span class="nb">&gt;</span> <span class="nv">forward</span> <span class="nv">back</span><span class="p">))))))</span>
</pre>
                                </div>
                              </div>
                              <p>这个版本也可用在列表，但这个实现更适合给向量使用。频繁的对列表调用 <code
                                  class="docutils literal"><span class="pre">elt</span></code>
                                的代价是昂贵的，因为列表仅允许顺序存取。而向量允许随机存取，从任何元素来存取每一个元素都是廉价的。</p>
                              <p>许多序列函数接受一个或多个，由下表所列的标准关键字参数：</p>
                              <table border="1" class="docutils">
                                <colgroup>
                                  <col width="25%" />
                                  <col width="50%" />
                                  <col width="25%" />
                                </colgroup>
                                <thead valign="bottom">
                                  <tr class="row-odd">
                                    <th class="head">参数</th>
                                    <th class="head">用途</th>
                                    <th class="head">缺省值</th>
                                  </tr>
                                </thead>
                                <tbody valign="top">
                                  <tr class="row-even">
                                    <td>:key</td>
                                    <td>应用至每个元素的函数</td>
                                    <td>identity</td>
                                  </tr>
                                  <tr class="row-odd">
                                    <td>:test</td>
                                    <td>作来比较的函数</td>
                                    <td>eql</td>
                                  </tr>
                                  <tr class="row-even">
                                    <td>:from-end</td>
                                    <td>若为真，反向工作。</td>
                                    <td>nil</td>
                                  </tr>
                                  <tr class="row-odd">
                                    <td>:start</td>
                                    <td>起始位置</td>
                                    <td>0</td>
                                  </tr>
                                  <tr class="row-even">
                                    <td>:end</td>
                                    <td>若有给定，结束位置。</td>
                                    <td>nil</td>
                                  </tr>
                                </tbody>
                              </table>
                              <p>一个接受所有关键字参数的函数是 <code class="docutils literal"><span class="pre">position</span></code>
                                ，返回序列中一个元素的位置，未找到元素时则返回 <code
                                  class="docutils literal"><span class="pre">nil</span></code> 。我们使用 <code
                                  class="docutils literal"><span class="pre">position</span></code> 来演示关键字参数所扮演的角色。</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">position</span> <span class="sc">#\a</span> <span class="s">&quot;fantasia&quot;</span><span class="p">)</span>
<span class="mi">1</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="nb">position</span> <span class="sc">#\a</span> <span class="s">&quot;fantasia&quot;</span> <span class="ss">:start</span> <span class="mi">3</span> <span class="ss">:end</span> <span class="mi">5</span><span class="p">)</span>
<span class="mi">4</span>
</pre>
                                </div>
                              </div>
                              <p>第二个例子我们要找在第四个与第六个字符间，第一个 <code
                                  class="docutils literal"><span class="pre">a</span></code> 所出现的位置。 <code
                                  class="docutils literal"><span class="pre">:start</span></code>
                                关键字参数是第一个被考虑的元素位置，缺省是序列的第一个元素。 <code
                                  class="docutils literal"><span class="pre">:end</span></code>
                                关键字参数，如果有给的话，是第一个不被考虑的元素位置。</p>
                              <p>如果我们给入 <code class="docutils literal"><span class="pre">:from-end</span></code> 关键字参数，
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">position</span> <span class="sc">#\a</span> <span class="s">&quot;fantasia&quot;</span> <span class="ss">:from-end</span> <span class="no">t</span><span class="p">)</span>
<span class="mi">7</span>
</pre>
                                </div>
                              </div>
                              <p>我们得到最靠近结尾的 <code class="docutils literal"><span class="pre">a</span></code>
                                的位置。但位置是像平常那样计算；而不是从尾端算回来的距离。</p>
                              <p><code class="docutils literal"><span class="pre">:key</span></code>
                                关键字参数是序列中每个元素在被考虑之前，应用至元素上的函数。如果我们说，</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">position</span> <span class="ss">&#39;a</span> <span class="o">&#39;</span><span class="p">((</span><span class="nv">c</span> <span class="nv">d</span><span class="p">)</span> <span class="p">(</span><span class="nv">a</span> <span class="nv">b</span><span class="p">))</span> <span class="ss">:key</span> <span class="nf">#&#39;</span><span class="nb">car</span><span class="p">)</span>
<span class="mi">1</span>
</pre>
                                </div>
                              </div>
                              <p>那么我们要找的是，元素的 <code class="docutils literal"><span class="pre">car</span></code> 部分是符号
                                <code class="docutils literal"><span class="pre">a</span></code> 的第一个元素。
                              </p>
                              <p><code class="docutils literal"><span class="pre">:test</span></code>
                                关键字参数接受需要两个实参的函数，并定义了怎样是一个成功的匹配。缺省函数为 <code
                                  class="docutils literal"><span class="pre">eql</span></code> 。如果你想要匹配一个列表，你也许想使用 <code
                                  class="docutils literal"><span class="pre">equal</span></code> 来取代：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">position</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">((</span><span class="nv">a</span> <span class="nv">b</span><span class="p">)</span> <span class="p">(</span><span class="nv">c</span> <span class="nv">d</span><span class="p">)))</span>
<span class="no">NIL</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="nb">position</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">((</span><span class="nv">a</span> <span class="nv">b</span><span class="p">)</span> <span class="p">(</span><span class="nv">c</span> <span class="nv">d</span><span class="p">))</span> <span class="ss">:test</span> <span class="nf">#&#39;</span><span class="nb">equal</span><span class="p">)</span>
<span class="mi">0</span>
</pre>
                                </div>
                              </div>
                              <p><code class="docutils literal"><span class="pre">:test</span></code>
                                关键字参数可以是任何接受两个实参的函数。举例来说，给定 <code
                                  class="docutils literal"><span class="pre">&lt;</span></code>
                                ，我们可以询问第一个使第一个参数比它小的元素位置：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">position</span> <span class="mi">3</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">0</span> <span class="mi">7</span> <span class="mi">5</span><span class="p">)</span> <span class="ss">:test</span> <span class="nf">#&#39;</span><span class="nb">&lt;</span><span class="p">)</span>
<span class="mi">2</span>
</pre>
                                </div>
                              </div>
                              <p>使用 <code class="docutils literal"><span class="pre">subseq</span></code> 与 <code
                                  class="docutils literal"><span class="pre">position</span></code>
                                ，我们可以写出分开序列的函数。举例来说，这个函数</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">second-word</span> <span class="p">(</span><span class="nv">str</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">p1</span> <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nb">position</span> <span class="sc">#\ </span> <span class="nv">str</span><span class="p">)</span> <span class="mi">1</span><span class="p">)))</span>
    <span class="p">(</span><span class="nb">subseq</span> <span class="nv">str</span> <span class="nv">p1</span> <span class="p">(</span><span class="nb">position</span> <span class="sc">#\ </span> <span class="nv">str</span> <span class="ss">:start</span> <span class="nv">p1</span><span class="p">))))</span>
</pre>
                                </div>
                              </div>
                              <p>返回字符串中第一个单字空格后的第二个单字：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">second-word</span> <span class="s">&quot;Form follows function&quot;</span><span class="p">)</span>
<span class="s">&quot;follows&quot;</span>
</pre>
                                </div>
                              </div>
                              <p>要找到满足谓词的元素，其中谓词接受一个实参，我们使用 <code
                                  class="docutils literal"><span class="pre">position-if</span></code>
                                。它接受一个函数与序列，并返回第一个满足此函数的元素：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">position-if</span> <span class="nf">#&#39;</span><span class="nb">oddp</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">))</span>
<span class="mi">1</span>
</pre>
                                </div>
                              </div>
                              <p><code class="docutils literal"><span class="pre">position-if</span></code> 接受除了 <code
                                  class="docutils literal"><span class="pre">:test</span></code> 之外的所有关键字参数。</p>
                              <p>有许多相似的函数，如给序列使用的 <code class="docutils literal"><span class="pre">member</span></code>
                                与 <code class="docutils literal"><span class="pre">member-if</span></code> 。分别是， <code
                                  class="docutils literal"><span class="pre">find</span></code> （接受全部关键字参数）与 <code
                                  class="docutils literal"><span class="pre">find-if</span></code> （接受除了 <code
                                  class="docutils literal"><span class="pre">:test</span></code> 之外的所有关键字参数）：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">find</span> <span class="sc">#\a</span> <span class="s">&quot;cat&quot;</span><span class="p">)</span>
<span class="sc">#\a</span>

<span class="nb">&gt;</span> <span class="p">(</span><span class="nb">find-if</span> <span class="nf">#&#39;</span><span class="nb">characterp</span> <span class="s">&quot;ham&quot;</span><span class="p">)</span>
<span class="sc">#\h</span>
</pre>
                                </div>
                              </div>
                              <p>不同于 <code class="docutils literal"><span class="pre">member</span></code> 与 <code
                                  class="docutils literal"><span class="pre">member-if</span></code> ，它们仅返回要寻找的对象。</p>
                              <p>通常一个 <code class="docutils literal"><span class="pre">find-if</span></code> 的调用，如果解读为
                                <code class="docutils literal"><span class="pre">find</span></code> 搭配一个 <code
                                  class="docutils literal"><span class="pre">:key</span></code> 关键字参数的话，会显得更清楚。举例来说，表达式
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">find-if</span> <span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span>
             <span class="p">(</span><span class="nb">eql</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">x</span><span class="p">)</span> <span class="ss">&#39;complete</span><span class="p">))</span>
         <span class="nv">lst</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>可以更好的解读为</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">find</span> <span class="ss">&#39;complete</span> <span class="nv">lst</span> <span class="ss">:key</span> <span class="nf">#&#39;</span><span class="nb">car</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>函数 <code class="docutils literal"><span class="pre">remove</span></code> （22 页）以及 <code
                                  class="docutils literal"><span class="pre">remove-if</span></code> 通常都可以用在序列。它们跟 <code
                                  class="docutils literal"><span class="pre">find</span></code> 与 <code
                                  class="docutils literal"><span class="pre">find-if</span></code> 是一样的关系。另一个相关的函数是
                                <code class="docutils literal"><span class="pre">remove-duplicates</span></code>
                                ，仅保留序列中每个元素的最后一次出现。
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">remove-duplicates</span> <span class="s">&quot;abracadabra&quot;</span><span class="p">)</span>
<span class="s">&quot;cdbra&quot;</span>
</pre>
                                </div>
                              </div>
                              <p>这个函数接受前表所列的所有关键字参数。</p>
                              <p>函数 <code class="docutils literal"><span class="pre">reduce</span></code>
                                用来把序列压缩成一个值。它至少接受两个参数，一个函数与序列。函数必须是接受两个实参的函数。在最简单的情况下，一开始函数用序列前两个元素作为实参来调用，之后接续的元素作为下次调用的第二个实参，而上次返回的值作为下次调用的第一个实参。最后调用最终返回的值作为
                                <code class="docutils literal"><span class="pre">reduce</span></code>
                                整个函数的返回值。也就是说像是这样的表达式：
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">reduce</span> <span class="nf">#&#39;</span><span class="nv">fn</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p>等同于</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nv">fn</span> <span class="p">(</span><span class="nv">fn</span> <span class="p">(</span><span class="nv">fn</span> <span class="ss">&#39;a</span> <span class="ss">&#39;b</span><span class="p">)</span> <span class="ss">&#39;c</span><span class="p">)</span> <span class="ss">&#39;d</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>我们可以使用 <code class="docutils literal"><span class="pre">reduce</span></code>
                                来扩充只接受两个参数的函数。举例来说，要得到三个或多个列表的交集(intersection)，我们可以：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">reduce</span> <span class="nf">#&#39;</span><span class="nb">intersection</span> <span class="o">&#39;</span><span class="p">((</span><span class="nv">b</span> <span class="nv">r</span> <span class="nv">a</span> <span class="nv">d</span> <span class="ss">&#39;s</span><span class="p">)</span> <span class="p">(</span><span class="nv">b</span> <span class="nv">a</span> <span class="nv">d</span><span class="p">)</span> <span class="p">(</span><span class="nv">c</span> <span class="nv">a</span> <span class="no">t</span><span class="p">)))</span>
<span class="p">(</span><span class="nv">A</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                            </div>
                            <div class="section" id="example-parsing-dates">
                              <h4>4.5 示例：解析日期 (Example: Parsing Dates)<a class="headerlink"
                                  href="#example-parsing-dates" title="Permalink to this headline">¶</a></h4>
                              <p>作为序列操作的示例，本节演示了如何写程序来解析日期。我们将编写一个程序，可以接受像是 “16 Aug 1980” 的字符串，然后返回一个表示日、月、年的整数列表。</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">tokens</span> <span class="p">(</span><span class="nv">str</span> <span class="nv">test</span> <span class="nv">start</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">p1</span> <span class="p">(</span><span class="nb">position-if</span> <span class="nv">test</span> <span class="nv">str</span> <span class="ss">:start</span> <span class="nv">start</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">if</span> <span class="nv">p1</span>
        <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">p2</span> <span class="p">(</span><span class="nb">position-if</span> <span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">c</span><span class="p">)</span>
                                   <span class="p">(</span><span class="nb">not</span> <span class="p">(</span><span class="nb">funcall</span> <span class="nv">test</span> <span class="nv">c</span><span class="p">)))</span>
                               <span class="nv">str</span> <span class="ss">:start</span> <span class="nv">p1</span><span class="p">)))</span>
          <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nb">subseq</span> <span class="nv">str</span> <span class="nv">p1</span> <span class="nv">p2</span><span class="p">)</span>
                <span class="p">(</span><span class="k">if</span> <span class="nv">p2</span>
                    <span class="p">(</span><span class="nv">tokens</span> <span class="nv">str</span> <span class="nv">test</span> <span class="nv">p2</span><span class="p">)</span>
                    <span class="no">nil</span><span class="p">)))</span>
        <span class="no">nil</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">constituent</span> <span class="p">(</span><span class="nv">c</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nb">graphic-char-p</span> <span class="nv">c</span><span class="p">)</span>
       <span class="p">(</span><span class="nb">not</span> <span class="p">(</span><span class="nb">char=</span> <span class="nv">c</span> <span class="sc">#\ </span><span class="p">))))</span>
</pre>
                                </div>
                              </div>
                              <p>图 4.2 辨别符号 (token)</p>
                              <p>图 4.2 里包含了某些在这个应用里所需的通用解析函数。第一个函数 <code
                                  class="docutils literal"><span class="pre">tokens</span></code> ，用来从字符串中取出语元
                                （token）。给定一个字符串及测试函数，满足测试函数的字符组成子字符串，子字符串再组成列表返回。举例来说，如果测试函数是对字母返回真的 <code
                                  class="docutils literal"><span class="pre">alpha-char-p</span></code> 函数，我们得到：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">tokens</span> <span class="s">&quot;ab12 3cde.f&quot;</span> <span class="nf">#&#39;</span><span class="nb">alpha-char-p</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">(</span><span class="s">&quot;ab&quot;</span> <span class="s">&quot;cde&quot;</span> <span class="s">&quot;f&quot;</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>所有不满足此函数的字符被视为空白 ── 他们是语元的分隔符，但永远不是语元的一部分。</p>
                              <p>函数 <code class="docutils literal"><span class="pre">constituent</span></code> 被定义成用来作为
                                <code class="docutils literal"><span class="pre">tokens</span></code> 的实参。
                              </p>
                              <p>在 Common Lisp 里，<em>图形字符</em>是我们可见的字符，加上空白字符。所以如果我们用 <code
                                  class="docutils literal"><span class="pre">constituent</span></code> 作为测试函数时，</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">tokens</span> <span class="s">&quot;ab12 3cde.f gh&quot;</span> <span class="nf">#&#39;</span><span class="nv">constituent</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">(</span><span class="s">&quot;ab12&quot;</span> <span class="s">&quot;3cde.f&quot;</span> <span class="s">&quot;gh&quot;</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>则语元将会由空白区分出来。</p>
                              <p>图 4.3 包含了特别为解析日期打造的函数。函数 <code
                                  class="docutils literal"><span class="pre">parse-date</span></code>
                                接受一个特别形式组成的日期，并返回代表这个日期的整数列表：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">parse-date</span> <span class="s">&quot;16 Aug 1980&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="mi">16</span> <span class="mi">8</span> <span class="mi">1980</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">parse-date</span> <span class="p">(</span><span class="nv">str</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">toks</span> <span class="p">(</span><span class="nv">tokens</span> <span class="nv">str</span> <span class="nf">#&#39;</span><span class="nv">constituent</span> <span class="mi">0</span><span class="p">)))</span>
    <span class="p">(</span><span class="nb">list</span> <span class="p">(</span><span class="nb">parse-integer</span> <span class="p">(</span><span class="nb">first</span> <span class="nv">toks</span><span class="p">))</span>
          <span class="p">(</span><span class="nv">parse-month</span> <span class="p">(</span><span class="nb">second</span> <span class="nv">toks</span><span class="p">))</span>
          <span class="p">(</span><span class="nb">parse-integer</span> <span class="p">(</span><span class="nb">third</span> <span class="nv">toks</span><span class="p">)))))</span>

<span class="p">(</span><span class="nb">defconstant</span> <span class="nv">month-names</span>
  <span class="o">#(</span><span class="s">&quot;jan&quot;</span> <span class="s">&quot;feb&quot;</span> <span class="s">&quot;mar&quot;</span> <span class="s">&quot;apr&quot;</span> <span class="s">&quot;may&quot;</span> <span class="s">&quot;jun&quot;</span>
    <span class="s">&quot;jul&quot;</span> <span class="s">&quot;aug&quot;</span> <span class="s">&quot;sep&quot;</span> <span class="s">&quot;oct&quot;</span> <span class="s">&quot;nov&quot;</span> <span class="s">&quot;dec&quot;</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">parse-month</span> <span class="p">(</span><span class="nv">str</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">p</span> <span class="p">(</span><span class="nb">position</span> <span class="nv">str</span> <span class="nv">month-names</span>
                         <span class="ss">:test</span> <span class="nf">#&#39;</span><span class="nb">string-equal</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">if</span> <span class="nv">p</span>
        <span class="p">(</span><span class="nb">+</span> <span class="nv">p</span> <span class="mi">1</span><span class="p">)</span>
        <span class="no">nil</span><span class="p">)))</span>
</pre>
                                </div>
                              </div>
                              <p>图 4.3 解析日期的函数</p>
                              <p><code class="docutils literal"><span class="pre">parse-date</span></code> 使用 <code
                                  class="docutils literal"><span class="pre">tokens</span></code> 来解析日期字符串，接著调用 <code
                                  class="docutils literal"><span class="pre">parse-month</span></code> 及 <code
                                  class="docutils literal"><span class="pre">parse-integer</span></code>
                                来转译年、月、日。要找到月份，调用 <code
                                  class="docutils literal"><span class="pre">parse-month</span></code> ，由于使用的是 <code
                                  class="docutils literal"><span class="pre">string-equal</span></code>
                                来匹配月份的名字，所以输入可以不分大小写。要找到年和日，调用内置的 <code
                                  class="docutils literal"><span class="pre">parse-integer</span></code> ， <code
                                  class="docutils literal"><span class="pre">parse-integer</span></code>
                                接受一个字符串并返回对应的整数。</p>
                              <p>如果需要自己写程序来解析整数，也许可以这么写：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">read-integer</span> <span class="p">(</span><span class="nv">str</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">every</span> <span class="nf">#&#39;</span><span class="nb">digit-char-p</span> <span class="nv">str</span><span class="p">)</span>
      <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">accum</span> <span class="mi">0</span><span class="p">))</span>
        <span class="p">(</span><span class="nb">dotimes</span> <span class="p">(</span><span class="nv">pos</span> <span class="p">(</span><span class="nb">length</span> <span class="nv">str</span><span class="p">))</span>
          <span class="p">(</span><span class="nb">setf</span> <span class="nv">accum</span> <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">accum</span> <span class="mi">10</span><span class="p">)</span>
                         <span class="p">(</span><span class="nb">digit-char-p</span> <span class="p">(</span><span class="nb">char</span> <span class="nv">str</span> <span class="nv">pos</span><span class="p">)))))</span>
        <span class="nv">accum</span><span class="p">)</span>
    <span class="no">nil</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p>这个定义演示了在 Common Lisp 中，字符是如何转成数字的 ── 函数 <code
                                  class="docutils literal"><span class="pre">digit-char-p</span></code>
                                不仅测试字符是否为数字，同时返回了对应的整数。</p>
                            </div>
                            <div class="section" id="structures">
                              <h4>4.6 结构 (Structures)<a class="headerlink" href="#structures"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>结构可以想成是豪华版的向量。假设你要写一个程序来追踪长方体。你可能会想用三个向量元素来表示长方体：高度、宽度及深度。与其使用原本的 <code
                                  class="docutils literal"><span class="pre">svref</span></code>
                                ，不如定义像是下面这样的抽象，程序会变得更容易阅读，</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">block-height</span> <span class="p">(</span><span class="nv">b</span><span class="p">)</span> <span class="p">(</span><span class="nb">svref</span> <span class="nv">b</span> <span class="mi">0</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p>而结构可以想成是，这些函数通通都替你定义好了的向量。</p>
                              <p>要想定义结构，使用 <code class="docutils literal"><span class="pre">defstruct</span></code>
                                。在最简单的情况下，只要给出结构及字段的名字便可以了：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defstruct</span> <span class="nv">point</span>
  <span class="nv">x</span>
  <span class="nv">y</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>这里定义了一个 <code class="docutils literal"><span class="pre">point</span></code> 结构，具有两个字段
                                <code class="docutils literal"><span class="pre">x</span></code> 与 <code
                                  class="docutils literal"><span class="pre">y</span></code> 。同时隐式地定义了 <code
                                  class="docutils literal"><span class="pre">make-point</span></code> 、 <code
                                  class="docutils literal"><span class="pre">point-p</span></code> 、 <code
                                  class="docutils literal"><span class="pre">copy-point</span></code> 、 <code
                                  class="docutils literal"><span class="pre">point-x</span></code> 及 <code
                                  class="docutils literal"><span class="pre">point-y</span></code> 函数。
                              </p>
                              <p>2.3 节提过， Lisp 程序可以写出 Lisp 程序。这是目前所见的明显例子之一。当你调用 <code
                                  class="docutils literal"><span class="pre">defstruct</span></code>
                                时，它自动生成了其它几个函数的定义。有了宏以后，你将可以自己来办到同样的事情（如果需要的话，你甚至可以自己写出 <code
                                  class="docutils literal"><span class="pre">defstruct</span></code> ）。</p>
                              <p>每一个 <code class="docutils literal"><span class="pre">make-point</span></code>
                                的调用，会返回一个新的 <code class="docutils literal"><span class="pre">point</span></code>
                                。可以通过给予对应的关键字参数，来指定单一字段的值：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">setf</span> <span class="nv">p</span> <span class="p">(</span><span class="nv">make-point</span> <span class="ss">:x</span> <span class="mi">0</span> <span class="ss">:y</span> <span class="mi">0</span><span class="p">))</span>
<span class="l-Other">#S</span><span class="p">(</span><span class="nv">POINT</span> <span class="nv">X</span> <span class="mi">0</span> <span class="nv">Y</span> <span class="mi">0</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>存取 <code class="docutils literal"><span class="pre">point</span></code>
                                字段的函数不仅被定义成可取出数值，也可以搭配 <code
                                  class="docutils literal"><span class="pre">setf</span></code> 一起使用。</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">point-x</span> <span class="nv">p</span><span class="p">)</span>
<span class="mi">0</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nv">point-y</span> <span class="nv">p</span><span class="p">)</span> <span class="mi">2</span><span class="p">)</span>
<span class="mi">2</span>
<span class="nb">&gt;</span> <span class="nv">p</span>
<span class="l-Other">#S</span><span class="p">(</span><span class="nv">POINT</span> <span class="nv">X</span> <span class="mi">0</span> <span class="nv">Y</span> <span class="mi">2</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>定义结构也定义了以结构为名的类型。每个点的类型层级会是，类型 <code
                                  class="docutils literal"><span class="pre">point</span></code> ，接著是类型 <code
                                  class="docutils literal"><span class="pre">structure</span></code> ，再来是类型 <code
                                  class="docutils literal"><span class="pre">atom</span></code> ，最后是 <code
                                  class="docutils literal"><span class="pre">t</span></code> 类型。所以使用 <code
                                  class="docutils literal"><span class="pre">point-p</span></code>
                                来测试某个东西是不是一个点时，也可以使用通用性的函数，像是 <code
                                  class="docutils literal"><span class="pre">typep</span></code> 来测试。</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">point-p</span> <span class="nv">p</span><span class="p">)</span>
<span class="no">T</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="nb">typep</span> <span class="nv">p</span> <span class="ss">&#39;point</span><span class="p">)</span>
<span class="no">T</span>
</pre>
                                </div>
                              </div>
                              <p>我们可以在本来的定义中，附上一个列表，含有字段名及缺省表达式，来指定结构字段的缺省值。</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defstruct</span> <span class="nv">polemic</span>
  <span class="p">(</span><span class="k">type</span> <span class="p">(</span><span class="k">progn</span>
          <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;What kind of polemic was it? &quot;</span><span class="p">)</span>
          <span class="p">(</span><span class="nb">read</span><span class="p">)))</span>
  <span class="p">(</span><span class="nv">effect</span> <span class="no">nil</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p>如果 <code class="docutils literal"><span class="pre">make-polemic</span></code>
                                调用没有给字段指定初始值，则字段会被设成缺省表达式的值：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">make-polemic</span><span class="p">)</span>
<span class="nv">What</span> <span class="nv">kind</span> <span class="nv">of</span> <span class="nv">polemic</span> <span class="nv">was</span> <span class="nv">it?</span> <span class="nv">scathing</span>
<span class="l-Other">#S</span><span class="p">(</span><span class="nv">POLEMIC</span> <span class="ss">:TYPE</span> <span class="nv">SCATHING</span> <span class="ss">:EFFECT</span> <span class="no">NIL</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>结构显示的方式也可以控制，以及结构自动产生的存取函数的字首。以下是做了前述两件事的 <code
                                  class="docutils literal"><span class="pre">point</span></code> 定义：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defstruct</span> <span class="p">(</span><span class="nv">point</span> <span class="p">(</span><span class="ss">:conc-name</span> <span class="nv">p</span><span class="p">)</span>
                  <span class="p">(</span><span class="ss">:print-function</span> <span class="nv">print-point</span><span class="p">))</span>
  <span class="p">(</span><span class="nv">x</span> <span class="mi">0</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">y</span> <span class="mi">0</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">print-point</span> <span class="p">(</span><span class="nv">p</span> <span class="nc">stream</span> <span class="nv">depth</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">format</span> <span class="nc">stream</span> <span class="s">&quot;#&lt;~A, ~A&gt;&quot;</span> <span class="p">(</span><span class="nv">px</span> <span class="nv">p</span><span class="p">)</span> <span class="p">(</span><span class="nv">py</span> <span class="nv">p</span><span class="p">)))</span>
</pre>
                                </div>
                              </div>
                              <p><code class="docutils literal"><span class="pre">:conc-name</span></code>
                                关键字参数指定了要放在字段前面的名字，并用这个名字来生成存取函数。预设是 <code
                                  class="docutils literal"><span class="pre">point-</span></code> ；现在变成只有 <code
                                  class="docutils literal"><span class="pre">p</span></code>
                                。不使用缺省的方式使代码的可读性些微降低了，只有在需要常常用到这些存取函数时，你才会想取个短点的名字。</p>
                              <p><code class="docutils literal"><span class="pre">:print-function</span></code>
                                是在需要显示结构出来看时，指定用来打印结构的函数 ── 需要显示的情况比如，要在顶层显示时。这个函数需要接受三个实参：要被印出的结构，在哪里被印出，第三个参数通常可以忽略。
                                <a class="footnote-reference" href="#id6" id="id3">[2]</a> 我们会在 7.1
                                节讨论流（stream）。现在来说，只要知道流可以作为参数传给 <code
                                  class="docutils literal"><span class="pre">format</span></code> 就好了。
                              </p>
                              <p>函数 <code class="docutils literal"><span class="pre">print-point</span></code>
                                会用缩写的形式来显示点：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre>&gt; (make-point)
#&lt;0,0&gt;
</pre>
                                </div>
                              </div>
                            </div>
                            <div class="section" id="example-binary-search-tree">
                              <h4>4.7 示例：二叉搜索树 (Example: Binary Search Tree)<a class="headerlink"
                                  href="#example-binary-search-tree" title="Permalink to this headline">¶</a></h4>
                              <p>由于 <code class="docutils literal"><span class="pre">sort</span></code> 本身系统就有了，极少需要在
                                Common Lisp 里编写排序程序。本节将演示如何解决一个与此相关的问题，这个问题尚未有现成的解决方案：维护一个已排序的对象集合。本节的代码会把对象存在二叉搜索树里（
                                <em>binary search tree</em> ）或称作 BST。当二叉搜索树平衡时，允许我们可以在与时间成 <code
                                  class="docutils literal"><span class="pre">log</span> <span class="pre">n</span></code>
                                比例的时间内，来寻找、添加或是删除元素，其中 <code class="docutils literal"><span class="pre">n</span></code>
                                是集合的大小。
                              </p>
                              <div class="figure">
                                <img alt="_images/Figure-4.4.png" src="_images/Figure-4.4.png" />
                              </div>
                              <p>图 4.4: 二叉搜索树</p>
                              <p>二叉搜索树是一种二叉树，给定某个排序函数，比如 <code
                                  class="docutils literal"><span class="pre">&lt;</span></code> ，每个元素的左子树都 <code
                                  class="docutils literal"><span class="pre">&lt;</span></code> 该元素，而该元素 <code
                                  class="docutils literal"><span class="pre">&lt;</span></code> 其右子树。图 4.4 展示了根据 <code
                                  class="docutils literal"><span class="pre">&lt;</span></code> 排序的二叉树。</p>
                              <p>图 4.5 包含了二叉搜索树的插入与寻找的函数。基本的数据结构会是 <code
                                  class="docutils literal"><span class="pre">node</span></code>
                                （节点），节点有三个部分：一个字段表示存在该节点的对象，以及各一个字段表示节点的左子树及右子树。可以把节点想成是有一个 <code
                                  class="docutils literal"><span class="pre">car</span></code> 和两个 <code
                                  class="docutils literal"><span class="pre">cdr</span></code> 的一个 cons 核（cons cell）。
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defstruct</span> <span class="p">(</span><span class="nv">node</span> <span class="p">(</span><span class="ss">:print-function</span>
                  <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">n</span> <span class="nv">s</span> <span class="nv">d</span><span class="p">)</span>
                    <span class="p">(</span><span class="nb">format</span> <span class="nv">s</span> <span class="s">&quot;#&lt;~A&gt;&quot;</span> <span class="p">(</span><span class="nv">node-elt</span> <span class="nv">n</span><span class="p">)))))</span>
  <span class="nb">elt</span> <span class="p">(</span><span class="nv">l</span> <span class="no">nil</span><span class="p">)</span> <span class="p">(</span><span class="nv">r</span> <span class="no">nil</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">bst-insert</span> <span class="p">(</span><span class="nv">obj</span> <span class="nv">bst</span> <span class="nb">&lt;</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">null</span> <span class="nv">bst</span><span class="p">)</span>
      <span class="p">(</span><span class="nv">make-node</span> <span class="ss">:elt</span> <span class="nv">obj</span><span class="p">)</span>
      <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nb">elt</span> <span class="p">(</span><span class="nv">node-elt</span> <span class="nv">bst</span><span class="p">)))</span>
        <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">eql</span> <span class="nv">obj</span> <span class="nb">elt</span><span class="p">)</span>
            <span class="nv">bst</span>
            <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">funcall</span> <span class="nb">&lt;</span> <span class="nv">obj</span> <span class="nb">elt</span><span class="p">)</span>
                <span class="p">(</span><span class="nv">make-node</span>
                   <span class="ss">:elt</span> <span class="nb">elt</span>
                   <span class="ss">:l</span> <span class="p">(</span><span class="nv">bst-insert</span> <span class="nv">obj</span> <span class="p">(</span><span class="nv">node-l</span> <span class="nv">bst</span><span class="p">)</span> <span class="nb">&lt;</span><span class="p">)</span>
                   <span class="ss">:r</span> <span class="p">(</span><span class="nv">node-r</span> <span class="nv">bst</span><span class="p">))</span>
                <span class="p">(</span><span class="nv">make-node</span>
                   <span class="ss">:elt</span> <span class="nb">elt</span>
                   <span class="ss">:r</span> <span class="p">(</span><span class="nv">bst-insert</span> <span class="nv">obj</span> <span class="p">(</span><span class="nv">node-r</span> <span class="nv">bst</span><span class="p">)</span> <span class="nb">&lt;</span><span class="p">)</span>
                   <span class="ss">:l</span> <span class="p">(</span><span class="nv">node-l</span> <span class="nv">bst</span><span class="p">)))))))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">bst-find</span> <span class="p">(</span><span class="nv">obj</span> <span class="nv">bst</span> <span class="nb">&lt;</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">null</span> <span class="nv">bst</span><span class="p">)</span>
      <span class="no">nil</span>
      <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nb">elt</span> <span class="p">(</span><span class="nv">node-elt</span> <span class="nv">bst</span><span class="p">)))</span>
        <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">eql</span> <span class="nv">obj</span> <span class="nb">elt</span><span class="p">)</span>
            <span class="nv">bst</span>
            <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">funcall</span> <span class="nb">&lt;</span> <span class="nv">obj</span> <span class="nb">elt</span><span class="p">)</span>
                <span class="p">(</span><span class="nv">bst-find</span> <span class="nv">obj</span> <span class="p">(</span><span class="nv">node-l</span> <span class="nv">bst</span><span class="p">)</span> <span class="nb">&lt;</span><span class="p">)</span>
                <span class="p">(</span><span class="nv">bst-find</span> <span class="nv">obj</span> <span class="p">(</span><span class="nv">node-r</span> <span class="nv">bst</span><span class="p">)</span> <span class="nb">&lt;</span><span class="p">))))))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">bst-min</span> <span class="p">(</span><span class="nv">bst</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">and</span> <span class="nv">bst</span>
       <span class="p">(</span><span class="nb">or</span> <span class="p">(</span><span class="nv">bst-min</span> <span class="p">(</span><span class="nv">node-l</span> <span class="nv">bst</span><span class="p">))</span> <span class="nv">bst</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">bst-max</span> <span class="p">(</span><span class="nv">bst</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">and</span> <span class="nv">bst</span>
       <span class="p">(</span><span class="nb">or</span> <span class="p">(</span><span class="nv">bst-max</span> <span class="p">(</span><span class="nv">node-r</span> <span class="nv">bst</span><span class="p">))</span> <span class="nv">bst</span><span class="p">)))</span>
</pre>
                                </div>
                              </div>
                              <p>图 4.5 二叉搜索树：查询与插入</p>
                              <p>一棵二叉搜索树可以是 <code class="docutils literal"><span class="pre">nil</span></code>
                                或是一个左子、右子树都是二叉搜索树的节点。如同列表可由连续调用 <code
                                  class="docutils literal"><span class="pre">cons</span></code> 来构造，二叉搜索树将可以通过连续调用 <code
                                  class="docutils literal"><span class="pre">bst-insert</span></code>
                                来构造。这个函数接受一个对象，一棵二叉搜索树及一个排序函数，并返回将对象插入的二叉搜索树。和 <code
                                  class="docutils literal"><span class="pre">cons</span></code> 函数一样， <code
                                  class="docutils literal"><span class="pre">bst-insert</span></code>
                                不改动做为第二个实参所传入的二叉搜索树。以下是如何使用这个函数来构造一棵叉搜索树：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">setf</span> <span class="nv">nums</span> <span class="no">nil</span><span class="p">)</span>
<span class="no">NIL</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="nb">dolist</span> <span class="p">(</span><span class="nv">x</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">5</span> <span class="mi">8</span> <span class="mi">4</span> <span class="mi">2</span> <span class="mi">1</span> <span class="mi">9</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">3</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">setf</span> <span class="nv">nums</span> <span class="p">(</span><span class="nv">bst-insert</span> <span class="nv">x</span> <span class="nv">nums</span> <span class="nf">#&#39;</span><span class="nb">&lt;</span><span class="p">)))</span>
<span class="no">NIL</span>
</pre>
                                </div>
                              </div>
                              <p>图 4.4 显示了此时 <code class="docutils literal"><span class="pre">nums</span></code>
                                的结构所对应的树。</p>
                              <p>我们可以使用 <code class="docutils literal"><span class="pre">bst-find</span></code>
                                来找到二叉搜索树中的对象，它与 <code
                                  class="docutils literal"><span class="pre">bst-insert</span></code> 接受同样的参数。先前叙述所提到的
                                <code class="docutils literal"><span class="pre">node</span></code> 结构，它像是一个具有两个 <code
                                  class="docutils literal"><span class="pre">cdr</span></code> 的 cons 核。如果我们把 16 页的
                                <code class="docutils literal"><span class="pre">our-member</span></code> 拿来与 <code
                                  class="docutils literal"><span class="pre">bst-find</span></code> 比较的话，这样的类比更加明确。
                              </p>
                              <p>与 <code class="docutils literal"><span class="pre">member</span></code> 相同， <code
                                  class="docutils literal"><span class="pre">bst-find</span></code>
                                不仅返回要寻找的元素，也返回了用寻找元素做为根节点的子树：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre>&gt; (bst-find 12 nums #&#39;&lt;)
NIL
&gt; (bst-find 4 nums #&#39;&lt;)
#&lt;4&gt;
</pre>
                                </div>
                              </div>
                              <p>这使我们可以区分出无法找到某个值，以及成功找到 <code
                                  class="docutils literal"><span class="pre">nil</span></code> 的情况。</p>
                              <p>要找到二叉搜索树的最小及最大的元素是很简单的。要找到最小的，我们沿着左子树的路径走，如同 <code
                                  class="docutils literal"><span class="pre">bst-min</span></code>
                                所做的。要找到最大的，沿着右子树的路径走，如同 <code
                                  class="docutils literal"><span class="pre">bst-max</span></code> 所做的：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre>&gt; (bst-min nums)
#&lt;1&gt;
&gt; (bst-max nums)
#&lt;9&gt;
</pre>
                                </div>
                              </div>
                              <p>要从二叉搜索树里移除元素一样很快，但需要更多代码。图 4.6 演示了如何从二叉搜索树里移除元素。</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">bst-remove</span> <span class="p">(</span><span class="nv">obj</span> <span class="nv">bst</span> <span class="nb">&lt;</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">null</span> <span class="nv">bst</span><span class="p">)</span>
      <span class="no">nil</span>
      <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nb">elt</span> <span class="p">(</span><span class="nv">node-elt</span> <span class="nv">bst</span><span class="p">)))</span>
        <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">eql</span> <span class="nv">obj</span> <span class="nb">elt</span><span class="p">)</span>
            <span class="p">(</span><span class="nv">percolate</span> <span class="nv">bst</span><span class="p">)</span>
            <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">funcall</span> <span class="nb">&lt;</span> <span class="nv">obj</span> <span class="nb">elt</span><span class="p">)</span>
                <span class="p">(</span><span class="nv">make-node</span>
                   <span class="ss">:elt</span> <span class="nb">elt</span>
                   <span class="ss">:l</span> <span class="p">(</span><span class="nv">bst-remove</span> <span class="nv">obj</span> <span class="p">(</span><span class="nv">node-l</span> <span class="nv">bst</span><span class="p">)</span> <span class="nb">&lt;</span><span class="p">)</span>
                   <span class="ss">:r</span> <span class="p">(</span><span class="nv">node-r</span> <span class="nv">bst</span><span class="p">))</span>
                <span class="p">(</span><span class="nv">make-node</span>
                   <span class="ss">:elt</span> <span class="nb">elt</span>
                   <span class="ss">:r</span> <span class="p">(</span><span class="nv">bst-remove</span> <span class="nv">obj</span> <span class="p">(</span><span class="nv">node-r</span> <span class="nv">bst</span><span class="p">)</span> <span class="nb">&lt;</span><span class="p">)</span>
                   <span class="ss">:l</span> <span class="p">(</span><span class="nv">node-l</span> <span class="nv">bst</span><span class="p">)))))))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">percolate</span> <span class="p">(</span><span class="nv">bst</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nb">null</span> <span class="p">(</span><span class="nv">node-l</span> <span class="nv">bst</span><span class="p">))</span>
         <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">null</span> <span class="p">(</span><span class="nv">node-r</span> <span class="nv">bst</span><span class="p">))</span>
             <span class="no">nil</span>
             <span class="p">(</span><span class="nv">rperc</span> <span class="nv">bst</span><span class="p">)))</span>
        <span class="p">((</span><span class="nb">null</span> <span class="p">(</span><span class="nv">node-r</span> <span class="nv">bst</span><span class="p">))</span> <span class="p">(</span><span class="nv">lperc</span> <span class="nv">bst</span><span class="p">))</span>
        <span class="p">(</span><span class="no">t</span> <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">zerop</span> <span class="p">(</span><span class="nb">random</span> <span class="mi">2</span><span class="p">))</span>
               <span class="p">(</span><span class="nv">lperc</span> <span class="nv">bst</span><span class="p">)</span>
               <span class="p">(</span><span class="nv">rperc</span> <span class="nv">bst</span><span class="p">)))))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">rperc</span> <span class="p">(</span><span class="nv">bst</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">make-node</span> <span class="ss">:elt</span> <span class="p">(</span><span class="nv">node-elt</span> <span class="p">(</span><span class="nv">node-r</span> <span class="nv">bst</span><span class="p">))</span>
             <span class="ss">:l</span> <span class="p">(</span><span class="nv">node-l</span> <span class="nv">bst</span><span class="p">)</span>
             <span class="ss">:r</span> <span class="p">(</span><span class="nv">percolate</span> <span class="p">(</span><span class="nv">node-r</span> <span class="nv">bst</span><span class="p">))))</span>
</pre>
                                </div>
                              </div>
                              <p>图 4.6 二叉搜索树：移除</p>
                              <p><strong>勘误:</strong> 此版 <code
                                  class="docutils literal"><span class="pre">bst-remove</span></code> 的定义已被汇报是坏掉的，请参考 <a
                                  class="reference external" href="https://gist.github.com/2868263">这里</a> 获得修复版。</p>
                              <p>函数 <code class="docutils literal"><span class="pre">bst-remove</span></code>
                                接受一个对象，一棵二叉搜索树以及排序函数，并返回一棵与本来的二叉搜索树相同的树，但不包含那个要移除的对象。和 <code
                                  class="docutils literal"><span class="pre">remove</span></code>
                                一样，它不改动做为第二个实参所传入的二叉搜索树：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre>&gt; (setf nums (bst-remove 2 nums #&#39;&lt;))
#&lt;5&gt;
&gt; (bst-find 2 nums #&#39;&lt;)
NIL
</pre>
                                </div>
                              </div>
                              <p>此时 <code class="docutils literal"><span class="pre">nums</span></code> 的结构应该如图 4.7 所示。
                                （另一个可能性是 <code class="docutils literal"><span class="pre">1</span></code> 取代了 <code
                                  class="docutils literal"><span class="pre">2</span></code> 的位置。）</p>
                              <div class="figure">
                                <img alt="_images/Figure-4.7.png" src="_images/Figure-4.7.png" />
                              </div>
                              <p>图 4.7: 二叉搜索树</p>
                              <p>移除需要做更多工作，因为从内部节点移除一个对象时，会留下一个空缺，需要由其中一个孩子来填补。这是 <code
                                  class="docutils literal"><span class="pre">percolate</span></code>
                                函数的用途。当它替换一个二叉搜索树的树根（topmost element）时，会找其中一个孩子来替换，并用此孩子的孩子来填补，如此这般一直递归下去。</p>
                              <p>为了要保持树的平衡，如果有两个孩子时， <code
                                  class="docutils literal"><span class="pre">perlocate</span></code> 随机择一替换。表达式 <code
                                  class="docutils literal"><span class="pre">(random</span> <span class="pre">2)</span></code>
                                会返回 <code class="docutils literal"><span class="pre">0</span></code> 或 <code
                                  class="docutils literal"><span class="pre">1</span></code> ，所以 <code
                                  class="docutils literal"><span class="pre">(zerop</span> <span class="pre">(random</span> <span class="pre">2))</span></code>
                                会返回真或假。</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">bst-traverse</span> <span class="p">(</span><span class="nv">fn</span> <span class="nv">bst</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">when</span> <span class="nv">bst</span>
    <span class="p">(</span><span class="nv">bst-traverse</span> <span class="nv">fn</span> <span class="p">(</span><span class="nv">node-l</span> <span class="nv">bst</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">funcall</span> <span class="nv">fn</span> <span class="p">(</span><span class="nv">node-elt</span> <span class="nv">bst</span><span class="p">))</span>
    <span class="p">(</span><span class="nv">bst-traverse</span> <span class="nv">fn</span> <span class="p">(</span><span class="nv">node-r</span> <span class="nv">bst</span><span class="p">))))</span>
</pre>
                                </div>
                              </div>
                              <p>图 4.8 二叉搜索树：遍历</p>
                              <p>一旦我们把一个对象集合插入至二叉搜索树时，中序遍历会将它们由小至大排序。这是图 4.8 中， <code
                                  class="docutils literal"><span class="pre">bst-traverse</span></code> 函数的用途：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">bst-traverse</span> <span class="nf">#&#39;</span><span class="nb">princ</span> <span class="nv">nums</span><span class="p">)</span>
<span class="mi">13456789</span>
<span class="no">NIL</span>
</pre>
                                </div>
                              </div>
                              <p>（函数 <code class="docutils literal"><span class="pre">princ</span></code> 仅显示单一对象）</p>
                              <p>本节所给出的代码，提供了一个二叉搜索树实现的脚手架。你可能想根据应用需求，来充实这个脚手架。举例来说，这里所给出的代码每个节点只有一个 <code
                                  class="docutils literal"><span class="pre">elt</span></code> 字段；在许多应用里，有两个字段会更有意义，
                                <code class="docutils literal"><span class="pre">key</span></code> 与 <code
                                  class="docutils literal"><span class="pre">value</span></code>
                                。本章的这个版本把二叉搜索树视为集合看待，从这个角度看，重复的插入是被忽略的。但是代码可以很简单地改动，来处理重复的元素。
                              </p>
                              <p>
                                二叉搜索树不仅是维护一个已排序对象的集合的方法。他们是否是最好的方法，取决于你的应用。一般来说，二叉搜索树最适合用在插入与删除是均匀分布的情况。有一件二叉搜索树不擅长的事，就是用来维护优先队列（priority
                                queues）。在一个优先队列里，插入也许是均匀分布的，但移除总是在一个另一端。这会导致一个二叉搜索树变得不平衡，而我们期望的复杂度是 <code
                                  class="docutils literal"><span class="pre">O(log(n))</span></code> 插入与移除操作，将会变成 <code
                                  class="docutils literal"><span class="pre">O(n)</span></code>
                                。如果用二叉搜索树来表示一个优先队列，也可以使用一般的列表，因为二叉搜索树最终会作用的像是个列表。</p>
                            </div>
                            <div class="section" id="hash-table">
                              <h4>4.8 哈希表 (Hash Table)<a class="headerlink" href="#hash-table"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>第三章演示过列表可以用来表示集合（sets）与映射（mappings）。但当列表的长度大幅上升时（或是 10 个元素），使用哈希表的速度比较快。你通过调用 <code
                                  class="docutils literal"><span class="pre">make-hash-table</span></code>
                                来构造一个哈希表，它不需要传入参数：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre>&gt; (setf ht (make-hash-table))
#&lt;Hash-Table BF0A96&gt;
</pre>
                                </div>
                              </div>
                              <p>和函数一样，哈希表总是用 <code
                                  class="docutils literal"><span class="pre">#&lt;...&gt;</span></code> 的形式来显示。</p>
                              <p>一个哈希表，与一个关联列表类似，是一种表达对应关系的方式。要取出与给定键值有关的数值，我们调用 <code
                                  class="docutils literal"><span class="pre">gethash</span></code>
                                并传入一个键值与哈希表。预设情况下，如果没有与这个键值相关的数值， <code
                                  class="docutils literal"><span class="pre">gethash</span></code> 会返回 <code
                                  class="docutils literal"><span class="pre">nil</span></code> 。</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">gethash</span> <span class="ss">&#39;color</span> <span class="nv">ht</span><span class="p">)</span>
<span class="no">NIL</span>
<span class="no">NIL</span>
</pre>
                                </div>
                              </div>
                              <p>在这里我们首次看到 Common Lisp 最突出的特色之一：一个表达式竟然可以返回多个数值。函数 <code
                                  class="docutils literal"><span class="pre">gethash</span></code>
                                返回两个数值。第一个值是与键值有关的数值，第二个值说明了哈希表是否含有任何用此键值来储存的数值。由于第二个值是 <code
                                  class="docutils literal"><span class="pre">nil</span></code> ，我们知道第一个 <code
                                  class="docutils literal"><span class="pre">nil</span></code> 是缺省的返回值，而不是因为 <code
                                  class="docutils literal"><span class="pre">nil</span></code> 是与 <code
                                  class="docutils literal"><span class="pre">color</span></code> 有关的数值。</p>
                              <p>大部分的实现会在顶层显示一个函数调用的所有返回值，但仅期待一个返回值的代码，只会收到第一个返回值。 5.5 节会说明，代码如何接收多个返回值。</p>
                              <p>要把数值与键值作关联，使用 <code class="docutils literal"><span class="pre">gethash</span></code> 搭配
                                <code class="docutils literal"><span class="pre">setf</span></code> ：
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nb">gethash</span> <span class="ss">&#39;color</span> <span class="nv">ht</span><span class="p">)</span> <span class="ss">&#39;red</span><span class="p">)</span>
<span class="nv">RED</span>
</pre>
                                </div>
                              </div>
                              <p>现在如果我们再次调用 <code class="docutils literal"><span class="pre">gethash</span></code>
                                ，我们会得到我们刚插入的值：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">gethash</span> <span class="ss">&#39;color</span> <span class="nv">ht</span><span class="p">)</span>
<span class="nv">RED</span>
<span class="no">T</span>
</pre>
                                </div>
                              </div>
                              <p>第二个返回值证明，我们取得了一个真正储存的对象，而不是预设值。</p>
                              <p>存在哈希表的对象或键值可以是任何类型。举例来说，如果我们要保留函数的某种讯息，我们可以使用哈希表，用函数作为键值，字符串作为词条（entry）：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre>&gt; (setf bugs (make-hash-table))
#&lt;Hash-Table BF4C36&gt;
&gt; (push &quot;Doesn&#39;t take keyword arguments.&quot;
        (gethash #&#39;our-member bugs))
(&quot;Doesn&#39;t take keyword arguments.&quot;)
</pre>
                                </div>
                              </div>
                              <p>由于 <code class="docutils literal"><span class="pre">gethash</span></code> 缺省返回 <code
                                  class="docutils literal"><span class="pre">nil</span></code> ，而 <code
                                  class="docutils literal"><span class="pre">push</span></code> 是 <code
                                  class="docutils literal"><span class="pre">setf</span></code> 的缩写，可以轻松的给哈希表新添一个词条。
                                （有困扰的 <code class="docutils literal"><span class="pre">our-member</span></code> 定义在 16
                                页。）</p>
                              <p>可以用哈希表来取代用列表表示集合。当集合变大时，哈希表的查询与移除会来得比较快。要新增一个成员到用哈希表所表示的集合，把 <code
                                  class="docutils literal"><span class="pre">gethash</span></code> 用 <code
                                  class="docutils literal"><span class="pre">setf</span></code> 设成 <code
                                  class="docutils literal"><span class="pre">t</span></code> ：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre>&gt; (setf fruit (make-hash-table))
#&lt;Hash-Table BFDE76&gt;
&gt; (setf (gethash &#39;apricot fruit) t)
T
</pre>
                                </div>
                              </div>
                              <p>然后要测试是否为成员，你只要调用：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">gethash</span> <span class="ss">&#39;apricot</span> <span class="nv">fruit</span><span class="p">)</span>
<span class="no">T</span>
<span class="no">T</span>
</pre>
                                </div>
                              </div>
                              <p>由于 <code class="docutils literal"><span class="pre">gethash</span></code>
                                缺省返回真，一个新创的哈希表，会很方便地是一个空集合。</p>
                              <p>要从集合中移除一个对象，你可以调用 <code
                                  class="docutils literal"><span class="pre">remhash</span></code> ，它从一个哈希表中移除一个词条：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">remhash</span> <span class="ss">&#39;apricot</span> <span class="nv">fruit</span><span class="p">)</span>
<span class="no">T</span>
</pre>
                                </div>
                              </div>
                              <p>返回值说明了是否有词条被移除；在这个情况里，有。</p>
                              <p>哈希表有一个迭代函数： <code class="docutils literal"><span class="pre">maphash</span></code>
                                ，它接受两个实参，接受两个参数的函数以及哈希表。该函数会被每个键值对调用，没有特定的顺序：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nb">gethash</span> <span class="ss">&#39;shape</span> <span class="nv">ht</span><span class="p">)</span> <span class="ss">&#39;spherical</span>
        <span class="p">(</span><span class="nb">gethash</span> <span class="ss">&#39;size</span> <span class="nv">ht</span><span class="p">)</span> <span class="ss">&#39;giant</span><span class="p">)</span>
<span class="nv">GIANT</span>

<span class="nb">&gt;</span> <span class="p">(</span><span class="nb">maphash</span> <span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">k</span> <span class="nv">v</span><span class="p">)</span>
               <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;~A = ~A~%&quot;</span> <span class="nv">k</span> <span class="nv">v</span><span class="p">))</span>
           <span class="nv">ht</span><span class="p">)</span>
<span class="nv">SHAPE</span> <span class="nb">=</span> <span class="nv">SPHERICAL</span>
<span class="nv">SIZE</span> <span class="nb">=</span> <span class="nv">GIANT</span>
<span class="nv">COLOR</span> <span class="nb">=</span> <span class="nv">RED</span>
<span class="no">NIL</span>
</pre>
                                </div>
                              </div>
                              <p><code class="docutils literal"><span class="pre">maphash</span></code> 总是返回 <code
                                  class="docutils literal"><span class="pre">nil</span></code>
                                ，但你可以通过传入一个会累积数值的函数，把哈希表的词条存在列表里。</p>
                              <p>哈希表可以容纳任何数量的元素，但当哈希表空间用完时，它们会被扩张。如果你想要确保一个哈希表，从特定数量的元素空间大小开始时，可以给 <code
                                  class="docutils literal"><span class="pre">make-hash-table</span></code> 一个选择性的 <code
                                  class="docutils literal"><span class="pre">:size</span></code>
                                关键字参数。做这件事情有两个理由：因为你知道哈希表会变得很大，你想要避免扩张它；或是因为你知道哈希表会是很小，你不想要浪费内存。 <code
                                  class="docutils literal"><span class="pre">:size</span></code>
                                参数不仅指定了哈希表的空间，也指定了元素的数量。平均来说，在被扩张前所能够容纳的数量。所以</p>
                              <p><code
                                  class="docutils literal"><span class="pre">(make-hash-table</span> <span class="pre">:size</span> <span class="pre">5)</span></code>
                              </p>
                              <p>会返回一个预期存放五个元素的哈希表。</p>
                              <p>和任何牵涉到查询的结构一样，哈希表一定有某种比较键值的概念。预设是使用 <code
                                  class="docutils literal"><span class="pre">eql</span></code> ，但你可以提供一个额外的关键字参数 <code
                                  class="docutils literal"><span class="pre">:test</span></code> 来告诉哈希表要使用 <code
                                  class="docutils literal"><span class="pre">eq</span></code> ， <code
                                  class="docutils literal"><span class="pre">equal</span></code> ，还是 <code
                                  class="docutils literal"><span class="pre">equalp</span></code> ：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre>&gt; (setf writers (make-hash-table :test #&#39;equal))
#&lt;Hash-Table C005E6&gt;
&gt; (setf (gethash &#39;(ralph waldo emerson) writers) t)
T
</pre>
                                </div>
                              </div>
                              <p>这是一个让哈希表变得有效率的取舍之一。有了列表，我们可以指定 <code
                                  class="docutils literal"><span class="pre">member</span></code>
                                为判断相等性的谓词。有了哈希表，我们可以预先决定，并在哈希表构造时指定它。</p>
                              <p>大多数 Lisp 编程的取舍（或是生活，就此而论）都有这种特质。起初你想要事情进行得流畅，甚至赔上效率的代价。之后当代码变得沉重时，你牺牲了弹性来换取速度。</p>
                            </div>
                            <div class="section" id="chapter-4-summary">
                              <h4>Chapter 4 总结 (Summary)<a class="headerlink" href="#chapter-4-summary"
                                  title="Permalink to this headline">¶</a></h4>
                              <ol class="arabic simple">
                                <li>Common Lisp 支持至少 7 个维度的数组。一维数组称为向量。</li>
                                <li>字符串是字符的向量。字符本身就是对象。</li>
                                <li>序列包括了向量与列表。许多序列函数都接受标准的关键字参数。</li>
                                <li>处理字符串的函数非常多，所以用 Lisp 来解析字符串是小菜一碟。</li>
                                <li>调用 <code class="docutils literal"><span class="pre">defstruct</span></code>
                                  定义了一个带有命名字段的结构。它是一个程序能写出程序的好例子。</li>
                                <li>二叉搜索树见长于维护一个已排序的对象集合。</li>
                                <li>哈希表提供了一个更有效率的方式来表示集合与映射 (mappings)。</li>
                              </ol>
                            </div>
                            <div class="section" id="chapter-4-exercises">
                              <h4>Chapter 4 习题 (Exercises)<a class="headerlink" href="#chapter-4-exercises"
                                  title="Permalink to this headline">¶</a></h4>
                              <ol class="arabic simple">
                                <li>定义一个函数，接受一个平方数组（square array，一个相同维度的数组 <code
                                    class="docutils literal"><span class="pre">(n</span> <span class="pre">n)</span></code>
                                  )，并将它顺时针转 90 度。</li>
                              </ol>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">quarter-turn</span> <span class="l-Other">#2A</span><span class="p">((</span><span class="nv">a</span> <span class="nv">b</span><span class="p">)</span> <span class="p">(</span><span class="nv">c</span> <span class="nv">d</span><span class="p">)))</span>
<span class="l-Other">#2A</span><span class="p">((</span><span class="nv">C</span> <span class="nv">A</span><span class="p">)</span> <span class="p">(</span><span class="nv">D</span> <span class="nv">B</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p>你会需要用到 361 页的 <code
                                  class="docutils literal"><span class="pre">array-dimensions</span></code> 。</p>
                              <ol class="arabic simple" start="2">
                                <li>阅读 368 页的 <code class="docutils literal"><span class="pre">reduce</span></code>
                                  说明，然后用它来定义：</li>
                              </ol>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre>(a) copy-list
(b) reverse（针对列表）
</pre>
                                </div>
                              </div>
                              <ol class="arabic simple" start="3">
                                <li>定义一个结构来表示一棵树，其中每个节点包含某些数据及三个小孩。定义：</li>
                              </ol>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre>(a) 一个函数来复制这样的树（复制完的节点与本来的节点是不相等（ `eql` ）的）
(b) 一个函数，接受一个对象与这样的树，如果对象与树中各节点的其中一个字段相等时，返回真。
</pre>
                                </div>
                              </div>
                              <ol class="arabic simple" start="4">
                                <li>定义一个函数，接受一棵二叉搜索树，并返回由此树元素所组成的，一个由大至小排序的列表。</li>
                                <li>定义 <code class="docutils literal"><span class="pre">bst-adjoin</span></code> 。这个函数应与
                                  <code class="docutils literal"><span class="pre">bst-insert</span></code>
                                  接受相同的参数，但应该只在对象不等于任何树中对象时将其插入。
                                </li>
                              </ol>
                              <p><strong>勘误:</strong> <code
                                  class="docutils literal"><span class="pre">bst-adjoin</span></code> 的功能与 <code
                                  class="docutils literal"><span class="pre">bst-insert</span></code> 一模一样。</p>
                              <ol class="arabic simple" start="6">
                                <li>任何哈希表的内容可以由关联列表（assoc-list）来描述，其中列表的元素是 <code
                                    class="docutils literal"><span class="pre">(k</span> <span class="pre">.</span> <span class="pre">v)</span></code>
                                  的形式，对应到哈希表中的每一个键值对。定义一个函数：</li>
                              </ol>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre>(a) 接受一个关联列表，并返回一个对应的哈希表。
(b) 接受一个哈希表，并返回一个对应的关联列表。
</pre>
                                </div>
                              </div>
                              <p class="rubric">脚注</p>
                              <table class="docutils footnote" frame="void" id="id5" rules="none">
                                <colgroup>
                                  <col class="label" />
                                  <col />
                                </colgroup>
                                <tbody valign="top">
                                  <tr>
                                    <td class="label"><a class="fn-backref" href="#id2">[1]</a></td>
                                    <td>
                                      一个简单数组大小是不可调整、元素也不可替换的，并不含有填充指针（fill-pointer）。数组缺省是简单的。简单向量是个一维的简单数组，可以含有任何类型的元素。
                                    </td>
                                  </tr>
                                </tbody>
                              </table>
                              <table class="docutils footnote" frame="void" id="id6" rules="none">
                                <colgroup>
                                  <col class="label" />
                                  <col />
                                </colgroup>
                                <tbody valign="top">
                                  <tr>
                                    <td class="label"><a class="fn-backref" href="#id3">[2]</a></td>
                                    <td>在 ANSI Common Lisp 里，你可以给一个 <code
                                        class="docutils literal"><span class="pre">:print-object</span></code>
                                      的关键字参数来取代，它只需要两个实参。也有一個宏叫做 <code
                                        class="docutils literal"><span class="pre">print-unreadable-object</span></code>
                                      ，能用则用，可以用 <code
                                        class="docutils literal"><span class="pre">#&lt;...&gt;</span></code> 的语法来显示对象。
                                    </td>
                                  </tr>
                                </tbody>
                              </table>
                            </div>
                          </div>
                          <div class="section">
                            <h3 id="5">第五章：控制流</h3>
                            <p>2.2 节介绍过 Common Lisp
                              的求值规则，现在你应该很熟悉了。本章的操作符都有一个共同点，就是它们都违反了求值规则。这些操作符让你决定在程序当中何时要求值。如果普通的函数调用是 Lisp
                              程序的树叶的话，那这些操作符就是连结树叶的树枝。</p>
                            <div class="section" id="blocks">
                              <h4>5.1 区块 (Blocks)<a class="headerlink" href="#blocks"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>Common Lisp 有三个构造区块（block）的基本操作符： <code
                                  class="docutils literal"><span class="pre">progn</span></code> 、 <code
                                  class="docutils literal"><span class="pre">block</span></code> 以及 <code
                                  class="docutils literal"><span class="pre">tagbody</span></code> 。我们已经看过 <code
                                  class="docutils literal"><span class="pre">progn</span></code> 了。在 <code
                                  class="docutils literal"><span class="pre">progn</span></code>
                                主体中的表达式会依序求值，并返回最后一个表达式的值：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="k">progn</span>
    <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;a&quot;</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;b&quot;</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">+</span> <span class="mi">11</span> <span class="mi">12</span><span class="p">))</span>
<span class="nv">ab</span>
<span class="mi">23</span>
</pre>
                                </div>
                              </div>
                              <p>由于只返回最后一个表达式的值，代表著使用 <code
                                  class="docutils literal"><span class="pre">progn</span></code> （或任何区块）涵盖了副作用。</p>
                              <p>一个 <code class="docutils literal"><span class="pre">block</span></code> 像是带有名字及紧急出口的
                                <code class="docutils literal"><span class="pre">progn</span></code>
                                。第一个实参应为符号。这成为了区块的名字。在主体中的任何地方，可以停止求值，并通过使用 <code
                                  class="docutils literal"><span class="pre">return-from</span></code> 指定区块的名字，来立即返回数值：
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="k">block</span> <span class="nv">head</span>
    <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;Here we go.&quot;</span><span class="p">)</span>
    <span class="p">(</span><span class="k">return-from</span> <span class="nv">head</span> <span class="ss">&#39;idea</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;We&#39;ll never see this.&quot;</span><span class="p">))</span>
<span class="nv">Here</span> <span class="nv">we</span> <span class="nv">go.</span>
<span class="nv">IDEA</span>
</pre>
                                </div>
                              </div>
                              <p>调用 <code class="docutils literal"><span class="pre">return-from</span></code>
                                允许你的程序，从代码的任何地方，突然但优雅地退出。第二个传给 <code
                                  class="docutils literal"><span class="pre">return-from</span></code>
                                的实参，用来作为以第一个实参为名的区块的返回值。在 <code
                                  class="docutils literal"><span class="pre">return-from</span></code> 之后的表达式不会被求值。</p>
                              <p>也有一个 <code class="docutils literal"><span class="pre">return</span></code>
                                宏，它把传入的参数当做封闭区块 <code class="docutils literal"><span class="pre">nil</span></code> 的返回值：
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="k">block</span> <span class="no">nil</span>
    <span class="p">(</span><span class="nb">return</span> <span class="mi">27</span><span class="p">))</span>
<span class="mi">27</span>
</pre>
                                </div>
                              </div>
                              <p>许多接受一个表达式主体的 Common Lisp 操作符，皆隐含在一个叫做 <code
                                  class="docutils literal"><span class="pre">nil</span></code> 的区块里。比如，所有由 <code
                                  class="docutils literal"><span class="pre">do</span></code> 构造的迭代函数：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">dolist</span> <span class="p">(</span><span class="nv">x</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span> <span class="nv">e</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;~A &quot;</span> <span class="nv">x</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">eql</span> <span class="nv">x</span> <span class="ss">&#39;c</span><span class="p">)</span>
        <span class="p">(</span><span class="nb">return</span> <span class="ss">&#39;done</span><span class="p">)))</span>
<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span>
<span class="nv">DONE</span>
</pre>
                                </div>
                              </div>
                              <p>使用 <code class="docutils literal"><span class="pre">defun</span></code>
                                定义的函数主体，都隐含在一个与函数同名的区块，所以你可以：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">foo</span> <span class="p">()</span>
  <span class="p">(</span><span class="k">return-from</span> <span class="nv">foo</span> <span class="mi">27</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p>在一个显式或隐式的 <code class="docutils literal"><span class="pre">block</span></code> 外，不论是
                                <code class="docutils literal"><span class="pre">return-from</span></code> 或 <code
                                  class="docutils literal"><span class="pre">return</span></code> 都不会工作。
                              </p>
                              <p>使用 <code class="docutils literal"><span class="pre">return-from</span></code>
                                ，我们可以写出一个更好的 <code class="docutils literal"><span class="pre">read-integer</span></code>
                                版本：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">read-integer</span> <span class="p">(</span><span class="nv">str</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">accum</span> <span class="mi">0</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">dotimes</span> <span class="p">(</span><span class="nv">pos</span> <span class="p">(</span><span class="nb">length</span> <span class="nv">str</span><span class="p">))</span>
      <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">i</span> <span class="p">(</span><span class="nb">digit-char-p</span> <span class="p">(</span><span class="nb">char</span> <span class="nv">str</span> <span class="nv">pos</span><span class="p">))))</span>
        <span class="p">(</span><span class="k">if</span> <span class="nv">i</span>
            <span class="p">(</span><span class="nb">setf</span> <span class="nv">accum</span> <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">accum</span> <span class="mi">10</span><span class="p">)</span> <span class="nv">i</span><span class="p">))</span>
            <span class="p">(</span><span class="k">return-from</span> <span class="nv">read-integer</span> <span class="no">nil</span><span class="p">))))</span>
    <span class="nv">accum</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p>68
                                页的版本在构造整数之前，需检查所有的字符。现在两个步骤可以结合，因为如果遇到非数字的字符时，我们可以舍弃计算结果。出现在主体的原子（atom）被解读为标签（labels)；把这样的标签传给
                                <code class="docutils literal"><span class="pre">go</span></code>
                                ，会把控制权交给标签后的表达式。以下是一个非常丑的程序片段，用来印出一至十的数字：
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="k">tagbody</span>
    <span class="p">(</span><span class="nb">setf</span> <span class="nv">x</span> <span class="mi">0</span><span class="p">)</span>
    <span class="nv">top</span>
      <span class="p">(</span><span class="nb">setf</span> <span class="nv">x</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="mi">1</span><span class="p">))</span>
      <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;~A &quot;</span> <span class="nv">x</span><span class="p">)</span>
      <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">&lt;</span> <span class="nv">x</span> <span class="mi">10</span><span class="p">)</span> <span class="p">(</span><span class="k">go</span> <span class="nv">top</span><span class="p">)))</span>
<span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span> <span class="mi">10</span>
<span class="no">NIL</span>
</pre>
                                </div>
                              </div>
                              <p>这个操作符主要用来实现其它的操作符，不是一般会用到的操作符。大多数迭代操作符都隐含在一个 <code
                                  class="docutils literal"><span class="pre">tagbody</span></code>
                                ，所以是可能可以在主体里（虽然很少想要）使用标签及 <code
                                  class="docutils literal"><span class="pre">go</span></code> 。</p>
                              <p>如何决定要使用哪一种区块建构子呢（block construct）？几乎任何时候，你会使用 <code
                                  class="docutils literal"><span class="pre">progn</span></code> 。如果你想要突然退出的话，使用 <code
                                  class="docutils literal"><span class="pre">block</span></code> 来取代。多数程序员永远不会显式地使用
                                <code class="docutils literal"><span class="pre">tagbody</span></code> 。
                              </p>
                            </div>
                            <div class="section" id="context">
                              <h4>5.2 语境 (Context)<a class="headerlink" href="#context"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>另一个我们用来区分表达式的操作符是 <code class="docutils literal"><span class="pre">let</span></code>
                                。它接受一个代码主体，但允许我们在主体内设置新变量：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">x</span> <span class="mi">7</span><span class="p">)</span>
        <span class="p">(</span><span class="nv">y</span> <span class="mi">2</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;Number&quot;</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">))</span>
<span class="nv">Number</span>
<span class="mi">9</span>
</pre>
                                </div>
                              </div>
                              <p>一个像是 <code class="docutils literal"><span class="pre">let</span></code>
                                的操作符，创造出一个新的词法语境（lexical context）。在这个语境里有两个新变量，然而在外部语境的变量也因此变得不可视了。</p>
                              <p>概念上说，一个 <code class="docutils literal"><span class="pre">let</span></code> 表达式等同于函数调用。在
                                2.14 节证明过，函数可以用名字来引用，也可以通过使用一个 lambda 表达式从字面上来引用。由于 lambda 表达式是函数的名字，我们可以像使用函数名那样，把
                                lambda 表达式作为函数调用的第一个实参：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">((</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="mi">1</span><span class="p">))</span> <span class="mi">3</span><span class="p">)</span>
<span class="mi">4</span>
</pre>
                                </div>
                              </div>
                              <p>前述的 <code class="docutils literal"><span class="pre">let</span></code> 表达式，实际上等同于：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">((</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
   <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;Number&quot;</span><span class="p">)</span>
   <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">))</span>
 <span class="mi">7</span>
 <span class="mi">2</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>如果有关于 <code class="docutils literal"><span class="pre">let</span></code>
                                的任何问题，应该是如何把责任交给 <code class="docutils literal"><span class="pre">lambda</span></code>
                                ，因为进入一个 <code class="docutils literal"><span class="pre">let</span></code> 等同于执行一个函数调用。
                              </p>
                              <p>这个模型清楚的告诉我们，由 <code class="docutils literal"><span class="pre">let</span></code>
                                创造的变量的值，不能依赖其它由同一个 <code class="docutils literal"><span class="pre">let</span></code>
                                所创造的变量。举例来说，如果我们试着：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">x</span> <span class="mi">2</span><span class="p">)</span>
      <span class="p">(</span><span class="nv">y</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="mi">1</span><span class="p">)))</span>
  <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p>在 <code
                                  class="docutils literal"><span class="pre">(+</span> <span class="pre">x</span> <span class="pre">1)</span></code>
                                中的 <code class="docutils literal"><span class="pre">x</span></code>
                                不是前一行所设置的值，因为整个表达式等同于：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">((</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">))</span> <span class="mi">2</span>
                        <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="mi">1</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p>这里明显看到 <code
                                  class="docutils literal"><span class="pre">(+</span> <span class="pre">x</span> <span class="pre">1)</span></code>
                                作为实参传给函数，不能引用函数内的形参 <code class="docutils literal"><span class="pre">x</span></code> 。
                              </p>
                              <p>所以如果你真的想要新变量的值，依赖同一个表达式所设立的另一个变量？在这个情况下，使用一个变形版本 <code
                                  class="docutils literal"><span class="pre">let*</span></code> ：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="k">let*</span> <span class="p">((</span><span class="nv">x</span> <span class="mi">1</span><span class="p">)</span>
         <span class="p">(</span><span class="nv">y</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="mi">1</span><span class="p">)))</span>
    <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">))</span>
<span class="mi">3</span>
</pre>
                                </div>
                              </div>
                              <p>一个 <code class="docutils literal"><span class="pre">let*</span></code> 功能上等同于一系列嵌套的
                                <code class="docutils literal"><span class="pre">let</span></code> 。这个特别的例子等同于：
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">x</span> <span class="mi">1</span><span class="p">))</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">y</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="mi">1</span><span class="p">)))</span>
    <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)))</span>
</pre>
                                </div>
                              </div>
                              <p><code class="docutils literal"><span class="pre">let</span></code> 与 <code
                                  class="docutils literal"><span class="pre">let*</span></code> 将变量初始值都设为 <code
                                  class="docutils literal"><span class="pre">nil</span></code> 。<code
                                  class="docutils literal"><span class="pre">nil</span></code> 为初始值的变量，不需要依附在列表内:</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="k">let</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">list</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">))</span>
<span class="p">(</span><span class="no">NIL</span> <span class="no">NIL</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p><code class="docutils literal"><span class="pre">destructuring-bind</span></code>
                                宏是通用化的 <code class="docutils literal"><span class="pre">let</span></code> 。其接受单一变量，一个模式
                                (pattern) ── 一个或多个变量所构成的树 ── 并将它们与某个实际的树所对应的部份做绑定。举例来说：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">destructuring-bind</span> <span class="p">(</span><span class="nv">w</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span> <span class="o">.</span> <span class="nv">z</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="p">(</span><span class="nv">b</span> <span class="nv">c</span><span class="p">)</span> <span class="nv">d</span> <span class="nv">e</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">list</span> <span class="nv">w</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span><span class="p">))</span>
<span class="p">(</span><span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="p">(</span><span class="nv">D</span> <span class="nv">E</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p>若给定的树（第二个实参）没有与模式匹配（第一个参数）时，会产生错误。</p>
                            </div>
                            <div class="section" id="conditionals">
                              <h4>5.3 条件 (Conditionals)<a class="headerlink" href="#conditionals"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>最简单的条件式是 <code class="docutils literal"><span class="pre">if</span></code> ；其余的条件式都是基于
                                <code class="docutils literal"><span class="pre">if</span></code> 所构造的。第二简单的条件式是 <code
                                  class="docutils literal"><span class="pre">when</span></code> ，它接受一个测试表达式（test
                                expression）与一个代码主体。若测试表达式求值返回真时，则对主体求值。所以
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">when</span> <span class="p">(</span><span class="nb">oddp</span> <span class="nv">that</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;Hmm, that&#39;s odd.&quot;</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">+</span> <span class="nv">that</span> <span class="mi">1</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p>等同于</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">oddp</span> <span class="nv">that</span><span class="p">)</span>
    <span class="p">(</span><span class="k">progn</span>
      <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;Hmm, that&#39;s odd.&quot;</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">+</span> <span class="nv">that</span> <span class="mi">1</span><span class="p">)))</span>
</pre>
                                </div>
                              </div>
                              <p><code class="docutils literal"><span class="pre">when</span></code> 的相反是 <code
                                  class="docutils literal"><span class="pre">unless</span></code>
                                ；它接受相同的实参，但仅在测试表达式返回假时，才对主体求值。</p>
                              <p>所有条件式的母体 (从正反两面看) 是 <code class="docutils literal"><span class="pre">cond</span></code>
                                ， <code class="docutils literal"><span class="pre">cond</span></code>
                                有两个新的优点：允许多个条件判断，与每个条件相关的代码隐含在 <code
                                  class="docutils literal"><span class="pre">progn</span></code> 里。 <code
                                  class="docutils literal"><span class="pre">cond</span></code> 预期在我们需要使用嵌套 <code
                                  class="docutils literal"><span class="pre">if</span></code> 的情况下使用。 举例来说，这个伪 member 函数
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">our-member</span> <span class="p">(</span><span class="nv">obj</span> <span class="nv">lst</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">atom</span> <span class="nv">lst</span><span class="p">)</span>
      <span class="no">nil</span>
      <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">eql</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">lst</span><span class="p">)</span> <span class="nv">obj</span><span class="p">)</span>
          <span class="nv">lst</span>
          <span class="p">(</span><span class="nv">our-member</span> <span class="nv">obj</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">lst</span><span class="p">)))))</span>
</pre>
                                </div>
                              </div>
                              <p>也可以定义成：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">our-member</span> <span class="p">(</span><span class="nv">obj</span> <span class="nv">lst</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nb">atom</span> <span class="nv">lst</span><span class="p">)</span> <span class="no">nil</span><span class="p">)</span>
        <span class="p">((</span><span class="nb">eql</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">lst</span><span class="p">)</span> <span class="nv">obj</span><span class="p">)</span> <span class="nv">lst</span><span class="p">)</span>
        <span class="p">(</span><span class="no">t</span> <span class="p">(</span><span class="nv">our-member</span> <span class="nv">obj</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">lst</span><span class="p">)))))</span>
</pre>
                                </div>
                              </div>
                              <p>事实上，Common Lisp 实现大概会把 <code
                                  class="docutils literal"><span class="pre">cond</span></code> 翻译成 <code
                                  class="docutils literal"><span class="pre">if</span></code> 的形式。</p>
                              <p>总得来说呢， <code class="docutils literal"><span class="pre">cond</span></code>
                                接受零个或多个实参。每一个实参必须是一个具有条件式，伴随着零个或多个表达式的列表。当 <code
                                  class="docutils literal"><span class="pre">cond</span></code>
                                表达式被求值时，测试条件式依序求值，直到某个测试条件式返回真才停止。当返回真时，与其相关联的表达式会被依序求值，而最后一个返回的数值，会作为 <code
                                  class="docutils literal"><span class="pre">cond</span></code> 的返回值。如果符合的条件式之后没有表达式的话：
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">cond</span> <span class="p">(</span><span class="mi">99</span><span class="p">))</span>
<span class="mi">99</span>
</pre>
                                </div>
                              </div>
                              <p>则会返回条件式的值。</p>
                              <p>由于 <code class="docutils literal"><span class="pre">cond</span></code> 子句的 <code
                                  class="docutils literal"><span class="pre">t</span></code>
                                条件永远成立，通常我们把它放在最后，作为缺省的条件式。如果没有子句符合时，则 <code
                                  class="docutils literal"><span class="pre">cond</span></code> 返回 <code
                                  class="docutils literal"><span class="pre">nil</span></code> ，但利用 <code
                                  class="docutils literal"><span class="pre">nil</span></code> 作为返回值是一种很差的风格
                                (这种问题可能发生的例子，请看 292 页)。译注: <strong>Appendix A, unexpected nil</strong> 小节。</p>
                              <p>当你想要把一个数值与一系列的常量比较时，有 <code
                                  class="docutils literal"><span class="pre">case</span></code> 可以用。我们可以使用 <code
                                  class="docutils literal"><span class="pre">case</span></code> 来定义一个函数，返回每个月份中的天数：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">month-length</span> <span class="p">(</span><span class="nv">mon</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">case</span> <span class="nv">mon</span>
    <span class="p">((</span><span class="nv">jan</span> <span class="nv">mar</span> <span class="nv">may</span> <span class="nv">jul</span> <span class="nv">aug</span> <span class="nv">oct</span> <span class="nv">dec</span><span class="p">)</span> <span class="mi">31</span><span class="p">)</span>
    <span class="p">((</span><span class="nv">apr</span> <span class="nv">jun</span> <span class="nv">sept</span> <span class="nv">nov</span><span class="p">)</span> <span class="mi">30</span><span class="p">)</span>
    <span class="p">(</span><span class="nv">feb</span> <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nv">leap-year</span><span class="p">)</span> <span class="mi">29</span> <span class="mi">28</span><span class="p">))</span>
    <span class="p">(</span><span class="nv">otherwise</span> <span class="s">&quot;unknown month&quot;</span><span class="p">)))</span>
</pre>
                                </div>
                              </div>
                              <p>一个 <code class="docutils literal"><span class="pre">case</span></code>
                                表达式由一个实参开始，此实参会被拿来与每个子句的键值做比较。接着是零个或多个子句，每个子句由一个或一串键值开始，跟随着零个或多个表达式。键值被视为常量；它们不会被求值。第一个参数的值被拿来与子句中的键值做比较
                                (使用 <code class="docutils literal"><span class="pre">eql</span></code>
                                )。如果匹配时，子句剩余的表达式会被求值，并将最后一个求值作为 <code
                                  class="docutils literal"><span class="pre">case</span></code> 的返回值。</p>
                              <p>缺省子句的键值可以是 <code class="docutils literal"><span class="pre">t</span></code> 或 <code
                                  class="docutils literal"><span class="pre">otherwise</span></code>
                                。如果没有子句符合时，或是子句只包含键值时，</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">case</span> <span class="mi">99</span> <span class="p">(</span><span class="mi">99</span><span class="p">))</span>
<span class="no">NIL</span>
</pre>
                                </div>
                              </div>
                              <p>则 <code class="docutils literal"><span class="pre">case</span></code> 返回 <code
                                  class="docutils literal"><span class="pre">nil</span></code> 。</p>
                              <p><code class="docutils literal"><span class="pre">typecase</span></code> 宏与 <code
                                  class="docutils literal"><span class="pre">case</span></code> 相似，除了每个子句中的键值应为类型修饰符
                                (type specifiers)，以及第一个实参与键值比较的函数使用 <code
                                  class="docutils literal"><span class="pre">typep</span></code> 而不是 <code
                                  class="docutils literal"><span class="pre">eql</span></code> (一个 <code
                                  class="docutils literal"><span class="pre">typecase</span></code> 的例子在 107 页)。
                                <strong>译注: 6.5 小节。</strong>
                              </p>
                            </div>
                            <div class="section" id="iteration">
                              <h4>5.4 迭代 (Iteration)<a class="headerlink" href="#iteration"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>最基本的迭代操作符是 <code class="docutils literal"><span class="pre">do</span></code> ，在 2.13
                                小节介绍过。由于 <code class="docutils literal"><span class="pre">do</span></code> 包含了隐式的 <code
                                  class="docutils literal"><span class="pre">block</span></code> 及 <code
                                  class="docutils literal"><span class="pre">tagbody</span></code> ，我们现在知道是可以在 <code
                                  class="docutils literal"><span class="pre">do</span></code> 主体内使用 <code
                                  class="docutils literal"><span class="pre">return</span></code> 、 <code
                                  class="docutils literal"><span class="pre">return-from</span></code> 以及 <code
                                  class="docutils literal"><span class="pre">go</span></code> 。</p>
                              <p>2.13 节提到 <code class="docutils literal"><span class="pre">do</span></code>
                                的第一个参数必须是说明变量规格的列表，列表可以是如下形式：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nv">variable</span>  <span class="nv">initial</span>  <span class="nv">update</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p><code class="docutils literal"><span class="pre">initial</span></code> 与 <code
                                  class="docutils literal"><span class="pre">update</span></code> 形式是选择性的。若 <code
                                  class="docutils literal"><span class="pre">update</span></code> 形式忽略时，每次迭代时不会更新变量。若
                                <code class="docutils literal"><span class="pre">initial</span></code> 形式也忽略时，变量会使用
                                <code class="docutils literal"><span class="pre">nil</span></code> 来初始化。
                              </p>
                              <p>在 23 页的例子中（译注: 2.13 节），</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">show-squares</span> <span class="p">(</span><span class="nv">start</span> <span class="nv">end</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">do</span> <span class="p">((</span><span class="nv">i</span> <span class="nv">start</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">i</span> <span class="mi">1</span><span class="p">)))</span>
      <span class="p">((</span><span class="nb">&gt;</span> <span class="nv">i</span> <span class="nv">end</span><span class="p">)</span> <span class="ss">&#39;done</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;~A ~A~%&quot;</span> <span class="nv">i</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">i</span> <span class="nv">i</span><span class="p">))))</span>
</pre>
                                </div>
                              </div>
                              <p><code class="docutils literal"><span class="pre">update</span></code> 形式引用到由 <code
                                  class="docutils literal"><span class="pre">do</span></code> 所创造的变量。一般都是这么用。如果一个 <code
                                  class="docutils literal"><span class="pre">do</span></code> 的 <code
                                  class="docutils literal"><span class="pre">update</span></code> 形式，没有至少引用到一个 <code
                                  class="docutils literal"><span class="pre">do</span></code> 创建的变量时，反而很奇怪。</p>
                              <p>当同时更新超过一个变量时，问题来了，如果一个 <code
                                  class="docutils literal"><span class="pre">update</span></code> 形式，引用到一个拥有自己的 <code
                                  class="docutils literal"><span class="pre">update</span></code>
                                形式的变量时，它会被更新呢？或是获得前一次迭代的值？使用 <code
                                  class="docutils literal"><span class="pre">do</span></code> 的话，它获得后者的值：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">x</span> <span class="ss">&#39;a</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">do</span> <span class="p">((</span><span class="nv">x</span> <span class="mi">1</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="mi">1</span><span class="p">))</span>
         <span class="p">(</span><span class="nv">y</span> <span class="nv">x</span> <span class="nv">x</span><span class="p">))</span>
        <span class="p">((</span><span class="nb">&gt;</span> <span class="nv">x</span> <span class="mi">5</span><span class="p">))</span>
      <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;(~A ~A)  &quot;</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)))</span>
<span class="p">(</span><span class="mi">1</span> <span class="nv">A</span><span class="p">)</span>  <span class="p">(</span><span class="mi">2</span> <span class="mi">1</span><span class="p">)</span>  <span class="p">(</span><span class="mi">3</span> <span class="mi">2</span><span class="p">)</span>  <span class="p">(</span><span class="mi">4</span> <span class="mi">3</span><span class="p">)</span>  <span class="p">(</span><span class="mi">5</span> <span class="mi">4</span><span class="p">)</span>
<span class="no">NIL</span>
</pre>
                                </div>
                              </div>
                              <p>每一次迭代时， <code class="docutils literal"><span class="pre">x</span></code> 获得先前的值，加上一；
                                <code class="docutils literal"><span class="pre">y</span></code> 也获得 <code
                                  class="docutils literal"><span class="pre">x</span></code> 的前一次数值。
                              </p>
                              <p>但也有一个 <code class="docutils literal"><span class="pre">do*</span></code> ，它有着和 <code
                                  class="docutils literal"><span class="pre">let</span></code> 与 <code
                                  class="docutils literal"><span class="pre">let*</span></code> 一样的关系。任何 <code
                                  class="docutils literal"><span class="pre">initial</span></code> 或 <code
                                  class="docutils literal"><span class="pre">update</span></code>
                                形式可以参照到前一个子句的变量，并会获得当下的值：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">do*</span> <span class="p">((</span><span class="nv">x</span> <span class="mi">1</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="mi">1</span><span class="p">))</span>
      <span class="p">(</span><span class="nv">y</span> <span class="nv">x</span> <span class="nv">x</span><span class="p">))</span>
     <span class="p">((</span><span class="nb">&gt;</span> <span class="nv">x</span> <span class="mi">5</span><span class="p">))</span>
  <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;(~A ~A) &quot;</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">))</span>
<span class="p">(</span><span class="mi">1</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="mi">2</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="mi">3</span> <span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="mi">4</span> <span class="mi">4</span><span class="p">)</span> <span class="p">(</span><span class="mi">5</span> <span class="mi">5</span><span class="p">)</span>
<span class="no">NIL</span>
</pre>
                                </div>
                              </div>
                              <p>除了 <code class="docutils literal"><span class="pre">do</span></code> 与 <code
                                  class="docutils literal"><span class="pre">do*</span></code>
                                之外，也有几个特别用途的迭代操作符。要迭代一个列表的元素，我们可以使用 <code
                                  class="docutils literal"><span class="pre">dolist</span></code> :</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">dolist</span> <span class="p">(</span><span class="nv">x</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span><span class="p">)</span> <span class="ss">&#39;done</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;~A &quot;</span> <span class="nv">x</span><span class="p">))</span>
<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="nv">D</span>
<span class="nv">DONE</span>
</pre>
                                </div>
                              </div>
                              <p>当迭代结束时，初始列表内的第三个表达式 (译注: <code
                                  class="docutils literal"><span class="pre">done</span></code> ) ，会被求值并作为 <code
                                  class="docutils literal"><span class="pre">dolist</span></code> 的返回值。缺省是 <code
                                  class="docutils literal"><span class="pre">nil</span></code> 。</p>
                              <p>有着同样的精神的是 <code class="docutils literal"><span class="pre">dotimes</span></code> ，给定某个
                                <code class="docutils literal"><span class="pre">n</span></code> ，将会从整数 <code
                                  class="docutils literal"><span class="pre">0</span></code> ，迭代至 <code
                                  class="docutils literal"><span class="pre">n-1</span></code> :
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">dotimes</span> <span class="p">(</span><span class="nv">x</span> <span class="mi">5</span> <span class="nv">x</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;~A &quot;</span> <span class="nv">x</span><span class="p">))</span>
<span class="mi">0</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span>
<span class="mi">5</span>
</pre>
                                </div>
                              </div>
                              <p><code class="docutils literal"><span class="pre">dolist</span></code> 与 <code
                                  class="docutils literal"><span class="pre">dotimes</span> <span class="pre">初始列表的第三个表达式皆可省略，省略时为</span> <span class="pre">``nil</span></code>
                                。注意该表达式可引用到迭代过程中的变量。</p>
                              <p>（译注：第三个表达式即上例之 <code class="docutils literal"><span class="pre">x</span></code>
                                ，可以省略，省略时 <code class="docutils literal"><span class="pre">dotimes</span></code>
                                表达式的返回值为 <code class="docutils literal"><span class="pre">nil</span></code> 。）</p>
                              <div class="admonition note">
                                <p class="first admonition-title">Note</p>
                                <p>do 的重点 (THE POINT OF do)</p>
                                <p>在 “The Evolution of Lisp” 里，Steele 与 Garbriel 陈述了 do 的重点，
                                  表达的实在太好了，值得整个在这里引用过来：</p>
                                <p>撇开争论语法不谈，有件事要说明的是，在任何一个编程语言中，一个循环若一次只能更新一个变量是毫无用处的。
                                  几乎在任何情况下，会有一个变量用来产生下个值，而另一个变量用来累积结果。如果循环语法只能产生变量，
                                  那么累积结果就得借由赋值语句来“手动”实现…或有其他的副作用。具有多变量的 do 循环，体现了产生与累积的本质对称性，允许可以无副作用地表达迭代过程：</p>
                                <div class="highlight-cl">
                                  <div class="highlight">
                                    <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">factorial</span> <span class="p">(</span><span class="nv">n</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">do</span> <span class="p">((</span><span class="nv">j</span> <span class="nv">n</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">j</span> <span class="mi">1</span><span class="p">))</span>
       <span class="p">(</span><span class="nv">f</span> <span class="mi">1</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">j</span> <span class="nv">f</span><span class="p">)))</span>
    <span class="p">((</span><span class="nb">=</span> <span class="nv">j</span> <span class="mi">0</span><span class="p">)</span> <span class="nv">f</span><span class="p">)))</span>
</pre>
                                  </div>
                                </div>
                                <p class="last">当然在 step 形式里实现所有的实际工作，一个没有主体的 do 循环形式是较不寻常的。</p>
                              </div>
                              <p>函数 <code class="docutils literal"><span class="pre">mapc</span></code> 和 <code
                                  class="docutils literal"><span class="pre">mapcar</span></code> 很像，但不会 <code
                                  class="docutils literal"><span class="pre">cons</span></code>
                                一个新列表作为返回值，所以使用的唯一理由是为了副作用。它们比 <code
                                  class="docutils literal"><span class="pre">dolist</span></code> 来得灵活，因为可以同时遍历多个列表：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">mapc</span> <span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
          <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;~A ~A  &quot;</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">))</span>
      <span class="o">&#39;</span><span class="p">(</span><span class="nv">hip</span> <span class="nv">flip</span> <span class="nv">slip</span><span class="p">)</span>
      <span class="o">&#39;</span><span class="p">(</span><span class="nv">hop</span> <span class="nv">flop</span> <span class="nv">slop</span><span class="p">))</span>
<span class="nv">HIP</span> <span class="nv">HOP</span>  <span class="nv">FLIP</span> <span class="nv">FLOP</span>  <span class="nv">SLIP</span> <span class="nv">SLOP</span>
<span class="p">(</span><span class="nv">HIP</span> <span class="nv">FLIP</span> <span class="nv">SLIP</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>总是返回 <code class="docutils literal"><span class="pre">mapc</span></code> 的第二个参数。</p>
                            </div>
                            <div class="section" id="multiple-values">
                              <h4>5.5 多值 (Multiple Values)<a class="headerlink" href="#multiple-values"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>曾有人这么说，为了要强调函数式编程的重要性，每个 Lisp 表达式都返回一个值。现在事情不是这么简单了；在 Common Lisp
                                里，一个表达式可以返回零个或多个数值。最多可以返回几个值取决于各家实现，但至少可以返回 19 个值。</p>
                              <p>多值允许一个函数返回多件事情的计算结果，而不用构造一个特定的结构。举例来说，内置的 <code
                                  class="docutils literal"><span class="pre">get-decoded-time</span></code> 返回 9
                                个数值来表示现在的时间：秒，分，时，日期，月，年，天，以及另外两个数值。</p>
                              <p>多值也使得查询函数可以分辨出 <code class="docutils literal"><span class="pre">nil</span></code>
                                与查询失败的情况。这也是为什么 <code class="docutils literal"><span class="pre">gethash</span></code>
                                返回两个值。因为它使用第二个数值来指出成功还是失败，我们可以在哈希表里储存 <code
                                  class="docutils literal"><span class="pre">nil</span></code> ，就像我们可以储存别的数值那样。</p>
                              <p><code class="docutils literal"><span class="pre">values</span></code>
                                函数返回多个数值。它一个不少地返回你作为数值所传入的实参：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">values</span> <span class="ss">&#39;a</span> <span class="no">nil</span> <span class="p">(</span><span class="nb">+</span> <span class="mi">2</span> <span class="mi">4</span><span class="p">))</span>
<span class="nv">A</span>
<span class="no">NIL</span>
<span class="mi">6</span>
</pre>
                                </div>
                              </div>
                              <p>如果一个 <code class="docutils literal"><span class="pre">values</span></code>
                                表达式，是函数主体最后求值的表达式，它所返回的数值变成函数的返回值。多值可以原封不地通过任何数量的返回来传递：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">((</span><span class="k">lambda</span> <span class="p">()</span> <span class="p">((</span><span class="k">lambda</span> <span class="p">()</span> <span class="p">(</span><span class="nb">values</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">)))))</span>
<span class="mi">1</span>
<span class="mi">2</span>
</pre>
                                </div>
                              </div>
                              <p>然而若只预期一个返回值时，第一个之外的值会被舍弃：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">x</span> <span class="p">(</span><span class="nb">values</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">)))</span>
    <span class="nv">x</span><span class="p">)</span>
<span class="mi">1</span>
</pre>
                                </div>
                              </div>
                              <p>通过不带实参使用 <code class="docutils literal"><span class="pre">values</span></code>
                                ，是可能不返回值的。在这个情况下，预期一个返回值的话，会获得 <code
                                  class="docutils literal"><span class="pre">nil</span></code> :</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">values</span><span class="p">)</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">x</span> <span class="p">(</span><span class="nb">values</span><span class="p">)))</span>
    <span class="nv">x</span><span class="p">)</span>
<span class="no">NIL</span>
</pre>
                                </div>
                              </div>
                              <p>要接收多个数值，我们使用 <code
                                  class="docutils literal"><span class="pre">multiple-value-bind</span></code> :</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">multiple-value-bind</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span><span class="p">)</span> <span class="p">(</span><span class="nb">values</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">list</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span><span class="p">))</span>
<span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span>

<span class="nb">&gt;</span> <span class="p">(</span><span class="nb">multiple-value-bind</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span><span class="p">)</span> <span class="p">(</span><span class="nb">values</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">list</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span><span class="p">))</span>
<span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="no">NIL</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>如果变量的数量大于数值的数量，剩余的变量会是 <code
                                  class="docutils literal"><span class="pre">nil</span></code>
                                。如果数值的数量大于变量的数量，多余的值会被舍弃。所以只想印出时间我们可以这么写:</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">multiple-value-bind</span> <span class="p">(</span><span class="nv">s</span> <span class="nv">m</span> <span class="nv">h</span><span class="p">)</span> <span class="p">(</span><span class="nb">get-decoded-time</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;~A:~A:~A&quot;</span> <span class="nv">h</span> <span class="nv">m</span> <span class="nv">s</span><span class="p">))</span>
<span class="s">&quot;4:32:13&quot;</span>
</pre>
                                </div>
                              </div>
                              <p>你可以借由 <code
                                  class="docutils literal"><span class="pre">multiple-value-call</span></code>
                                将多值作为实参传给第二个函数：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="k">multiple-value-call</span> <span class="nf">#&#39;</span><span class="nb">+</span> <span class="p">(</span><span class="nb">values</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">))</span>
<span class="mi">6</span>
</pre>
                                </div>
                              </div>
                              <p>还有一个函数是 <code
                                  class="docutils literal"><span class="pre">multiple-value-list</span></code> :</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">multiple-value-list</span> <span class="p">(</span><span class="nb">values</span> <span class="ss">&#39;a</span> <span class="ss">&#39;b</span> <span class="ss">&#39;c</span><span class="p">))</span>
<span class="p">(</span><span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>看起来像是使用 <code class="docutils literal"><span class="pre">#'list</span></code>
                                作为第一个参数的来调用 <code
                                  class="docutils literal"><span class="pre">multiple-value-call</span></code> 。</p>
                            </div>
                            <div class="section" id="aborts">
                              <h4>5.6 中止 (Aborts)<a class="headerlink" href="#aborts"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>你可以使用 <code class="docutils literal"><span class="pre">return</span></code> 在任何时候离开一个
                                <code class="docutils literal"><span class="pre">block</span></code>
                                。有时候我们想要做更极端的事，在数个函数调用里将控制权转移回来。要达成这件事，我们使用 <code
                                  class="docutils literal"><span class="pre">catch</span></code> 与 <code
                                  class="docutils literal"><span class="pre">throw</span></code> 。一个 <code
                                  class="docutils literal"><span class="pre">catch</span></code>
                                表达式接受一个标签（tag），标签可以是任何类型的对象，伴随着一个表达式主体：
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">super</span> <span class="p">()</span>
  <span class="p">(</span><span class="k">catch</span> <span class="ss">&#39;abort</span>
    <span class="p">(</span><span class="nv">sub</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;We&#39;ll never see this.&quot;</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">sub</span> <span class="p">()</span>
  <span class="p">(</span><span class="k">throw</span> <span class="ss">&#39;abort</span> <span class="mi">99</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p>表达式依序求值，就像它们是在 <code class="docutils literal"><span class="pre">progn</span></code>
                                里一样。在这段代码里的任何地方，一个带有特定标签的 <code
                                  class="docutils literal"><span class="pre">throw</span></code> 会导致 <code
                                  class="docutils literal"><span class="pre">catch</span></code> 表达式直接返回：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">super</span><span class="p">)</span>
<span class="mi">99</span>
</pre>
                                </div>
                              </div>
                              <p>一个带有给定标签的 <code class="docutils literal"><span class="pre">throw</span></code>
                                ，为了要到达匹配标签的 <code class="docutils literal"><span class="pre">catch</span></code>
                                ，会将控制权转移 (因此杀掉进程)给任何有标签的 <code
                                  class="docutils literal"><span class="pre">catch</span></code> 。如果没有一个 <code
                                  class="docutils literal"><span class="pre">catch</span></code> 符合欲匹配的标签时， <code
                                  class="docutils literal"><span class="pre">throw</span></code> 会产生一个错误。</p>
                              <p>调用 <code class="docutils literal"><span class="pre">error</span></code>
                                同时中断了执行，本来会将控制权转移到调用树（calling tree）的更高点，取而代之的是，它将控制权转移给 Lisp 错误处理器（error
                                handler）。通常会导致调用一个中断循环（break loop）。以下是一个假定的 Common Lisp 实现可能会发生的事情：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="k">progn</span>
    <span class="p">(</span><span class="nb">error</span> <span class="s">&quot;Oops!&quot;</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;After the error.&quot;</span><span class="p">))</span>
<span class="nv">Error:</span> <span class="nv">Oops!</span>
       <span class="nv">Options:</span> <span class="ss">:abort,</span> <span class="ss">:backtrace</span>
<span class="nv">&gt;&gt;</span>
</pre>
                                </div>
                              </div>
                              <p>译注：2 个 <code class="docutils literal"><span class="pre">&gt;&gt;</span></code>
                                显示进入中断循环了。</p>
                              <p>关于错误与状态的更多讯息，参见 14.6 小节以及附录 A。</p>
                              <p>有时候你想要防止代码被 <code class="docutils literal"><span class="pre">throw</span></code> 与
                                <code class="docutils literal"><span class="pre">error</span></code> 打断。借由使用 <code
                                  class="docutils literal"><span class="pre">unwind-protect</span></code>
                                ，可以确保像是前述的中断，不会让你的程序停在不一致的状态。一个 <code
                                  class="docutils literal"><span class="pre">unwind-protect</span></code>
                                接受任何数量的实参，并返回第一个实参的值。然而即便是第一个实参的求值被打断时，剩下的表达式仍会被求值：
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">setf</span> <span class="nv">x</span> <span class="mi">1</span><span class="p">)</span>
<span class="mi">1</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="k">catch</span> <span class="ss">&#39;abort</span>
    <span class="p">(</span><span class="k">unwind-protect</span>
      <span class="p">(</span><span class="k">throw</span> <span class="ss">&#39;abort</span> <span class="mi">99</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">setf</span> <span class="nv">x</span> <span class="mi">2</span><span class="p">)))</span>
<span class="mi">99</span>
<span class="nb">&gt;</span> <span class="nv">x</span>
<span class="mi">2</span>
</pre>
                                </div>
                              </div>
                              <p>在这里，即便 <code class="docutils literal"><span class="pre">throw</span></code> 将控制权交回监测的
                                <code class="docutils literal"><span class="pre">catch</span></code> ， <code
                                  class="docutils literal"><span class="pre">unwind-protect</span></code>
                                确保控制权移交时，第二个表达式有被求值。无论何时，一个确切的动作要伴随着某种清理或重置时， <code
                                  class="docutils literal"><span class="pre">unwind-protect</span></code> 可能会派上用场。在 121
                                页提到了一个例子。
                              </p>
                            </div>
                            <div class="section" id="example-date-arithmetic">
                              <h4>5.7 示例：日期运算 (Example: Date Arithmetic)<a class="headerlink"
                                  href="#example-date-arithmetic" title="Permalink to this headline">¶</a></h4>
                              <p>在某些应用里，能够做日期的加减是很有用的 ── 举例来说，能够算出从 1997 年 12 月 17 日，六十天之后是 1998 年 2 月 15
                                日。在这个小节里，我们会编写一个实用的工具来做日期运算。我们会将日期转成整数，起始点设置在 2000 年 1 月 1 日。我们会使用内置的 <code
                                  class="docutils literal"><span class="pre">+</span></code> 与 <code
                                  class="docutils literal"><span class="pre">-</span></code>
                                函数来处理这些数字，而当我们转换完毕时，再将结果转回日期。</p>
                              <p>要将日期转成数字，我们需要从日期的单位中，算出总天数有多少。举例来说，2004 年 11 月 13 日的天数总和，是从起始点至 2004 年有多少天，加上从 2004 年到
                                2004 年 11 月有多少天，再加上 13 天。</p>
                              <p>有一个我们会需要的东西是，一张列出非润年每月份有多少天的表格。我们可以使用 Lisp 来推敲出这个表格的内容。我们从列出每月份的长度开始：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">setf</span> <span class="nv">mon</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">31</span> <span class="mi">28</span> <span class="mi">31</span> <span class="mi">30</span> <span class="mi">31</span> <span class="mi">30</span> <span class="mi">31</span> <span class="mi">31</span> <span class="mi">30</span> <span class="mi">31</span> <span class="mi">30</span> <span class="mi">31</span><span class="p">))</span>
<span class="p">(</span><span class="mi">31</span> <span class="mi">28</span> <span class="mi">31</span> <span class="mi">30</span> <span class="mi">31</span> <span class="mi">30</span> <span class="mi">31</span> <span class="mi">31</span> <span class="mi">30</span> <span class="mi">31</span> <span class="mi">30</span> <span class="mi">31</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>我们可以通过应用 <code class="docutils literal"><span class="pre">+</span></code>
                                函数至这个列表来测试总长度：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">apply</span> <span class="nf">#&#39;</span><span class="nb">+</span> <span class="nv">mon</span><span class="p">)</span>
<span class="mi">365</span>
</pre>
                                </div>
                              </div>
                              <p>现在如果我们反转这个列表并使用 <code class="docutils literal"><span class="pre">maplist</span></code>
                                来应用 <code class="docutils literal"><span class="pre">+</span></code> 函数至每下一个 <code
                                  class="docutils literal"><span class="pre">cdr</span></code> 上，我们可以获得从每个月份开始所累积的天数：
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">setf</span> <span class="nv">nom</span> <span class="p">(</span><span class="nb">reverse</span> <span class="nv">mon</span><span class="p">))</span>
<span class="p">(</span><span class="mi">31</span> <span class="mi">30</span> <span class="mi">31</span> <span class="mi">30</span> <span class="mi">31</span> <span class="mi">31</span> <span class="mi">30</span> <span class="mi">31</span> <span class="mi">30</span> <span class="mi">31</span> <span class="mi">28</span> <span class="mi">31</span><span class="p">)</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="nb">setf</span> <span class="nv">sums</span> <span class="p">(</span><span class="nb">maplist</span> <span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span>
                          <span class="p">(</span><span class="nb">apply</span> <span class="nf">#&#39;</span><span class="nb">+</span> <span class="nv">x</span><span class="p">))</span>
                      <span class="nv">nom</span><span class="p">))</span>
<span class="p">(</span><span class="mi">365</span> <span class="mi">334</span> <span class="mi">304</span> <span class="mi">273</span> <span class="mi">243</span> <span class="mi">212</span> <span class="mi">181</span> <span class="mi">151</span> <span class="mi">120</span> <span class="mi">90</span> <span class="mi">59</span> <span class="mi">31</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>这些数字体现了从二月一号开始已经过了 31 天，从三月一号开始已经过了 59 天……等等。</p>
                              <p>我们刚刚建立的这个列表，可以转换成一个向量，见图 5.1，转换日期至整数的代码。</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defconstant</span> <span class="nv">month</span>
  <span class="o">#(</span><span class="mi">0</span> <span class="mi">31</span> <span class="mi">59</span> <span class="mi">90</span> <span class="mi">120</span> <span class="mi">151</span> <span class="mi">181</span> <span class="mi">212</span> <span class="mi">243</span> <span class="mi">273</span> <span class="mi">304</span> <span class="mi">334</span> <span class="mi">365</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defconstant</span> <span class="nv">yzero</span> <span class="mi">2000</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">leap?</span> <span class="p">(</span><span class="nv">y</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nb">zerop</span> <span class="p">(</span><span class="nb">mod</span> <span class="nv">y</span> <span class="mi">4</span><span class="p">))</span>
       <span class="p">(</span><span class="nb">or</span> <span class="p">(</span><span class="nb">zerop</span> <span class="p">(</span><span class="nb">mod</span> <span class="nv">y</span> <span class="mi">400</span><span class="p">))</span>
           <span class="p">(</span><span class="nb">not</span> <span class="p">(</span><span class="nb">zerop</span> <span class="p">(</span><span class="nb">mod</span> <span class="nv">y</span> <span class="mi">100</span><span class="p">))))))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">date-&gt;num</span> <span class="p">(</span><span class="nv">d</span> <span class="nv">m</span> <span class="nv">y</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">d</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nv">month-num</span> <span class="nv">m</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="nv">year-num</span> <span class="nv">y</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">month-num</span> <span class="p">(</span><span class="nv">m</span> <span class="nv">y</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nb">svref</span> <span class="nv">month</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">m</span> <span class="mi">1</span><span class="p">))</span>
     <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nb">&gt;</span> <span class="nv">m</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="nv">leap?</span> <span class="nv">y</span><span class="p">))</span> <span class="mi">1</span> <span class="mi">0</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">year-num</span> <span class="p">(</span><span class="nv">y</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">d</span> <span class="mi">0</span><span class="p">))</span>
    <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">&gt;=</span> <span class="nv">y</span> <span class="nv">yzero</span><span class="p">)</span>
        <span class="p">(</span><span class="nb">dotimes</span> <span class="p">(</span><span class="nv">i</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">y</span> <span class="nv">yzero</span><span class="p">)</span> <span class="nv">d</span><span class="p">)</span>
          <span class="p">(</span><span class="nb">incf</span> <span class="nv">d</span> <span class="p">(</span><span class="nv">year-days</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">yzero</span> <span class="nv">i</span><span class="p">))))</span>
        <span class="p">(</span><span class="nb">dotimes</span> <span class="p">(</span><span class="nv">i</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">yzero</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">d</span><span class="p">))</span>
          <span class="p">(</span><span class="nb">incf</span> <span class="nv">d</span> <span class="p">(</span><span class="nv">year-days</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">y</span> <span class="nv">i</span><span class="p">)))))))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">year-days</span> <span class="p">(</span><span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nv">leap?</span> <span class="nv">y</span><span class="p">)</span> <span class="mi">366</span> <span class="mi">365</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p><strong>图 5.1 日期运算：转换日期至数字</strong></p>
                              <p>典型 Lisp 程序的生命周期有四个阶段：先写好，然后读入，接着编译，最后执行。有件 Lisp 非常独特的事情之一是，在这四个阶段时， Lisp
                                一直都在那里。可以在你的程序编译 (参见 10.2 小节)或读入时 (参见 14.3 小节) 来调用 Lisp。我们推导出 <code
                                  class="docutils literal"><span class="pre">month</span></code> 的过程演示了，如何在撰写一个程序时使用
                                Lisp。</p>
                              <p>效率通常只跟第四个阶段有关系，运行期（run-time）。在前三个阶段，你可以随意的使用列表拥有的威力与灵活性，而不需要担心效率。</p>
                              <p>若你使用图 5.1 的代码来造一个时光机器（time
                                machine），当你抵达时，人们大概会不同意你的日期。即使是相对近的现在，欧洲的日期也曾有过偏移，因为人们会获得更精准的每年有多长的概念。在说英语的国家，最后一次的不连续性出现在
                                1752 年，日期从 9 月 2 日跳到 9 月 14 日。</p>
                              <p>每年有几天取决于该年是否是润年。如果该年可以被四整除，我们说该年是润年，除非该年可以被 100 整除，则该年非润年 ── 而要是它可以被 400 整除，则又是润年。所以
                                1904 年是润年，1900 年不是，而 1600 年是。</p>
                              <p>要决定某个数是否可以被另个数整除，我们使用函数 <code
                                  class="docutils literal"><span class="pre">mod</span></code> ，返回相除后的余数：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">mod</span> <span class="mi">23</span> <span class="mi">5</span><span class="p">)</span>
<span class="mi">3</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="nb">mod</span> <span class="mi">25</span> <span class="mi">5</span><span class="p">)</span>
<span class="mi">0</span>
</pre>
                                </div>
                              </div>
                              <p>如果第一个实参除以第二个实参的余数为 0，则第一个实参是可以被第二个实参整除的。函数 <code
                                  class="docutils literal"><span class="pre">leap?</span></code> 使用了这个方法，来决定它的实参是否是一个润年：
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">mapcar</span> <span class="nf">#&#39;</span><span class="nv">leap?</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1904</span> <span class="mi">1900</span> <span class="mi">1600</span><span class="p">))</span>
<span class="p">(</span><span class="no">T</span> <span class="no">NIL</span> <span class="no">T</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>我们用来转换日期至整数的函数是 <code
                                  class="docutils literal"><span class="pre">date-&gt;num</span></code>
                                。它返回日期中每个单位的天数总和。要找到从某月份开始的天数和，我们调用 <code
                                  class="docutils literal"><span class="pre">month-num</span></code> ，它在 <code
                                  class="docutils literal"><span class="pre">month</span></code> 中查询天数，如果是在润年的二月之后，则加一。
                              </p>
                              <p>要找到从某年开始的天数和， <code
                                  class="docutils literal"><span class="pre">date-&gt;num</span></code> 调用 <code
                                  class="docutils literal"><span class="pre">year-num</span></code>
                                ，它返回某年一月一日相对于起始点（2000.01.01）所代表的天数。这个函数的工作方式是从传入的实参 <code
                                  class="docutils literal"><span class="pre">y</span></code> 年开始，朝着起始年（2000）往上或往下数。</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">num-&gt;date</span> <span class="p">(</span><span class="nv">n</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">multiple-value-bind</span> <span class="p">(</span><span class="nv">y</span> <span class="nv">left</span><span class="p">)</span> <span class="p">(</span><span class="nv">num-year</span> <span class="nv">n</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">multiple-value-bind</span> <span class="p">(</span><span class="nv">m</span> <span class="nv">d</span><span class="p">)</span> <span class="p">(</span><span class="nv">num-month</span> <span class="nv">left</span> <span class="nv">y</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">values</span> <span class="nv">d</span> <span class="nv">m</span> <span class="nv">y</span><span class="p">))))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">num-year</span> <span class="p">(</span><span class="nv">n</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">&lt;</span> <span class="nv">n</span> <span class="mi">0</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">do*</span> <span class="p">((</span><span class="nv">y</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">yzero</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">y</span> <span class="mi">1</span><span class="p">))</span>
            <span class="p">(</span><span class="nv">d</span> <span class="p">(</span><span class="nb">-</span> <span class="p">(</span><span class="nv">year-days</span> <span class="nv">y</span><span class="p">))</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">d</span> <span class="p">(</span><span class="nv">year-days</span> <span class="nv">y</span><span class="p">))))</span>
           <span class="p">((</span><span class="nb">&lt;=</span> <span class="nv">d</span> <span class="nv">n</span><span class="p">)</span> <span class="p">(</span><span class="nb">values</span> <span class="nv">y</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">n</span> <span class="nv">d</span><span class="p">))))</span>
      <span class="p">(</span><span class="nb">do*</span> <span class="p">((</span><span class="nv">y</span> <span class="nv">yzero</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">y</span> <span class="mi">1</span><span class="p">))</span>
            <span class="p">(</span><span class="nv">prev</span> <span class="mi">0</span> <span class="nv">d</span><span class="p">)</span>
            <span class="p">(</span><span class="nv">d</span> <span class="p">(</span><span class="nv">year-days</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">d</span> <span class="p">(</span><span class="nv">year-days</span> <span class="nv">y</span><span class="p">))))</span>
           <span class="p">((</span><span class="nb">&gt;</span> <span class="nv">d</span> <span class="nv">n</span><span class="p">)</span> <span class="p">(</span><span class="nb">values</span> <span class="nv">y</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">n</span> <span class="nv">prev</span><span class="p">))))))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">num-month</span> <span class="p">(</span><span class="nv">n</span> <span class="nv">y</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nv">leap?</span> <span class="nv">y</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nb">=</span> <span class="nv">n</span> <span class="mi">59</span><span class="p">)</span> <span class="p">(</span><span class="nb">values</span> <span class="mi">2</span> <span class="mi">29</span><span class="p">))</span>
            <span class="p">((</span><span class="nb">&gt;</span> <span class="nv">n</span> <span class="mi">59</span><span class="p">)</span> <span class="p">(</span><span class="nv">nmon</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">n</span> <span class="mi">1</span><span class="p">)))</span>
            <span class="p">(</span><span class="no">t</span>        <span class="p">(</span><span class="nv">nmon</span> <span class="nv">n</span><span class="p">)))</span>
      <span class="p">(</span><span class="nv">nmon</span> <span class="nv">n</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">nmon</span> <span class="p">(</span><span class="nv">n</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">m</span> <span class="p">(</span><span class="nb">position</span> <span class="nv">n</span> <span class="nv">month</span> <span class="ss">:test</span> <span class="nf">#&#39;</span><span class="nb">&lt;</span><span class="p">)))</span>
    <span class="p">(</span><span class="nb">values</span> <span class="nv">m</span> <span class="p">(</span><span class="nb">+</span> <span class="mi">1</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">n</span> <span class="p">(</span><span class="nb">svref</span> <span class="nv">month</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">m</span> <span class="mi">1</span><span class="p">)))))))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">date+</span> <span class="p">(</span><span class="nv">d</span> <span class="nv">m</span> <span class="nv">y</span> <span class="nv">n</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">num-&gt;date</span> <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nv">date-&gt;num</span> <span class="nv">d</span> <span class="nv">m</span> <span class="nv">y</span><span class="p">)</span> <span class="nv">n</span><span class="p">)))</span>
</pre>
                                </div>
                              </div>
                              <p><strong>图 5.2 日期运算：转换数字至日期</strong></p>
                              <p>图 5.2 展示了代码的下半部份。函数 <code
                                  class="docutils literal"><span class="pre">num-&gt;date</span></code> 将整数转换回日期。它调用了
                                <code class="docutils literal"><span class="pre">num-year</span></code>
                                函数，以日期的格式返回年，以及剩余的天数。再将剩余的天数传给 <code
                                  class="docutils literal"><span class="pre">num-month</span></code> ，分解出月与日。
                              </p>
                              <p>和 <code class="docutils literal"><span class="pre">year-num</span></code> 相同， <code
                                  class="docutils literal"><span class="pre">num-year</span></code>
                                从起始年往上或下数，一次数一年。并持续累积天数，直到它获得一个绝对值大于或等于 <code
                                  class="docutils literal"><span class="pre">n</span></code>
                                的数。如果它往下数，那么它可以返回当前迭代中的数值。不然它会超过年份，然后必须返回前次迭代的数值。这也是为什么要使用 <code
                                  class="docutils literal"><span class="pre">prev</span></code> ， <code
                                  class="docutils literal"><span class="pre">prev</span></code> 在每次迭代时会存入 <code
                                  class="docutils literal"><span class="pre">days</span></code> 前次迭代的数值。</p>
                              <p>函数 <code class="docutils literal"><span class="pre">num-month</span></code>
                                以及它的子程序（subroutine） <code class="docutils literal"><span class="pre">nmon</span></code>
                                的行为像是相反地 <code class="docutils literal"><span class="pre">month-num</span></code>
                                。他们从常数向量 <code class="docutils literal"><span class="pre">month</span></code> 的数值到位置，然而
                                <code class="docutils literal"><span class="pre">month-num</span></code> 从位置到数值。
                              </p>
                              <p>图 5.2 的前两个函数可以合而为一。与其返回数值给另一个函数， <code
                                  class="docutils literal"><span class="pre">num-year</span></code> 可以直接调用 <code
                                  class="docutils literal"><span class="pre">num-month</span></code>
                                。现在分成两部分的代码，比较容易做交互测试，但是现在它可以工作了，下一步或许是把它合而为一。</p>
                              <p>有了 <code class="docutils literal"><span class="pre">date-&gt;num</span></code> 与 <code
                                  class="docutils literal"><span class="pre">num-&gt;date</span></code> ，日期运算是很简单的。我们在
                                <code class="docutils literal"><span class="pre">date+</span></code>
                                里使用它们，可以从特定的日期做加减。如果我们想透过 <code
                                  class="docutils literal"><span class="pre">date+</span></code> 来知道 1997 年 12 月 17
                                日六十天之后的日期:
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">multiple-value-list</span> <span class="p">(</span><span class="nv">date+</span> <span class="mi">17</span> <span class="mi">12</span> <span class="mi">1997</span> <span class="mi">60</span><span class="p">))</span>
<span class="p">(</span><span class="mi">15</span> <span class="mi">2</span> <span class="mi">1998</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>我们得到，1998 年 2 月 15 日。</p>
                            </div>
                            <div class="section" id="chapter-5-summary">
                              <h4>Chapter 5 总结 (Summary)<a class="headerlink" href="#chapter-5-summary"
                                  title="Permalink to this headline">¶</a></h4>
                              <ol class="arabic simple">
                                <li>Common Lisp 有三个基本的区块建构子： <code
                                    class="docutils literal"><span class="pre">progn</span></code> ；允许返回的 <code
                                    class="docutils literal"><span class="pre">block</span></code> ；以及允许 <code
                                    class="docutils literal"><span class="pre">goto</span></code> 的 <code
                                    class="docutils literal"><span class="pre">tagbody</span></code> 。很多内置的操作符隐含在区块里。
                                </li>
                                <li>进入一个新的词法语境，概念上等同于函数调用。</li>
                                <li>Common Lisp 提供了适合不同情况的条件式。每个都可以使用 <code
                                    class="docutils literal"><span class="pre">if</span></code> 来定义。</li>
                                <li>有数个相似迭代操作符的变种。</li>
                                <li>表达式可以返回多个数值。</li>
                                <li>计算过程可以被中断以及保护，保护可使其免于中断所造成的后果。</li>
                              </ol>
                            </div>
                            <div class="section" id="chapter-5-exercises">
                              <h4>Chapter 5 练习 (Exercises)<a class="headerlink" href="#chapter-5-exercises"
                                  title="Permalink to this headline">¶</a></h4>
                              <ol class="arabic simple">
                                <li>将下列表达式翻译成没有使用 <code class="docutils literal"><span class="pre">let</span></code> 与
                                  <code class="docutils literal"><span class="pre">let*</span></code> ，并使同样的表达式不被求值 2 次。
                                </li>
                              </ol>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nv">a</span><span class="p">)</span> <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">x</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">y</span><span class="p">)))</span>
      <span class="p">(</span><span class="nb">cons</span> <span class="nv">x</span> <span class="nv">x</span><span class="p">))</span>
<span class="p">(</span><span class="nv">b</span><span class="p">)</span> <span class="p">(</span><span class="k">let*</span> <span class="p">((</span><span class="nv">w</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">x</span><span class="p">))</span>
           <span class="p">(</span><span class="nv">y</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">w</span> <span class="nv">z</span><span class="p">)))</span>
      <span class="p">(</span><span class="nb">cons</span> <span class="nv">w</span> <span class="nv">y</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <ol class="arabic simple" start="2">
                                <li>使用 <code class="docutils literal"><span class="pre">cond</span></code> 重写 29 页的
                                  <code class="docutils literal"><span class="pre">mystery</span></code> 函数。（译注: 第二章的练习第
                                  5 题的 (b) 部分)
                                </li>
                                <li>定义一个返回其实参平方的函数，而当实参是一个正整数且小于等于 5 时，不要计算其平方。</li>
                                <li>使用 <code class="docutils literal"><span class="pre">case</span></code> 与 <code
                                    class="docutils literal"><span class="pre">svref</span></code> 重写 <code
                                    class="docutils literal"><span class="pre">month-num</span></code> (图 5.1)。</li>
                                <li>定义一个迭代与递归版本的函数，接受一个对象 x 与向量 v ，并返回一个列表，包含了向量 v 当中，所有直接在 <code
                                    class="docutils literal"><span class="pre">x</span></code> 之前的对象：</li>
                              </ol>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">precedes</span> <span class="sc">#\a</span> <span class="s">&quot;abracadabra&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="sc">#\c</span> <span class="sc">#\d</span> <span class="sc">#\r</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <ol class="arabic simple" start="6">
                                <li>定义一个迭代与递归版本的函数，接受一个对象与列表，并返回一个新的列表，在原本列表的对象之间加上传入的对象：</li>
                              </ol>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">intersperse</span> <span class="ss">&#39;-</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span><span class="p">))</span>
<span class="p">(</span><span class="nv">A</span> <span class="nb">-</span> <span class="nv">B</span> <span class="nb">-</span> <span class="nv">C</span> <span class="nb">-</span> <span class="nv">D</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <ol class="arabic simple" start="7">
                                <li>定义一个接受一系列数字的函数，并在若且唯若每一对（pair）数字的差为一时，返回真，使用</li>
                              </ol>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre>(a) 递归
(b) do
(c) mapc 与 return
</pre>
                                </div>
                              </div>
                              <ol class="arabic simple" start="8">
                                <li>定义一个单递归函数，返回两个值，分别是向量的最大与最小值。</li>
                                <li>图 3.12 的程序在找到一个完整的路径时，仍持续遍历伫列。在搜索范围大时，这可能会产生问题。</li>
                              </ol>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre>(a) 使用 catch 与 throw 来变更程序，使其找到第一个完整路径时，直接返回它。
(b) 重写一个做到同样事情的程序，但不使用 catch 与 throw。
</pre>
                                </div>
                              </div>
                            </div>
                          </div>
                          <div class="section">
                            <h3 id="6">第六章：函数</h3>
                            <p>理解函数是理解 Lisp 的关键之一。概念上来说，函数是 Lisp 的核心所在。实际上呢，函数是你手边最有用的工具之一。</p>
                            <div class="section" id="global-functions">
                              <h4>6.1 全局函数 (Global Functions)<a class="headerlink" href="#global-functions"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>谓词 <code class="docutils literal"><span class="pre">fboundp</span></code>
                                告诉我们，是否有个函数的名字与给定的符号绑定。如果一个符号是函数的名字，则 <code
                                  class="docutils literal"><span class="pre">symbol-function</span></code> 会返回它：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre>&gt; (fboundp &#39;+)
T
&gt; (symbol-function &#39;+)
#&lt;Compiled-function + 17BA4E&gt;
</pre>
                                </div>
                              </div>
                              <p>可通过 <code class="docutils literal"><span class="pre">symbol-function</span></code>
                                给函数配置某个名字：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nb">symbol-function</span> <span class="ss">&#39;add2</span><span class="p">)</span>
  <span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="mi">2</span><span class="p">)))</span>
</pre>
                                </div>
                              </div>
                              <p>新的全局函数可以这样定义，用起来和 <code class="docutils literal"><span class="pre">defun</span></code>
                                所定义的函数一样：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">add2</span> <span class="mi">1</span><span class="p">)</span>
<span class="mi">3</span>
</pre>
                                </div>
                              </div>
                              <p>实际上 <code class="docutils literal"><span class="pre">defun</span></code> 做了稍微多的工作，将某些像是
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">add2</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="mi">2</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p>翻译成上述的 <code class="docutils literal"><span class="pre">setf</span></code> 表达式。使用 <code
                                  class="docutils literal"><span class="pre">defun</span></code>
                                让程序看起来更美观，并或多或少帮助了编译器，但严格来说，没有 <code
                                  class="docutils literal"><span class="pre">defun</span></code> 也能写程序。</p>
                              <p>通过把 <code class="docutils literal"><span class="pre">defun</span></code>
                                的第一个实参变成这种形式的列表 <code
                                  class="docutils literal"><span class="pre">(setf</span> <span class="pre">f)</span></code>
                                ，你定义了当 <code class="docutils literal"><span class="pre">setf</span></code> 第一个实参是 <code
                                  class="docutils literal"><span class="pre">f</span></code> 的函数调用时，所会发生的事情。下面这对函数把
                                <code class="docutils literal"><span class="pre">primo</span></code> 定义成 <code
                                  class="docutils literal"><span class="pre">car</span></code> 的同义词：
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">primo</span> <span class="p">(</span><span class="nv">lst</span><span class="p">)</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">lst</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="p">(</span><span class="nb">setf</span> <span class="nv">primo</span><span class="p">)</span> <span class="p">(</span><span class="nv">val</span> <span class="nv">lst</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">lst</span><span class="p">)</span> <span class="nv">val</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p>在函数名是这种形式 <code
                                  class="docutils literal"><span class="pre">(setf</span> <span class="pre">f)</span></code>
                                的函数定义中，第一个实参代表新的数值，而剩余的实参代表了传给 <code
                                  class="docutils literal"><span class="pre">f</span></code> 的参数。</p>
                              <p>现在任何 <code class="docutils literal"><span class="pre">primo</span></code> 的 <code
                                  class="docutils literal"><span class="pre">setf</span></code> ，会是上面后者的函数调用：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">x</span> <span class="p">(</span><span class="nb">list</span> <span class="ss">&#39;a</span> <span class="ss">&#39;b</span> <span class="ss">&#39;c</span><span class="p">)))</span>
    <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nv">primo</span> <span class="nv">x</span><span class="p">)</span> <span class="mi">480</span><span class="p">)</span>
    <span class="nv">x</span><span class="p">)</span>
<span class="p">(</span><span class="mi">480</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>不需要为了定义 <code
                                  class="docutils literal"><span class="pre">(setf</span> <span class="pre">primo)</span></code>
                                而定义 <code class="docutils literal"><span class="pre">primo</span></code> ，但这样的定义通常是成对的。
                              </p>
                              <p>由于字符串是 Lisp 表达式，没有理由它们不能出现在代码的主体。字符串本身是没有副作用的，除非它是最后一个表达式，否则不会造成任何差别。如果让字符串成为 <code
                                  class="docutils literal"><span class="pre">defun</span></code> 定义的函数主体的第一个表达式，</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">foo</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span>
  <span class="s">&quot;Implements an enhanced paradigm of diversity&quot;</span>
  <span class="nv">x</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>那么这个字符串会变成函数的文档字符串（documentation string）。要取得函数的文档字符串，可以通过调用 <code
                                  class="docutils literal"><span class="pre">documentation</span></code> 来取得：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">documentation</span> <span class="ss">&#39;foo</span> <span class="ss">&#39;function</span><span class="p">)</span>
<span class="s">&quot;Implements an enhanced paradigm of diversity&quot;</span>
</pre>
                                </div>
                              </div>
                            </div>
                            <div class="section" id="local-functions">
                              <h4>6.2 局部函数 (Local Functions)<a class="headerlink" href="#local-functions"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>通过 <code class="docutils literal"><span class="pre">defun</span></code> 或 <code
                                  class="docutils literal"><span class="pre">symbol-function</span></code> 搭配 <code
                                  class="docutils literal"><span class="pre">setf</span></code>
                                定义的函数是全局函数。你可以像存取全局变量那样，在任何地方存取它们。定义局部函数也是有可能的，局部函数和局部变量一样，只在某些上下文内可以访问。</p>
                              <p>局部函数可以使用 <code class="docutils literal"><span class="pre">labels</span></code>
                                来定义，它是一种像是给函数使用的 <code class="docutils literal"><span class="pre">let</span></code>
                                。它的第一个实参是一个新局部函数的定义列表，而不是一个变量规格说明的列表。列表中的元素为如下形式：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nv">name</span> <span class="nv">parameters</span> <span class="o">.</span> <span class="nv">body</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>而 <code class="docutils literal"><span class="pre">labels</span></code> 表达式剩余的部份，调用
                                <code class="docutils literal"><span class="pre">name</span></code> 就等于调用 <code
                                  class="docutils literal"><span class="pre">(lambda</span> <span class="pre">parameters</span> <span class="pre">.</span> <span class="pre">body)</span></code>
                                。
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="k">labels</span> <span class="p">((</span><span class="nv">add10</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="mi">10</span><span class="p">))</span>
           <span class="p">(</span><span class="nv">consa</span>  <span class="p">(</span><span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">cons</span> <span class="ss">&#39;a</span> <span class="nv">x</span><span class="p">)))</span>
    <span class="p">(</span><span class="nv">consa</span> <span class="p">(</span><span class="nv">add10</span> <span class="mi">3</span><span class="p">)))</span>
<span class="p">(</span><span class="nv">A</span> <span class="o">.</span> <span class="mi">13</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p><code class="docutils literal"><span class="pre">labels</span></code> 与 <code
                                  class="docutils literal"><span class="pre">let</span></code> 的类比在一个方面上被打破了。由 <code
                                  class="docutils literal"><span class="pre">labels</span></code>
                                表达式所定义的局部函数，可以被其他任何在此定义的函数引用，包括自己。所以这样定义一个递归的局部函数是可能的：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="k">labels</span> <span class="p">((</span><span class="nv">len</span> <span class="p">(</span><span class="nv">lst</span><span class="p">)</span>
             <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">null</span> <span class="nv">lst</span><span class="p">)</span>
                 <span class="mi">0</span>
                 <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nv">len</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">lst</span><span class="p">))</span> <span class="mi">1</span><span class="p">))))</span>
    <span class="p">(</span><span class="nv">len</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">)))</span>
<span class="mi">3</span>
</pre>
                                </div>
                              </div>
                              <p>5.2 节展示了 <code class="docutils literal"><span class="pre">let</span></code>
                                表达式如何被理解成函数调用。 <code class="docutils literal"><span class="pre">do</span></code>
                                表达式同样可以被解释成调用递归函数。这样形式的 <code
                                  class="docutils literal"><span class="pre">do</span></code> :</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">do</span> <span class="p">((</span><span class="nv">x</span> <span class="nv">a</span> <span class="p">(</span><span class="nv">b</span> <span class="nv">x</span><span class="p">))</span>
     <span class="p">(</span><span class="nv">y</span> <span class="nv">c</span> <span class="p">(</span><span class="nv">d</span> <span class="nv">y</span><span class="p">)))</span>
    <span class="p">((</span><span class="nv">test</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="nv">z</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">))</span>
  <span class="p">(</span><span class="nv">f</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p>等同于</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="k">labels</span> <span class="p">((</span><span class="nv">rec</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
           <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nv">test</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
                  <span class="p">(</span><span class="nv">z</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">))</span>
                 <span class="p">(</span><span class="no">t</span>
                  <span class="p">(</span><span class="nv">f</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
                  <span class="p">(</span><span class="nv">rec</span> <span class="p">(</span><span class="nv">b</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nv">d</span> <span class="nv">y</span><span class="p">))))))</span>
  <span class="p">(</span><span class="nv">rec</span> <span class="nv">a</span> <span class="nv">c</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p>这个模型可以用来解决，任何你对于 <code class="docutils literal"><span class="pre">do</span></code>
                                行为仍有疑惑的问题。</p>
                            </div>
                            <div class="section" id="parameter-lists">
                              <h4>6.3 参数列表 (Parameter Lists)<a class="headerlink" href="#parameter-lists"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>2.1 节我们演示过，有了前序表达式， <code class="docutils literal"><span class="pre">+</span></code>
                                可以接受任何数量的参数。从那时开始，我们看过许多接受不定数量参数的函数。要写出这样的函数，我们需要使用一个叫做剩余（ <em>rest</em> ）参数的东西。</p>
                              <p>如果我们在函数的形参列表里的最后一个变量前，插入 <code
                                  class="docutils literal"><span class="pre">&amp;rest</span></code>
                                符号，那么当这个函数被调用时，这个变量会被设成一个带有剩余参数的列表。现在我们可以明白 <code
                                  class="docutils literal"><span class="pre">funcall</span></code> 是如何根据 <code
                                  class="docutils literal"><span class="pre">apply</span></code> 写成的。它或许可以定义成：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">our-funcall</span> <span class="p">(</span><span class="nv">fn</span> <span class="k">&amp;rest</span> <span class="nv">args</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">apply</span> <span class="nv">fn</span> <span class="nv">args</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p>我们也看过操作符中，有的参数可以被忽略，并可以缺省设成特定的值。这样的参数称为选择性参数（optional
                                parameters）。（相比之下，普通的参数有时称为必要参数「required parameters」) 如果符号 <code
                                  class="docutils literal"><span class="pre">&amp;optional</span></code> 出现在一个函数的形参列表时，
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">philosoph</span> <span class="p">(</span><span class="nv">thing</span> <span class="k">&amp;optional</span> <span class="nv">property</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">list</span> <span class="nv">thing</span> <span class="ss">&#39;is</span> <span class="nv">property</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p>那么在 <code class="docutils literal"><span class="pre">&amp;optional</span></code>
                                之后的参数都是选择性的，缺省为 <code class="docutils literal"><span class="pre">nil</span></code> :</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">philosoph</span> <span class="ss">&#39;death</span><span class="p">)</span>
<span class="p">(</span><span class="nv">DEATH</span> <span class="nv">IS</span> <span class="no">NIL</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>我们可以明确指定缺省值，通过将缺省值附在列表里给入。这版的 <code
                                  class="docutils literal"><span class="pre">philosoph</span></code></p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">philosoph</span> <span class="p">(</span><span class="nv">thing</span> <span class="k">&amp;optional</span> <span class="p">(</span><span class="nv">property</span> <span class="ss">&#39;fun</span><span class="p">))</span>
  <span class="p">(</span><span class="nb">list</span> <span class="nv">thing</span> <span class="ss">&#39;is</span> <span class="nv">property</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p>有着更鼓舞人心的缺省值：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">philosoph</span> <span class="ss">&#39;death</span><span class="p">)</span>
<span class="p">(</span><span class="nv">DEATH</span> <span class="nv">IS</span> <span class="nv">FUN</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>选择性参数的缺省值可以不是常量。可以是任何的 Lisp 表达式。若这个表达式不是常量，它会在每次需要用到缺省值时被重新求值。</p>
                              <p>一个关键字参数（keyword parameter）是一种更灵活的选择性参数。如果你把符号 <code
                                  class="docutils literal"><span class="pre">&amp;key</span></code> 放在一个形参列表，那在 <code
                                  class="docutils literal"><span class="pre">&amp;key</span></code>
                                之后的形参都是选择性的。此外，当函数被调用时，这些参数会被识别出来，参数的位置在哪不重要，而是用符号标签（译注: <code
                                  class="docutils literal"><span class="pre">:</span></code> ）识别出来：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">defun</span> <span class="nv">keylist</span> <span class="p">(</span><span class="nv">a</span> <span class="k">&amp;key</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">list</span> <span class="nv">a</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span><span class="p">))</span>
<span class="nv">KEYLIST</span>

<span class="nb">&gt;</span> <span class="p">(</span><span class="nv">keylist</span> <span class="mi">1</span> <span class="ss">:y</span> <span class="mi">2</span><span class="p">)</span>
<span class="p">(</span><span class="mi">1</span> <span class="no">NIL</span> <span class="mi">2</span> <span class="no">NIL</span><span class="p">)</span>

<span class="nb">&gt;</span> <span class="p">(</span><span class="nv">keylist</span> <span class="mi">1</span> <span class="ss">:y</span> <span class="mi">3</span> <span class="ss">:x</span> <span class="mi">2</span><span class="p">)</span>
<span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="no">NIL</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>和普通的选择性参数一样，关键字参数缺省值为 <code
                                  class="docutils literal"><span class="pre">nil</span></code> ，但可以在形参列表中明确地指定缺省值。</p>
                              <p>关键字与其相关的参数可以被剩余参数收集起来，并传递给其他期望收到这些参数的函数。举例来说，我们可以这样定义 <code
                                  class="docutils literal"><span class="pre">adjoin</span></code> ：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">our-adjoin</span> <span class="p">(</span><span class="nv">obj</span> <span class="nv">lst</span> <span class="k">&amp;rest</span> <span class="nv">args</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">apply</span> <span class="nf">#&#39;</span><span class="nb">member</span> <span class="nv">obj</span> <span class="nv">lst</span> <span class="nv">args</span><span class="p">)</span>
      <span class="nv">lst</span>
      <span class="p">(</span><span class="nb">cons</span> <span class="nv">obj</span> <span class="nv">lst</span><span class="p">)))</span>
</pre>
                                </div>
                              </div>
                              <p>由于 <code class="docutils literal"><span class="pre">adjoin</span></code> 与 <code
                                  class="docutils literal"><span class="pre">member</span></code>
                                接受一样的关键字，我们可以用剩余参数收集它们，再传给 <code
                                  class="docutils literal"><span class="pre">member</span></code> 函数。</p>
                              <p>5.2 节介绍过 <code
                                  class="docutils literal"><span class="pre">destructuring-bind</span></code>
                                宏。在通常情况下，每个模式（pattern）中作为第一个参数的子树，可以与函数的参数列表一样复杂：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">destructuring-bind</span> <span class="p">((</span><span class="k">&amp;key</span> <span class="nv">w</span> <span class="nv">x</span><span class="p">)</span> <span class="k">&amp;rest</span> <span class="nv">y</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">((</span><span class="ss">:w</span> <span class="mi">3</span><span class="p">)</span> <span class="nv">a</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">list</span> <span class="nv">w</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">))</span>
<span class="p">(</span><span class="mi">3</span> <span class="no">NIL</span> <span class="p">(</span><span class="nv">A</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                            </div>
                            <div class="section" id="example-utilities">
                              <h4>6.4 示例：实用函数 (Example: Utilities)<a class="headerlink" href="#example-utilities"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>2.6 节提到过，Lisp 大部分是由 Lisp
                                函数组成，这些函数与你可以自己定义的函数一样。这是程序语言中一个有用的特色：你不需要改变你的想法来配合语言，因为你可以改变语言来配合你的想法。如果你想要 Common Lisp
                                有某个特定的函数，自己写一个，而这个函数会成为语言的一部分，就跟内置的 <code
                                  class="docutils literal"><span class="pre">+</span></code> 或 <code
                                  class="docutils literal"><span class="pre">eql</span></code> 一样。</p>
                              <p>有经验的 Lisp 程序员，由上而下（top-down）也由下而上
                                (bottom-up)地工作。当他们朝着语言撰写程序的同时，也打造了一个更适合他们程序的语言。通过这种方式，语言与程序结合的更好，也更好用。</p>
                              <p>写来扩展 Lisp 的操作符称为实用函数（utilities）。当你写了更多 Lisp
                                程序时，会发现你开发了一系列的程序，而在一个项目写过许多的实用函数，下个项目里也会派上用场。</p>
                              <p>
                                专业的程序员常发现，手边正在写的程序，与过去所写的程序有很大的关联。这就是软件重用让人听起来很吸引人的原因。但重用已经被联想成面向对象程序设计。但软件不需要是面向对象的才能重用
                                ── 这是很明显的，我们看看程序语言（换言之，编译器），是重用性最高的软件。</p>
                              <p>要获得可重用软件的方法是，由下而上地写程序，而程序不需要是面向对象的才能够由下而上地写出。实际上，函数式风格相比之下，更适合写出重用软件。想想看 <code
                                  class="docutils literal"><span class="pre">sort</span></code> 。在 Common Lisp
                                你几乎不需要自己写排序程序； <code class="docutils literal"><span class="pre">sort</span></code>
                                是如此的快与普遍，以致于它不值得我们烦恼。这才是可重用软件。</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">single?</span> <span class="p">(</span><span class="nv">lst</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nb">consp</span> <span class="nv">lst</span><span class="p">)</span> <span class="p">(</span><span class="nb">null</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">lst</span><span class="p">))))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">append1</span> <span class="p">(</span><span class="nv">lst</span> <span class="nv">obj</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">append</span> <span class="nv">lst</span> <span class="p">(</span><span class="nb">list</span> <span class="nv">obj</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">map-int</span> <span class="p">(</span><span class="nv">fn</span> <span class="nv">n</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">acc</span> <span class="no">nil</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">dotimes</span> <span class="p">(</span><span class="nv">i</span> <span class="nv">n</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">push</span> <span class="p">(</span><span class="nb">funcall</span> <span class="nv">fn</span> <span class="nv">i</span><span class="p">)</span> <span class="nv">acc</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">nreverse</span> <span class="nv">acc</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">filter</span> <span class="p">(</span><span class="nv">fn</span> <span class="nv">lst</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">acc</span> <span class="no">nil</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">dolist</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">lst</span><span class="p">)</span>
      <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">val</span> <span class="p">(</span><span class="nb">funcall</span> <span class="nv">fn</span> <span class="nv">x</span><span class="p">)))</span>
        <span class="p">(</span><span class="k">if</span> <span class="nv">val</span> <span class="p">(</span><span class="nb">push</span> <span class="nv">val</span> <span class="nv">acc</span><span class="p">))))</span>
    <span class="p">(</span><span class="nb">nreverse</span> <span class="nv">acc</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">most</span> <span class="p">(</span><span class="nv">fn</span> <span class="nv">lst</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">null</span> <span class="nv">lst</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">values</span> <span class="no">nil</span> <span class="no">nil</span><span class="p">)</span>
      <span class="p">(</span><span class="k">let*</span> <span class="p">((</span><span class="nv">wins</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">lst</span><span class="p">))</span>
             <span class="p">(</span><span class="nb">max</span> <span class="p">(</span><span class="nb">funcall</span> <span class="nv">fn</span> <span class="nv">wins</span><span class="p">)))</span>
        <span class="p">(</span><span class="nb">dolist</span> <span class="p">(</span><span class="nv">obj</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">lst</span><span class="p">))</span>
          <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">score</span> <span class="p">(</span><span class="nb">funcall</span> <span class="nv">fn</span> <span class="nv">obj</span><span class="p">)))</span>
            <span class="p">(</span><span class="nb">when</span> <span class="p">(</span><span class="nb">&gt;</span> <span class="nv">score</span> <span class="nb">max</span><span class="p">)</span>
              <span class="p">(</span><span class="nb">setf</span> <span class="nv">wins</span> <span class="nv">obj</span>
                    <span class="nb">max</span>  <span class="nv">score</span><span class="p">))))</span>
        <span class="p">(</span><span class="nb">values</span> <span class="nv">wins</span> <span class="nb">max</span><span class="p">))))</span>
</pre>
                                </div>
                              </div>
                              <p><strong>图 6.1 实用函数</strong></p>
                              <p>你可以通过撰写实用函数，在程序里做到同样的事情。图 6.1 挑选了一组实用的函数。前两个 <code
                                  class="docutils literal"><span class="pre">single?</span></code> 与 <code
                                  class="docutils literal"><span class="pre">append1</span></code>
                                函数，放在这的原因是要演示，即便是小程序也很有用。前一个函数 <code
                                  class="docutils literal"><span class="pre">single?</span></code> ，当实参是只有一个元素的列表时，返回真。
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">single?</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span><span class="p">))</span>
<span class="no">T</span>
</pre>
                                </div>
                              </div>
                              <p>而后一个函数 <code class="docutils literal"><span class="pre">append1</span></code> 和 <code
                                  class="docutils literal"><span class="pre">cons</span></code> 很像，但在列表后面新增一个元素，而不是在前面:
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">append1</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">)</span> <span class="ss">&#39;d</span><span class="p">)</span>
<span class="p">(</span><span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="nv">D</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>下个实用函数是 <code class="docutils literal"><span class="pre">map-int</span></code>
                                ，接受一个函数与整数 <code class="docutils literal"><span class="pre">n</span></code> ，并返回将函数应用至整数
                                <code class="docutils literal"><span class="pre">0</span></code> 到 <code
                                  class="docutils literal"><span class="pre">n-1</span></code> 的结果的列表。
                              </p>
                              <p>这在测试的时候非常好用（一个 Lisp 的优点之一是，互动环境让你可以轻松地写出测试）。如果我们只想要一个 <code
                                  class="docutils literal"><span class="pre">0</span></code> 到 <code
                                  class="docutils literal"><span class="pre">9</span></code> 的列表，我们可以：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">map-int</span> <span class="nf">#&#39;</span><span class="nb">identity</span> <span class="mi">10</span><span class="p">)</span>
<span class="p">(</span><span class="mi">0</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>然而要是我们想要一个具有 10 个随机数的列表，每个数介于 0 至 99 之间（包含 99），我们可以忽略参数并只要:</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">map-int</span> <span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">random</span> <span class="mi">100</span><span class="p">))</span>
           <span class="mi">10</span><span class="p">)</span>
<span class="p">(</span><span class="mi">85</span> <span class="mi">50</span> <span class="mi">73</span> <span class="mi">64</span> <span class="mi">28</span> <span class="mi">21</span> <span class="mi">40</span> <span class="mi">67</span> <span class="mi">5</span> <span class="mi">32</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p><code class="docutils literal"><span class="pre">map-int</span></code> 的定义说明了 Lisp
                                构造列表的标准做法（idiom）之一。我们创建一个累积器 <code
                                  class="docutils literal"><span class="pre">acc</span></code> ，初始化是 <code
                                  class="docutils literal"><span class="pre">nil</span></code>
                                ，并将之后的对象累积起来。当累积完毕时，反转累积器。 <a class="footnote-reference" href="#id5" id="id2">[1]</a>
                              </p>
                              <p>我们在 <code class="docutils literal"><span class="pre">filter</span></code> 中看到同样的做法。
                                <code class="docutils literal"><span class="pre">filter</span></code>
                                接受一个函数与一个列表，将函数应用至列表元素上时，返回所有非 <code
                                  class="docutils literal"><span class="pre">nil</span></code> 元素:
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">filter</span> <span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span>
              <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nb">evenp</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="mi">10</span><span class="p">)))</span>
          <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span><span class="p">))</span>
<span class="p">(</span><span class="mi">12</span> <span class="mi">14</span> <span class="mi">16</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>另一种思考 <code class="docutils literal"><span class="pre">filter</span></code> 的方式是用通用版本的
                                <code class="docutils literal"><span class="pre">remove-if</span></code> 。
                              </p>
                              <p>图 6.1 的最后一个函数， <code class="docutils literal"><span class="pre">most</span></code>
                                ，根据某个评分函数（scoring function），返回列表中最高分的元素。它返回两个值，获胜的元素以及它的分数:</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">most</span> <span class="nf">#&#39;</span><span class="nb">length</span> <span class="o">&#39;</span><span class="p">((</span><span class="nv">a</span> <span class="nv">b</span><span class="p">)</span> <span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">)</span> <span class="p">(</span><span class="nv">a</span><span class="p">)))</span>
<span class="p">(</span><span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span><span class="p">)</span>
<span class="mi">3</span>
</pre>
                                </div>
                              </div>
                              <p>如果平手的话，返回先驰得点的元素。</p>
                              <p>注意图 6.1 的最后三个函数，它们全接受函数作为参数。 Lisp 使得将函数作为参数传递变得便捷，而这也是为什么，Lisp
                                适合由下而上程序设计的原因之一。成功的实用函数必须是通用的，当你可以将细节作为函数参数传递时，要将通用的部份抽象起来就变得容易许多。</p>
                              <p>本节给出的函数是通用的实用函数。可以用在任何种类的程序。但也可以替特定种类的程序撰写实用函数。确实，当我们谈到宏时，你可以凌驾于 Lisp
                                之上，写出自己的特定语言，如果你想这么做的话。如果你想要写可重用软件，看起来这是最靠谱的方式。</p>
                            </div>
                            <div class="section" id="closures">
                              <h4>6.5 闭包 (Closures)<a class="headerlink" href="#closures"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>函数可以如表达式的值，或是其它对象那样被返回。以下是接受一个实参，并依其类型返回特定的结合函数：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">combiner</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">typecase</span> <span class="nv">x</span>
    <span class="p">(</span><span class="nc">number</span> <span class="nf">#&#39;</span><span class="nb">+</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">list</span> <span class="nf">#&#39;</span><span class="nb">append</span><span class="p">)</span>
    <span class="p">(</span><span class="no">t</span> <span class="nf">#&#39;</span><span class="nb">list</span><span class="p">)))</span>
</pre>
                                </div>
                              </div>
                              <p>在这之上，我们可以创建一个通用的结合函数:</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">combine</span> <span class="p">(</span><span class="k">&amp;rest</span> <span class="nv">args</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">apply</span> <span class="p">(</span><span class="nv">combiner</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">args</span><span class="p">))</span>
         <span class="nv">args</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p>它接受任何类型的参数，并以适合它们类型的方式结合。（为了简化这个例子，我们假定所有的实参，都有着一样的类型。）</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">combine</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span>
<span class="mi">5</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="nv">combine</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">c</span> <span class="nv">d</span><span class="p">))</span>
<span class="p">(</span><span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="nv">D</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>2.10 小节提过词法变量（lexical variables）只在被定义的上下文内有效。伴随这个限制而来的是，只要那个上下文还有在使用，它们就保证会是有效的。</p>
                              <p>如果函数在词法变量的作用域里被定义时，函数仍可引用到那个变量，即便函数被作为一个值返回了，返回至词法变量被创建的上下文之外。下面我们创建了一个把实参加上 <code
                                  class="docutils literal"><span class="pre">3</span></code> 的函数：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre>&gt; (setf fn (let ((i 3))
             #&#39;(lambda (x) (+ x i))))
#&lt;Interpreted-Function C0A51E&gt;
&gt; (funcall fn 2)
5
</pre>
                                </div>
                              </div>
                              <p>当函数引用到外部定义的变量时，这外部定义的变量称为自由变量（free variable）。函数引用到自由的词法变量时，称之为闭包（closure）。 <a
                                  class="footnote-reference" href="#id6" id="id3">[2]</a> 只要函数还存在，变量就必须一起存在。</p>
                              <p>闭包结合了函数与环境（environment）；无论何时，当一个函数引用到周围词法环境的某个东西时，闭包就被隐式地创建出来了。这悄悄地发生在像是下面这个函数，是一样的概念:
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">add-to-list</span> <span class="p">(</span><span class="nv">num</span> <span class="nv">lst</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">mapcar</span> <span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span>
              <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="nv">num</span><span class="p">))</span>
          <span class="nv">lst</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p>这函数接受一个数字及列表，并返回一个列表，列表元素是元素与传入数字的和。在 lambda 表达式里的变量 <code
                                  class="docutils literal"><span class="pre">num</span></code> 是自由的，所以像是这样的情况，我们传递了一个闭包给
                                <code class="docutils literal"><span class="pre">mapcar</span></code> 。
                              </p>
                              <p>一个更显着的例子会是函数在被调用时，每次都返回不同的闭包。下面这个函数返回一个加法器（adder）:</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">make-adder</span> <span class="p">(</span><span class="nv">n</span><span class="p">)</span>
  <span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="nv">n</span><span class="p">)))</span>
</pre>
                                </div>
                              </div>
                              <p>它接受一个数字，并返回一个将该数字与其参数相加的闭包（函数）。</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre>&gt; (setf add3 (make-adder 3))
#&lt;Interpreted-Function COEBF6&gt;
&gt; (funcall add3 2)
5
&gt; (setf add27 (make-adder 27))
#&lt;Interpreted-Function C0EE4E&gt;
&gt; (funcall add27 2)
29
</pre>
                                </div>
                              </div>
                              <p>我们可以产生共享变量的数个闭包。下面我们定义共享一个计数器的两个函数:</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">counter</span> <span class="mi">0</span><span class="p">))</span>
  <span class="p">(</span><span class="nb">defun</span> <span class="nv">reset</span> <span class="p">()</span>
    <span class="p">(</span><span class="nb">setf</span> <span class="nv">counter</span> <span class="mi">0</span><span class="p">))</span>
  <span class="p">(</span><span class="nb">defun</span> <span class="nv">stamp</span> <span class="p">()</span>
    <span class="p">(</span><span class="nb">setf</span> <span class="nv">counter</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">counter</span> <span class="mi">1</span><span class="p">))))</span>
</pre>
                                </div>
                              </div>
                              <p>这样的一对函数或许可以用来创建时间戳章（time-stamps）。每次我们调用 <code
                                  class="docutils literal"><span class="pre">stamp</span></code> 时，我们获得一个比之前高的数字，而调用
                                <code class="docutils literal"><span class="pre">reset</span></code> 我们可以将计数器归零:
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">list</span> <span class="p">(</span><span class="nv">stamp</span><span class="p">)</span> <span class="p">(</span><span class="nv">stamp</span><span class="p">)</span> <span class="p">(</span><span class="nv">reset</span><span class="p">)</span> <span class="p">(</span><span class="nv">stamp</span><span class="p">))</span>
<span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">0</span> <span class="mi">1</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>你可以使用全局计数器来做到同样的事情，但这样子使用计数器，可以保护计数器被非预期的引用。</p>
                              <p>Common Lisp 有一个内置的函数 <code
                                  class="docutils literal"><span class="pre">complement</span></code>
                                函数，接受一个谓词，并返回谓词的补数（complement）。比如：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">mapcar</span> <span class="p">(</span><span class="nb">complement</span> <span class="nf">#&#39;</span><span class="nb">oddp</span><span class="p">)</span>
          <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span><span class="p">))</span>
<span class="p">(</span><span class="no">NIL</span> <span class="no">T</span> <span class="no">NIL</span> <span class="no">T</span> <span class="no">NIL</span> <span class="no">T</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>有了闭包以后，很容易就可以写出这样的函数：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">our-complement</span> <span class="p">(</span><span class="nv">f</span><span class="p">)</span>
  <span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="k">&amp;rest</span> <span class="nv">args</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">not</span> <span class="p">(</span><span class="nb">apply</span> <span class="nv">f</span> <span class="nv">args</span><span class="p">))))</span>
</pre>
                                </div>
                              </div>
                              <p>如果你停下来好好想想，会发现这是个非凡的小例子；而这仅是冰山一角。闭包是 Lisp 特有的美妙事物之一。闭包开创了一种在别的语言当中，像是不可思议的程序设计方法。</p>
                            </div>
                            <div class="section" id="example-function-builders">
                              <h4>6.6 示例：函数构造器 (Example: Function Builders)<a class="headerlink"
                                  href="#example-function-builders" title="Permalink to this headline">¶</a></h4>
                              <p>Dylan 是 Common Lisp 与 Scheme 的混合物，有着 Pascal 一般的语法。它有着大量返回函数的函数：除了上一节我们所看过的
                                <cite>complement</cite> ，Dylan 包含: <code
                                  class="docutils literal"><span class="pre">compose</span></code> 、 <code
                                  class="docutils literal"><span class="pre">disjoin</span></code> 、 <code
                                  class="docutils literal"><span class="pre">conjoin</span></code> 、 <code
                                  class="docutils literal"><span class="pre">curry</span></code> 、 <code
                                  class="docutils literal"><span class="pre">rcurry</span></code> 以及 <code
                                  class="docutils literal"><span class="pre">always</span></code> 。图 6.2 有这些函数的 Common
                                Lisp 实现，而图 6.3 演示了一些从定义延伸出的等价函数。
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">compose</span> <span class="p">(</span><span class="k">&amp;rest</span> <span class="nv">fns</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">destructuring-bind</span> <span class="p">(</span><span class="nv">fn1</span> <span class="o">.</span> <span class="nb">rest</span><span class="p">)</span> <span class="p">(</span><span class="nb">reverse</span> <span class="nv">fns</span><span class="p">)</span>
    <span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="k">&amp;rest</span> <span class="nv">args</span><span class="p">)</span>
        <span class="p">(</span><span class="nb">reduce</span> <span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">v</span> <span class="nv">f</span><span class="p">)</span> <span class="p">(</span><span class="nb">funcall</span> <span class="nv">f</span> <span class="nv">v</span><span class="p">))</span>
                <span class="nb">rest</span>
                <span class="ss">:initial-value</span> <span class="p">(</span><span class="nb">apply</span> <span class="nv">fn1</span> <span class="nv">args</span><span class="p">)))))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">disjoin</span> <span class="p">(</span><span class="nv">fn</span> <span class="k">&amp;rest</span> <span class="nv">fns</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">null</span> <span class="nv">fns</span><span class="p">)</span>
      <span class="nv">fn</span>
      <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">disj</span> <span class="p">(</span><span class="nb">apply</span> <span class="nf">#&#39;</span><span class="nv">disjoin</span> <span class="nv">fns</span><span class="p">)))</span>
        <span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="k">&amp;rest</span> <span class="nv">args</span><span class="p">)</span>
            <span class="p">(</span><span class="nb">or</span> <span class="p">(</span><span class="nb">apply</span> <span class="nv">fn</span> <span class="nv">args</span><span class="p">)</span> <span class="p">(</span><span class="nb">apply</span> <span class="nv">disj</span> <span class="nv">args</span><span class="p">))))))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">conjoin</span> <span class="p">(</span><span class="nv">fn</span> <span class="k">&amp;rest</span> <span class="nv">fns</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">null</span> <span class="nv">fns</span><span class="p">)</span>
      <span class="nv">fn</span>
      <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">conj</span> <span class="p">(</span><span class="nb">apply</span> <span class="nf">#&#39;</span><span class="nv">conjoin</span> <span class="nv">fns</span><span class="p">)))</span>
        <span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="k">&amp;rest</span> <span class="nv">args</span><span class="p">)</span>
            <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nb">apply</span> <span class="nv">fn</span> <span class="nv">args</span><span class="p">)</span> <span class="p">(</span><span class="nb">apply</span> <span class="nv">conj</span> <span class="nv">args</span><span class="p">))))))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">curry</span> <span class="p">(</span><span class="nv">fn</span> <span class="k">&amp;rest</span> <span class="nv">args</span><span class="p">)</span>
  <span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="k">&amp;rest</span> <span class="nv">args2</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">apply</span> <span class="nv">fn</span> <span class="p">(</span><span class="nb">append</span> <span class="nv">args</span> <span class="nv">args2</span><span class="p">))))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">rcurry</span> <span class="p">(</span><span class="nv">fn</span> <span class="k">&amp;rest</span> <span class="nv">args</span><span class="p">)</span>
  <span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="k">&amp;rest</span> <span class="nv">args2</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">apply</span> <span class="nv">fn</span> <span class="p">(</span><span class="nb">append</span> <span class="nv">args2</span> <span class="nv">args</span><span class="p">))))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">always</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span> <span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="k">&amp;rest</span> <span class="nv">args</span><span class="p">)</span> <span class="nv">x</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p><strong>图 6.2 Dylan 函数建构器</strong></p>
                              <p>首先， <code class="docutils literal"><span class="pre">compose</span></code>
                                接受一个或多个函数，并返回一个依序将其参数应用的新函数，即，</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nv">compose</span> <span class="nf">#&#39;</span><span class="nv">a</span> <span class="nf">#&#39;</span><span class="nv">b</span> <span class="nf">#&#39;</span><span class="nv">c</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>返回一个函数等同于</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="k">&amp;rest</span> <span class="nv">args</span><span class="p">)</span> <span class="p">(</span><span class="nv">a</span> <span class="p">(</span><span class="nv">b</span> <span class="p">(</span><span class="nb">apply</span> <span class="nf">#&#39;</span><span class="nv">c</span> <span class="nv">args</span><span class="p">))))</span>
</pre>
                                </div>
                              </div>
                              <p>这代表着 <code class="docutils literal"><span class="pre">compose</span></code>
                                的最后一个实参，可以是任意长度，但其它函数只能接受一个实参。</p>
                              <p>下面我们建构了一个函数，先给取参数的平方根，取整后再放回列表里，接著返回:</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">mapcar</span> <span class="p">(</span><span class="nv">compose</span> <span class="nf">#&#39;</span><span class="nb">list</span> <span class="nf">#&#39;</span><span class="nb">round</span> <span class="nf">#&#39;</span><span class="nb">sqrt</span><span class="p">)</span>
          <span class="o">&#39;</span><span class="p">(</span><span class="mi">4</span> <span class="mi">9</span> <span class="mi">16</span> <span class="mi">25</span><span class="p">))</span>
<span class="p">((</span><span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="p">(</span><span class="mi">5</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p>接下来的两个函数， <code class="docutils literal"><span class="pre">disjoin</span></code> 及
                                <code class="docutils literal"><span class="pre">conjoin</span></code> 同接受一个或多个谓词作为参数：
                                <code class="docutils literal"><span class="pre">disjoin</span></code> 当任一谓词返回真时，返回真，而
                                <code class="docutils literal"><span class="pre">conjoin</span></code> 当所有谓词返回真时，返回真。
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">mapcar</span> <span class="p">(</span><span class="nv">disjoin</span> <span class="nf">#&#39;</span><span class="nb">integerp</span> <span class="nf">#&#39;</span><span class="nb">symbolp</span><span class="p">)</span>
          <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="s">&quot;a&quot;</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">))</span>
<span class="p">(</span><span class="no">T</span> <span class="no">NIL</span> <span class="no">T</span> <span class="no">T</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">mapcar</span> <span class="p">(</span><span class="nv">conjoin</span> <span class="nf">#&#39;</span><span class="nb">integerp</span> <span class="nf">#&#39;</span><span class="nb">symbolp</span><span class="p">)</span>
          <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="s">&quot;a&quot;</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">))</span>
<span class="p">(</span><span class="no">NIL</span> <span class="no">NIL</span> <span class="no">NIL</span> <span class="no">T</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>若考虑将谓词定义成集合， <code class="docutils literal"><span class="pre">disjoin</span></code>
                                返回传入参数的联集（union），而 <code
                                  class="docutils literal"><span class="pre">conjoin</span></code>
                                则是返回传入参数的交集（intersection）。</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre>      <span class="nb">cddr</span> <span class="nb">=</span> <span class="p">(</span><span class="nv">compose</span> <span class="nf">#&#39;</span><span class="nb">cdr</span> <span class="nf">#&#39;</span><span class="nb">cdr</span><span class="p">)</span>
      <span class="nb">nth</span>  <span class="nb">=</span> <span class="p">(</span><span class="nv">compose</span> <span class="nf">#&#39;</span><span class="nb">car</span> <span class="nf">#&#39;</span><span class="nb">nthcdr</span><span class="p">)</span>
      <span class="nb">atom</span> <span class="nb">=</span> <span class="p">(</span><span class="nv">compose</span> <span class="nf">#&#39;</span><span class="nb">not</span> <span class="nf">#&#39;</span><span class="nb">consp</span><span class="p">)</span>
           <span class="nb">=</span> <span class="p">(</span><span class="nv">rcurry</span> <span class="nf">#&#39;</span><span class="nb">typep</span> <span class="ss">&#39;atom</span><span class="p">)</span>
        <span class="nb">&lt;=</span> <span class="nb">=</span> <span class="p">(</span><span class="nv">disjoin</span> <span class="nf">#&#39;</span><span class="nb">&lt;</span> <span class="nf">#&#39;</span><span class="nb">=</span><span class="p">)</span>
     <span class="nb">listp</span> <span class="nb">=</span> <span class="p">(</span><span class="nv">disjoin</span> <span class="nf">#&#39;</span><span class="nb">&lt;</span> <span class="nf">#&#39;</span><span class="nb">=</span><span class="p">)</span>
           <span class="nb">=</span> <span class="p">(</span><span class="nv">rcurry</span> <span class="nf">#&#39;</span><span class="nb">typep</span> <span class="ss">&#39;list</span><span class="p">)</span>
        <span class="nb">1+</span> <span class="nb">=</span> <span class="p">(</span><span class="nv">curry</span> <span class="nf">#&#39;</span><span class="nb">+</span> <span class="mi">1</span><span class="p">)</span>
           <span class="nb">=</span> <span class="p">(</span><span class="nv">rcurry</span> <span class="nf">#&#39;</span><span class="nb">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="nb">1-</span> <span class="nb">=</span> <span class="p">(</span><span class="nv">rcurry</span> <span class="nf">#&#39;</span><span class="nb">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="nb">mapcan</span> <span class="nb">=</span> <span class="p">(</span><span class="nv">compose</span> <span class="p">(</span><span class="nv">curry</span> <span class="nf">#&#39;</span><span class="nb">apply</span> <span class="nf">#&#39;</span><span class="nb">nconc</span><span class="p">)</span> <span class="nf">#&#39;</span><span class="nb">mapcar</span>
<span class="nb">complement</span> <span class="nb">=</span> <span class="p">(</span><span class="nv">curry</span> <span class="nf">#&#39;</span><span class="nv">compose</span> <span class="nf">#&#39;</span><span class="nb">not</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p><strong>图 6.3 某些等价函数</strong></p>
                              <p>函数 <code class="docutils literal"><span class="pre">curry</span></code> 与 <code
                                  class="docutils literal"><span class="pre">rcurry</span></code> （“right
                                curry”）精神上与前一小节的 <code
                                  class="docutils literal"><span class="pre">make-adder</span></code>
                                相同。两者皆接受一个函数及某些参数，并返回一个期望剩余参数的新函数。下列任一个函数等同于 <code
                                  class="docutils literal"><span class="pre">(make-adder</span> <span class="pre">3)</span></code>
                                :</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nv">curry</span> <span class="nf">#&#39;</span><span class="nb">+</span> <span class="mi">3</span><span class="p">)</span>
<span class="p">(</span><span class="nv">rcurry</span> <span class="nf">#&#39;</span><span class="nb">+</span> <span class="mi">3</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>当函数的参数顺序重要时，很明显可以看出 <code
                                  class="docutils literal"><span class="pre">curry</span></code> 与 <code
                                  class="docutils literal"><span class="pre">rcurry</span></code> 的差别。如果我们 <code
                                  class="docutils literal"><span class="pre">curry</span> <span class="pre">#'-</span></code>
                                ，我们得到一个用其参数减去某特定数的函数，</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">funcall</span> <span class="p">(</span><span class="nv">curry</span> <span class="nf">#&#39;</span><span class="nb">-</span> <span class="mi">3</span><span class="p">)</span> <span class="mi">2</span><span class="p">)</span>
<span class="mi">1</span>
</pre>
                                </div>
                              </div>
                              <p>而当我们 <code
                                  class="docutils literal"><span class="pre">rcurry</span> <span class="pre">#'-</span></code>
                                时，我们得到一个用某特定数减去其参数的函数:</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">funcall</span> <span class="p">(</span><span class="nv">rcurry</span> <span class="nf">#&#39;</span><span class="nb">-</span> <span class="mi">3</span><span class="p">)</span> <span class="mi">2</span><span class="p">)</span>
<span class="mi">-1</span>
</pre>
                                </div>
                              </div>
                              <p>最后， <code class="docutils literal"><span class="pre">always</span></code> 函数是 Common
                                Lisp 函数 <code class="docutils literal"><span class="pre">constantly</span></code>
                                。接受一个参数并原封不动返回此参数的函数。和 <code
                                  class="docutils literal"><span class="pre">identity</span></code>
                                一样，在很多需要传入函数参数的情况下很有用。</p>
                            </div>
                            <div class="section" id="dynamic-scope">
                              <h4>6.7 动态作用域 (Dynamic Sc​​ope)<a class="headerlink" href="#dynamic-scope"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>2.11 小节解释过局部与全局变量的差别。实际的差别是词法作用域（lexical scope）的词法变量（lexical variable），与动态作用域（dynamic
                                scope）的特别变量（special variable）的区别。但这俩几乎是没有区别，因为局部变量几乎总是是词法变量，而全局变量总是是特别变量。</p>
                              <p>在词法作用域下，一个符号引用到上下文中符号名字出现的地方。局部变量缺省有着词法作用域。所以如果我们在一个环境里定义一个函数，其中有一个变量叫做 <code
                                  class="docutils literal"><span class="pre">x</span></code> ，</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">x</span> <span class="mi">10</span><span class="p">))</span>
  <span class="p">(</span><span class="nb">defun</span> <span class="nv">foo</span> <span class="p">()</span>
    <span class="nv">x</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p>则无论 <code class="docutils literal"><span class="pre">foo</span></code> 被调用时有存在其它的 <code
                                  class="docutils literal"><span class="pre">x</span></code> ，主体内的 <code
                                  class="docutils literal"><span class="pre">x</span></code> 都会引用到那个变量:</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">x</span> <span class="mi">20</span><span class="p">))</span> <span class="p">(</span><span class="nv">foo</span><span class="p">))</span>
<span class="mi">10</span>
</pre>
                                </div>
                              </div>
                              <p>而动态作用域，我们在环境中函数被调用的地方寻找变量。要使一个变量是动态作用域的，我们需要在任何它出现的上下文中声明它是 <code
                                  class="docutils literal"><span class="pre">special</span></code> 。如果我们这样定义 <code
                                  class="docutils literal"><span class="pre">foo</span></code> ：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">x</span> <span class="mi">10</span><span class="p">))</span>
  <span class="p">(</span><span class="nb">defun</span> <span class="nv">foo</span> <span class="p">()</span>
    <span class="p">(</span><span class="k">declare</span> <span class="p">(</span><span class="k">special</span> <span class="nv">x</span><span class="p">))</span>
    <span class="nv">x</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p>则函数内的 <code class="docutils literal"><span class="pre">x</span></code>
                                就不再引用到函数定义里的那个词法变量，但会引用到函数被调用时，当下所存在的任何特别变量 <code
                                  class="docutils literal"><span class="pre">x</span></code> :</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">x</span> <span class="mi">20</span><span class="p">))</span>
    <span class="p">(</span><span class="k">declare</span> <span class="p">(</span><span class="k">special</span> <span class="nv">x</span><span class="p">))</span>
    <span class="p">(</span><span class="nv">foo</span><span class="p">))</span>
<span class="mi">20</span>
</pre>
                                </div>
                              </div>
                              <p>新的变量被创建出来之后， 一个 <code class="docutils literal"><span class="pre">declare</span></code>
                                调用可以在代码的任何地方出现。 <code class="docutils literal"><span class="pre">special</span></code>
                                声明是独一无二的，因为它可以改变程序的行为。 13 章将讨论其它种类的声明。所有其它的声明，只是给编译器的建议；或许可以使程序运行的更快，但不会改变程序的行为。</p>
                              <p>通过在顶层调用 <code class="docutils literal"><span class="pre">setf</span></code>
                                来配置全局变量，是隐式地将变量声明为特殊变量:</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">setf</span> <span class="nv">x</span> <span class="mi">30</span><span class="p">)</span>
<span class="mi">30</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="nv">foo</span><span class="p">)</span>
<span class="mi">30</span>
</pre>
                                </div>
                              </div>
                              <p>在一个文件里的代码，如果你不想依赖隐式的特殊声明，可以使用 <code
                                  class="docutils literal"><span class="pre">defparameter</span></code> 取代，让程序看起来更简洁。
                              </p>
                              <p>动态作用域什么时候会派上用场呢？通常用来暂时给某个全局变量赋新值。举例来说，有 11 个变量来控制对象印出的方式，包括了 <code
                                  class="docutils literal"><span class="pre">*print-base*</span></code> ，缺省是 <code
                                  class="docutils literal"><span class="pre">10</span></code> 。如果你想要用 16 进制显示数字，你可以重新绑定
                                <code class="docutils literal"><span class="pre">*print-base*</span></code> :
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="vg">*print-base*</span> <span class="mi">16</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">princ</span> <span class="mi">32</span><span class="p">))</span>
<span class="mi">20</span>
<span class="mi">32</span>
</pre>
                                </div>
                              </div>
                              <p>这里显示了两件事情，由 <code class="docutils literal"><span class="pre">princ</span></code>
                                产生的输出，以及它所返回的值。他们代表着同样的数字，第一次在被印出时，用 16 进制显示，而第二次，因为在 <code
                                  class="docutils literal"><span class="pre">let</span></code> 表达式外部，所以是用十进制显示，因为 <code
                                  class="docutils literal"><span class="pre">*print-base*</span></code> 回到之前的数值， <code
                                  class="docutils literal"><span class="pre">10</span></code> 。</p>
                            </div>
                            <div class="section" id="compilation">
                              <h4>6.8 编译 (Compilation)<a class="headerlink" href="#compilation"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>Common Lisp 函数可以独立被编译或挨个文件编译。如果你只是在顶层输入一个 <code
                                  class="docutils literal"><span class="pre">defun</span></code> 表达式：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">defun</span> <span class="nv">foo</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="mi">1</span><span class="p">))</span>
<span class="nv">FOO</span>
</pre>
                                </div>
                              </div>
                              <p>许多实现会创建一个直译的函数（interpreted function）。你可以将函数传给 <code
                                  class="docutils literal"><span class="pre">compiled-function-p</span></code>
                                来检查一个函数是否有被编译:</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">compiled-function-p</span> <span class="nf">#&#39;</span><span class="nv">foo</span><span class="p">)</span>
<span class="no">NIL</span>
</pre>
                                </div>
                              </div>
                              <p>若你将 <code class="docutils literal"><span class="pre">foo</span></code> 函数名传给 <code
                                  class="docutils literal"><span class="pre">compile</span></code> :</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">compile</span> <span class="ss">&#39;foo</span><span class="p">)</span>
<span class="nv">FOO</span>
</pre>
                                </div>
                              </div>
                              <p>则这个函数会被编译，而直译的定义会被编译出来的取代。编译与直译函数的行为一样，只不过对 <code
                                  class="docutils literal"><span class="pre">compiled-function-p</span></code> 来说不一样。
                              </p>
                              <p>你可以把列表作为参数传给 <code class="docutils literal"><span class="pre">compile</span></code> 。这种
                                <code class="docutils literal"><span class="pre">compile</span></code> 的用法在 161 页 (译注:
                                10.1 小节)。
                              </p>
                              <p>有一种函数你不能作为参数传给 <code class="docutils literal"><span class="pre">compile</span></code>
                                ：一个像是 <code class="docutils literal"><span class="pre">stamp</span></code> 或是 <code
                                  class="docutils literal"><span class="pre">reset</span></code> 这种，在顶层明确使用词法上下文输入的函数 (即
                                <code class="docutils literal"><span class="pre">let</span></code> ) <a
                                  class="footnote-reference" href="#id7" id="id4">[3]</a>
                                在一个文件里面定义这些函数，接着编译然后载入文件是可以的。这么限制直译的代码的是实作的原因，而不是因为在词法上下文里明确定义函数有什么问题。
                              </p>
                              <p>通常要编译 Lisp 代码不是挨个函数编译，而是使用 <code
                                  class="docutils literal"><span class="pre">compile-file</span></code>
                                编译整个文件。这个函数接受一个文件名，并创建一个原始码的编译版本 ── 通常会有同样的名称，但不同的扩展名。当编译过的文件被载入时， <code
                                  class="docutils literal"><span class="pre">compiled-function-p</span></code>
                                应给所有定义在文件内的函数返回真。</p>
                              <p>当一个函数包含在另一个函数内时，包含它的函数会被编译，而且内部的函数也会被编译。所以 <code
                                  class="docutils literal"><span class="pre">make-adder</span></code> (108
                                页)被编译时，它会返回编译的函数:</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">compile</span> <span class="ss">&#39;make-adder</span><span class="p">)</span>
<span class="nv">MAKE-ADDER</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="nb">compiled-function-p</span> <span class="p">(</span><span class="nv">make-adder</span> <span class="mi">2</span><span class="p">))</span>
<span class="no">T</span>
</pre>
                                </div>
                              </div>
                            </div>
                            <div class="section" id="using-recursion">
                              <h4>6.9 使用递归 (Using Recursion)<a class="headerlink" href="#using-recursion"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>比起多数别的语言，递归在 Lisp 中扮演了一个重要的角色。这主要有三个原因：</p>
                              <ol class="arabic simple">
                                <li>函数式程序设计。递归演算法有副作用的可能性较低。</li>
                                <li>递归数据结构。 Lisp 隐式地使用了指标，使得递归地定义数据结构变简单了。最常见的是用在列表：一个列表的递归定义，列表为空表，或是一个 <code
                                    class="docutils literal"><span class="pre">cons</span></code> ，其中 <code
                                    class="docutils literal"><span class="pre">cdr</span></code> 也是个列表。</li>
                                <li>优雅性。Lisp 程序员非常关心它们的程序是否美丽，而递归演算法通常比迭代演算法来得优雅。</li>
                              </ol>
                              <p>学生们起初会觉得递归很难理解。但 3.9 节指出了，如果你想要知道是否正确，不需要去想递归函数所有的调用过程。</p>
                              <p>同样的如果你想写一个递归函数。如果你可以描述问题是怎么递归解决的，通常很容易将解法转成代码。要使用递归来解决一个问题，你需要做两件事：</p>
                              <ol class="arabic simple">
                                <li>你必须要示范如何解决问题的一般情况，通过将问题切分成有限小并更小的子问题。</li>
                                <li>你必须要示范如何通过 ── 有限的步骤，来解决最小的问题 ── 基本用例。</li>
                              </ol>
                              <p>如果这两件事完成了，那问题就解决了。因为递归每次都将问题变得更小，而一个有限的问题终究会被解决的，而最小的问题仅需几个有限的步骤就能解决。</p>
                              <p>举例来说，下面这个找到一个正规列表（proper list）长度的递归算法，我们每次递归时，都可以找到更小列表的长度：</p>
                              <ol class="arabic simple">
                                <li>在一般情况下，一个正规列表的长度是它的 <code
                                    class="docutils literal"><span class="pre">cdr</span></code> 加一。</li>
                                <li>基本用例，空列表长度为 <code class="docutils literal"><span class="pre">0</span></code> 。</li>
                              </ol>
                              <p>当这个描述翻译成代码时，先处理基本用例；但公式化递归演算法时，我们通常从一般情况下手。</p>
                              <p>前述的演算法，明确地描述了一种找到正规列表长度的方法。当你定义一个递归函数时，你必须要确定你在分解问题时，问题实际上越变越小。取得一个正规列表的 <code
                                  class="docutils literal"><span class="pre">cdr</span></code> 会给出 <code
                                  class="docutils literal"><span class="pre">length</span></code>
                                更小的子问题，但取得环状列表（circular list）的 <code
                                  class="docutils literal"><span class="pre">cdr</span></code> 不会。</p>
                              <p>这里有两个递归算法的示例。假定参数是有限的。注意第二个示例，我们每次递归时，将问题分成两个更小的问题：</p>
                              <p>第一个例子， <code class="docutils literal"><span class="pre">member</span></code>
                                函数，我们说某物是列表的成员，需满足：如果它是第一个元素的成员或是 <code
                                  class="docutils literal"><span class="pre">member</span></code> 的 <code
                                  class="docutils literal"><span class="pre">cdr</span></code> 的成员。但空列表没有任何成员。</p>
                              <p>第二个例子， <code class="docutils literal"><span class="pre">copy-tree</span></code> 一个
                                <code class="docutils literal"><span class="pre">cons</span></code> 的 <code
                                  class="docutils literal"><span class="pre">copy-tree</span></code> ，是一个由 <code
                                  class="docutils literal"><span class="pre">cons</span></code> 的 <code
                                  class="docutils literal"><span class="pre">car</span></code> 的 <code
                                  class="docutils literal"><span class="pre">copy-tree</span></code> 与 <code
                                  class="docutils literal"><span class="pre">cdr</span></code> 的 <code
                                  class="docutils literal"><span class="pre">copy-tree</span></code> 所组成的。一个原子的 <code
                                  class="docutils literal"><span class="pre">copy-tree</span></code> 是它自己。
                              </p>
                              <p>一旦你可以这样描述算法，要写出递归函数只差一步之遥。</p>
                              <p>某些算法通常是这样表达最自然，而某些算法不是。你可能需要翻回前面，试试不使用递归来定义 <code
                                  class="docutils literal"><span class="pre">our-copy-tree</span></code> (41 页，译注: 3.8
                                小节)。另一方面来说，23 页 (译注: 2.13 节) 迭代版本的 <code
                                  class="docutils literal"><span class="pre">show-squares</span></code> 可能更容易比 24
                                页的递归版本要容易理解。某些时候是很难看出哪个形式比较自然，直到你试着去写出程序来。</p>
                              <p>如果你关心效率，有两个你需要考虑的议题。第一，尾递归（tail-recursive），会在 13.2
                                节讨论。一个好的编译器，使用循环或是尾递归的速度，应该是没有或是区别很小的。然而如果你需要使函数变成尾递归的形式时，或许直接用迭代会更好。</p>
                              <p>另一个需要铭记在心的议题是，最显而易见的递归算法，不一定是最有效的。经典的例子是费氏函数。它是这样递归地被定义的，</p>
                              <blockquote>
                                <div>
                                  <ol class="arabic simple">
                                    <li>Fib(0) = Fib(1) = 1</li>
                                    <li>Fib(n) = Fib(n-1)+Fib(n-2)</li>
                                  </ol>
                                </div>
                              </blockquote>
                              <p>直接翻译这个定义，</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">fib</span> <span class="p">(</span><span class="nv">n</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">&lt;=</span> <span class="nv">n</span> <span class="mi">1</span><span class="p">)</span>
      <span class="mi">1</span>
      <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nv">fib</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">n</span> <span class="mi">1</span><span class="p">))</span>
         <span class="p">(</span><span class="nv">fib</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">n</span> <span class="mi">2</span><span class="p">)))))</span>
</pre>
                                </div>
                              </div>
                              <p>这样是效率极差的。一次又一次的重复计算。如果你要找 <code
                                  class="docutils literal"><span class="pre">(fib</span> <span class="pre">10)</span></code>
                                ，这个函数计算 <code
                                  class="docutils literal"><span class="pre">(fib</span> <span class="pre">9)</span></code>
                                与 <code
                                  class="docutils literal"><span class="pre">(fib</span> <span class="pre">8)</span></code>
                                。但要计算出 <code
                                  class="docutils literal"><span class="pre">(fib</span> <span class="pre">9)</span></code>
                                ，它需要再次计算 <code
                                  class="docutils literal"><span class="pre">(fib</span> <span class="pre">8)</span></code>
                                ，等等。</p>
                              <p>下面是一个算出同样结果的迭代版本:</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">fib</span> <span class="p">(</span><span class="nv">n</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">do</span> <span class="p">((</span><span class="nv">i</span> <span class="nv">n</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">i</span> <span class="mi">1</span><span class="p">))</span>
       <span class="p">(</span><span class="nv">f1</span> <span class="mi">1</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">f1</span> <span class="nv">f2</span><span class="p">))</span>
       <span class="p">(</span><span class="nv">f2</span> <span class="mi">1</span> <span class="nv">f1</span><span class="p">))</span>
      <span class="p">((</span><span class="nb">&lt;=</span> <span class="nv">i</span> <span class="mi">1</span><span class="p">)</span> <span class="nv">f1</span><span class="p">)))</span>
</pre>
                                </div>
                              </div>
                              <p>迭代的版本不如递归版本来得直观，但是效率远远高出许多。这样的事情在实践中常发生吗？非常少 ── 这也是为什么所有的教科书都使用一样的例子 ── 但这是需要注意的事。</p>
                            </div>
                            <div class="section" id="chapter-6-summary">
                              <h4>Chapter 6 总结 (Summary)<a class="headerlink" href="#chapter-6-summary"
                                  title="Permalink to this headline">¶</a></h4>
                              <ol class="arabic simple">
                                <li>命名函数是一个存在符号的 <code
                                    class="docutils literal"><span class="pre">symbol-function</span></code> 部分的函数。
                                  <code class="docutils literal"><span class="pre">defun</span></code>
                                  宏隐藏了这样的细节。它也允许你定义文档字符串（documentation string），并指定 <code
                                    class="docutils literal"><span class="pre">setf</span></code> 要怎么处理函数调用。
                                </li>
                                <li>定义局部函数是有可能的，与定义局部变量有相似的精神。</li>
                                <li>函数可以有选择性参数（optional）、剩余（rest）以及关键字（keyword）参数。</li>
                                <li>实用函数是 Lisp 的扩展。他们是由下而上编程的小规模示例。</li>
                                <li>只要有某物引用到词法变量时，它们会一直存在。闭包是引用到自由变量的函数。你可以写出返回闭包的函数。</li>
                                <li>Dylan 提供了构造函数的函数。很简单就可以使用闭包，然后在 Common Lisp 中实现它们。</li>
                                <li>特别变量（special variable）有动态作用域 (dynamic scope)。</li>
                                <li>Lisp 函数可以单独编译，或（更常见）编译整个文件。</li>
                                <li>一个递归演算法通过将问题细分成更小丶更小的子问题来解决问题。</li>
                              </ol>
                            </div>
                            <div class="section" id="chapter-6-exercises">
                              <h4>Chapter 6 练习 (Exercises)<a class="headerlink" href="#chapter-6-exercises"
                                  title="Permalink to this headline">¶</a></h4>
                              <ol class="arabic simple">
                                <li>定义一个 <code class="docutils literal"><span class="pre">tokens</span></code> 版本 (67
                                  页)，接受 <code class="docutils literal"><span class="pre">:test</span></code> 与 <code
                                    class="docutils literal"><span class="pre">:start</span></code> 参数，缺省分别是 <code
                                    class="docutils literal"><span class="pre">#'constituent</span></code> 与 <code
                                    class="docutils literal"><span class="pre">0</span></code> 。(译注: 67 页在 4.5 小节)</li>
                                <li>定义一个 <code class="docutils literal"><span class="pre">bin-search</span></code> (60
                                  页)的版本，接受 <code class="docutils literal"><span class="pre">:key</span></code> , <code
                                    class="docutils literal"><span class="pre">:test</span></code> , <code
                                    class="docutils literal"><span class="pre">start</span></code> 与 <code
                                    class="docutils literal"><span class="pre">end</span></code> 参数，有着一般的意义与缺省值。(译注: 60
                                  页在 4.1 小节)</li>
                                <li>定义一个函数，接受任何数目的参数，并返回传入的参数。</li>
                                <li>修改 <code class="docutils literal"><span class="pre">most</span></code> 函数 (105
                                  页)，使其返回 2 个数值，一个列表中最高分的两个元素。(译注: 105 页在 6.4 小节)</li>
                                <li>用 <code class="docutils literal"><span class="pre">filter</span></code> (105 页) 来定义
                                  <code class="docutils literal"><span class="pre">remove-if</span></code> （没有关键字）。(译注:
                                  105 页在 6.4 小节)
                                </li>
                                <li>定义一个函数，接受一个参数丶一个数字，并返回目前传入参数中最大的那个。</li>
                                <li>定义一个函数，接受一个参数丶一个数字，若传入参数比上个参数大时，返回真。函数第一次调用时应返回 <code
                                    class="docutils literal"><span class="pre">nil</span></code> 。</li>
                                <li>假设 <code class="docutils literal"><span class="pre">expensive</span></code>
                                  是一个接受一个参数的函数，一个介于 0 至 100 的整数（包含 100)，返回一个耗时的计算结果。定义一个函数 <code
                                    class="docutils literal"><span class="pre">frugal</span></code>
                                  来返回同样的答案，但仅在没见过传入参数时调用 <code
                                    class="docutils literal"><span class="pre">expensive</span></code> 。</li>
                                <li>定义一个像是 <code class="docutils literal"><span class="pre">apply</span></code>
                                  的函数，但在任何数字印出前，缺省用 8 进制印出。</li>
                              </ol>
                              <p class="rubric">脚注</p>
                              <table class="docutils footnote" frame="void" id="id5" rules="none">
                                <colgroup>
                                  <col class="label" />
                                  <col />
                                </colgroup>
                                <tbody valign="top">
                                  <tr>
                                    <td class="label"><a class="fn-backref" href="#id2">[1]</a></td>
                                    <td>在这个情况下， <code class="docutils literal"><span class="pre">nreverse</span></code>
                                      (在 222 页描述)和 <code
                                        class="docutils literal"><span class="pre">reverse</span></code> 做一样的事情，但更有效率。
                                    </td>
                                  </tr>
                                </tbody>
                              </table>
                              <table class="docutils footnote" frame="void" id="id6" rules="none">
                                <colgroup>
                                  <col class="label" />
                                  <col />
                                </colgroup>
                                <tbody valign="top">
                                  <tr>
                                    <td class="label"><a class="fn-backref" href="#id3">[2]</a></td>
                                    <td>“闭包”这个名字是早期的 Lisp 方言流传而来。它是从闭包需要在动态作用域里实现的方式衍生而来。</td>
                                  </tr>
                                </tbody>
                              </table>
                              <table class="docutils footnote" frame="void" id="id7" rules="none">
                                <colgroup>
                                  <col class="label" />
                                  <col />
                                </colgroup>
                                <tbody valign="top">
                                  <tr>
                                    <td class="label"><a class="fn-backref" href="#id4">[3]</a></td>
                                    <td>以前的 ANSI Common Lisp， <code
                                        class="docutils literal"><span class="pre">compile</span></code>
                                      的第一个参数也不能是一个已经编译好的函数。</td>
                                  </tr>
                                </tbody>
                              </table>
                            </div>
                          </div>
                          <div class="section">
                            <h3 id="7">第七章：输入与输出</h3>
                            <p>Common Lisp 有着威力强大的 I/O 工具。针对输入以及一些普遍读取字符的函数，我们有 <code
                                class="docutils literal"><span class="pre">read</span></code> ，包含了一个完整的解析器
                              (parser)。针对输出以及一些普遍写出字符的函数，我们有 <code
                                class="docutils literal"><span class="pre">format</span></code>
                              ，它自己几乎就是一个语言。本章介绍了所有基本的概念。</p>
                            <p>Common Lisp 有两种流 (streams)，字符流与二进制流。本章描述了字符流的操作；二进制流的操作涵盖在 14.2 节。</p>
                            <div class="section" id="streams">
                              <h4>7.1 流 (Streams)<a class="headerlink" href="#streams"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>流是用来表示字符来源或终点的 Lisp
                                对象。要从文件读取或写入，你将文件作为流打开。但流与文件是不一样的。当你在顶层读入或印出时，你也可以使用流。你甚至可以创建可以读取或写入字符串的流。</p>
                              <p>输入缺省是从 <code class="docutils literal"><span class="pre">*standard-input*</span></code>
                                流读取。输出缺省是在 <code
                                  class="docutils literal"><span class="pre">*standard-output*</span></code>
                                流。最初它们大概会在相同的地方：一个表示顶层的流。</p>
                              <p>我们已经看过 <code class="docutils literal"><span class="pre">read</span></code> 与 <code
                                  class="docutils literal"><span class="pre">format</span></code>
                                是如何在顶层读取与印出。前者接受一个应是流的选择性参数，缺省是 <code
                                  class="docutils literal"><span class="pre">*standard-input*</span></code> 。 <code
                                  class="docutils literal"><span class="pre">format</span></code> 的第一个参数也可以是一个流，但当它是
                                <code class="docutils literal"><span class="pre">t</span></code> 时，输出被送到 <code
                                  class="docutils literal"><span class="pre">*standard-output*</span></code>
                                。所以我们目前为止都只用到缺省的流而已。我们可以在任何流上面做同样的 I/O 操作。
                              </p>
                              <p>路径名（pathname）是一种指定一个文件的可移植方式。路径名包含了六个部分：host、device、directory、name、type 及
                                version。你可以通过调用 <code
                                  class="docutils literal"><span class="pre">make-pathname</span></code>
                                搭配一个或多个对应的关键字参数来产生一个路径。在最简单的情况下，你可以只指明名字，让其他的部分留为缺省：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">setf</span> <span class="nv">path</span> <span class="p">(</span><span class="nb">make-pathname</span> <span class="ss">:name</span> <span class="s">&quot;myfile&quot;</span><span class="p">))</span>
      <span class="l-Other">#P&quot;myfile&quot;</span>
</pre>
                                </div>
                              </div>
                              <p>开启一个文件的基本函数是 <code class="docutils literal"><span class="pre">open</span></code>
                                。它接受一个路径名 <a class="footnote-reference" href="#id5" id="id2">[1]</a>
                                以及大量的选择性关键字参数，而若是开启成功时，返回一个指向文件的流。</p>
                              <p>你可以在创建流时，指定你想要怎么使用它。 无论你是要写入流、从流读取或者同时进行读写操作，都可以通过 <code
                                  class="docutils literal"><span class="pre">direction</span></code> 参数设置。三个对应的数值是 <code
                                  class="docutils literal"><span class="pre">:input</span></code> , <code
                                  class="docutils literal"><span class="pre">:output</span></code> , <code
                                  class="docutils literal"><span class="pre">:io</span></code> 。如果是用来输出的流， <code
                                  class="docutils literal"><span class="pre">if-exists</span></code>
                                参数说明了如果文件已经存在时该怎么做；通常它应该是 <code
                                  class="docutils literal"><span class="pre">:supersede</span></code> (译注:
                                取代)。所以要创建一个可以写至 <code
                                  class="docutils literal"><span class="pre">&quot;myfile&quot;</span></code> 文件的流，你可以：
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre>&gt; (setf str (open path :direction :output
                       :if-exists :supersede))
#&lt;Stream C017E6&gt;
</pre>
                                </div>
                              </div>
                              <p>流的打印表示法因实现而异。</p>
                              <p>现在我们可以把这个流作为第一个参数传给 <code
                                  class="docutils literal"><span class="pre">format</span></code> ，它会在流印出，而不是顶层：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">format</span> <span class="nv">str</span> <span class="s">&quot;Something~%&quot;</span><span class="p">)</span>
<span class="no">NIL</span>
</pre>
                                </div>
                              </div>
                              <p>如果我们在此时检查这个文件，可能有输出，也可能没有。某些实现会将输出累积成一块 (chunks)再输出。直到我们将流关闭，它也许一直不会出现：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">close</span> <span class="nv">str</span><span class="p">)</span>
<span class="no">NIL</span>
</pre>
                                </div>
                              </div>
                              <p>当你使用完时，永远记得关闭文件；在你还没关闭之前，内容是不保证会出现的。现在如果我们检查文件 &#8220;myfile&#8221; ，应该有一行：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nv">Something</span>
</pre>
                                </div>
                              </div>
                              <p>如果我们只想从一个文件读取，我们可以开启一个具有 <code
                                  class="docutils literal"><span class="pre">:direction</span> <span class="pre">:input</span></code>
                                的流 ：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre>&gt; (setf str (open path :direction :input))
#&lt;Stream C01C86&gt;
</pre>
                                </div>
                              </div>
                              <p>我们可以对一个文件使用任何输入函数。7.2 节会更详细的描述输入。这里作为一个示例，我们将使用 <code
                                  class="docutils literal"><span class="pre">read-line</span></code> 从文件来读取一行文字：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">read-line</span> <span class="nv">str</span><span class="p">)</span>
<span class="s">&quot;Something&quot;</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="nb">close</span> <span class="nv">str</span><span class="p">)</span>
<span class="no">NIL</span>
</pre>
                                </div>
                              </div>
                              <p>当你读取完毕时，记得关闭文件。</p>
                              <p>大部分时间我们不使用 <code class="docutils literal"><span class="pre">open</span></code> 与 <code
                                  class="docutils literal"><span class="pre">close</span></code> 来操作文件的 I/O 。 <code
                                  class="docutils literal"><span class="pre">with-open-file</span></code>
                                宏通常更方便。它的第一个参数应该是一个列表，包含了变数名、伴随着你想传给 <code
                                  class="docutils literal"><span class="pre">open</span></code>
                                的参数。在这之后，它接受一个代码主体，它会被绑定至流的变数一起被求值，其中流是通过将剩余的参数传给 <code
                                  class="docutils literal"><span class="pre">open</span></code>
                                来创建的。之后这个流会被自动关闭。所以整个文件写入动作可以表示为：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">with-open-file</span> <span class="p">(</span><span class="nv">str</span> <span class="nv">path</span> <span class="ss">:direction</span> <span class="ss">:output</span>
                          <span class="ss">:if-exists</span> <span class="ss">:supersede</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">format</span> <span class="nv">str</span> <span class="s">&quot;Something~%&quot;</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p><code class="docutils literal"><span class="pre">with-open-file</span></code> 宏将 <code
                                  class="docutils literal"><span class="pre">close</span></code> 放在 <code
                                  class="docutils literal"><span class="pre">unwind-protect</span></code> 里 (参见 92 页，译注:
                                5.6 节)，即使一个错误打断了主体的求值，文件是保证会被关闭的。</p>
                            </div>
                            <div class="section" id="input">
                              <h4>7.2 输入 (Input)<a class="headerlink" href="#input"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>两个最受欢迎的输入函数是 <code class="docutils literal"><span class="pre">read-line</span></code> 及
                                <code class="docutils literal"><span class="pre">read</span></code> 。前者读入换行符
                                (newline)之前的所有字符，并用字符串返回它们。它接受一个选择性流参数 (optional stream argument)；若流忽略时，缺省为 <code
                                  class="docutils literal"><span class="pre">*standard-input*</span></code> :
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="k">progn</span>
    <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;Please enter your name: &quot;</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">read-line</span><span class="p">))</span>
<span class="nv">Please</span> <span class="nv">enter</span> <span class="nv">your</span> <span class="nv">name:</span> <span class="nv">Rodrigo</span> <span class="nv">de</span> <span class="nv">Bivar</span>
<span class="s">&quot;Rodrigo de Bivar&quot;</span>
<span class="no">NIL</span>
</pre>
                                </div>
                              </div>
                              <p>译注：Rodrigo de Bivar 人称熙德 (El Cid)，十一世纪的西班牙民族英雄。</p>
                              <p>如果你想要原封不动的输出，这是你该用的函数。(第二个返回值只在 <code
                                  class="docutils literal"><span class="pre">read-line</span></code> 在遇到换行符之前，用尽输入时返回真。)
                              </p>
                              <p>在一般情况下， <code class="docutils literal"><span class="pre">read-line</span></code>
                                接受四个选择性参数: 一个流；一个参数用来决定遇到 <code
                                  class="docutils literal"><span class="pre">end-of-file</span></code> 时，是否产生错误；若前一个参数为
                                <code class="docutils literal"><span class="pre">nil</span></code> 时，该返回什么；第四个参数 (在 235
                                页讨论)通常可以省略。
                              </p>
                              <p>所以要在顶层显示一个文件的内容，我们可以使用下面这个函数：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">pseudo-cat</span> <span class="p">(</span><span class="nv">file</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">with-open-file</span> <span class="p">(</span><span class="nv">str</span> <span class="nv">file</span> <span class="ss">:direction</span> <span class="ss">:input</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">do</span> <span class="p">((</span><span class="nv">line</span> <span class="p">(</span><span class="nb">read-line</span> <span class="nv">str</span> <span class="no">nil</span> <span class="ss">&#39;eof</span><span class="p">)</span>
               <span class="p">(</span><span class="nb">read-line</span> <span class="nv">str</span> <span class="no">nil</span> <span class="ss">&#39;eof</span><span class="p">)))</span>
        <span class="p">((</span><span class="nb">eql</span> <span class="nv">line</span> <span class="ss">&#39;eof</span><span class="p">))</span>
      <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;~A~%&quot;</span> <span class="nv">line</span><span class="p">))))</span>
</pre>
                                </div>
                              </div>
                              <p>如果我们想要把输入解析为 Lisp 对象，使用 <code
                                  class="docutils literal"><span class="pre">read</span></code>
                                。这个函数恰好读取一个表达式，在表达式结束时停止读取。所以可以读取多于或少于一行。而当然它所读取的内容必须是合法的 Lisp 语法。</p>
                              <p>如果我们在顶层使用 <code class="docutils literal"><span class="pre">read</span></code>
                                ，它会让我们在表达式里面，想用几个换行符就用几个：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">read</span><span class="p">)</span>
<span class="p">(</span><span class="nv">a</span>
<span class="nv">b</span>
<span class="nv">c</span><span class="p">)</span>
<span class="p">(</span><span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>换句话说，如果我们在一行里面输入许多表达式， <code
                                  class="docutils literal"><span class="pre">read</span></code>
                                会在第一个表达式之后，停止处理字符，留下剩余的字符给之后读取这个流的函数处理。所以如果我们在一行输入多个表达式，来回应 <code
                                  class="docutils literal"><span class="pre">ask-number</span></code> (20 页。译注：2.10
                                小节)所印出提示符，会发生如下情形:</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">ask-number</span><span class="p">)</span>
<span class="nv">Please</span> <span class="nv">enter</span> <span class="nv">a</span> <span class="nv">number.</span> <span class="nv">a</span> <span class="nv">b</span>
<span class="nv">Please</span> <span class="nv">enter</span> <span class="nv">a</span> <span class="nv">number.</span> <span class="nv">Please</span> <span class="nv">enter</span> <span class="nv">a</span> <span class="nv">number.</span> <span class="mi">43</span>
<span class="mi">43</span>
</pre>
                                </div>
                              </div>
                              <p>两个连续的提示符 (successive prompts)在第二行被印出。第一个 <code
                                  class="docutils literal"><span class="pre">read</span></code> 调用会返回 <code
                                  class="docutils literal"><span class="pre">a</span></code> ，而它不是一个数字，所以函数再次要求一个数字。但第一个
                                <code class="docutils literal"><span class="pre">read</span></code> 只读取到 <code
                                  class="docutils literal"><span class="pre">a</span></code> 的结尾。所以下一个 <code
                                  class="docutils literal"><span class="pre">read</span></code> 调用返回 <code
                                  class="docutils literal"><span class="pre">b</span></code> ，导致了下一个提示符。
                              </p>
                              <p>你或许想要避免使用 <code class="docutils literal"><span class="pre">read</span></code>
                                来直接处理使用者的输入。前述的函数若使用 <code
                                  class="docutils literal"><span class="pre">read-line</span></code>
                                来获得使用者输入会比较好，然后对结果字符串调用 <code
                                  class="docutils literal"><span class="pre">read-from-string</span></code>
                                。这个函数接受一个字符串，并返回第一个读取的表达式:</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">read-from-string</span> <span class="s">&quot;a b c&quot;</span><span class="p">)</span>
<span class="nv">A</span>
<span class="mi">2</span>
</pre>
                                </div>
                              </div>
                              <p>它同时返回第二个值，一个指出停止读取字符串时的位置的数字。</p>
                              <p>在一般情况下， <code class="docutils literal"><span class="pre">read-from-string</span></code>
                                可以接受两个选择性参数与三个关键字参数。两个选择性参数是 <code
                                  class="docutils literal"><span class="pre">read</span></code> 的第三、第四个参数: 一个
                                end-of-file (这个情况是字符串) 決定是否报错，若不报错该返回什么。关键字参数 <code
                                  class="docutils literal"><span class="pre">:start</span></code> 及 <code
                                  class="docutils literal"><span class="pre">:end</span></code> 可以用来划分从字符串的哪里开始读。</p>
                              <p>所有的这些输入函数是由基本函数 (primitive) <code
                                  class="docutils literal"><span class="pre">read-char</span></code> 所定义的，它读取一个字符。它接受四个与
                                <code class="docutils literal"><span class="pre">read</span></code> 及 <code
                                  class="docutils literal"><span class="pre">read-line</span></code> 一样的选择性参数。Common
                                Lisp 也定义一个函数叫做 <code class="docutils literal"><span class="pre">peek-char</span></code>
                                ，跟 <code class="docutils literal"><span class="pre">read-char</span></code>
                                类似，但不会将字符从流中移除。
                              </p>
                            </div>
                            <div class="section" id="output">
                              <h4>7.3 输出 (Output)<a class="headerlink" href="#output"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>三个最简单的输出函数是 <code class="docutils literal"><span class="pre">prin1</span></code> ,
                                <code class="docutils literal"><span class="pre">princ</span></code> 以及 <code
                                  class="docutils literal"><span class="pre">terpri</span></code>
                                。这三个函数的最后一个参数皆为选择性的流参数，缺省是 <code
                                  class="docutils literal"><span class="pre">*standard-output*</span></code> 。
                              </p>
                              <p><code class="docutils literal"><span class="pre">prin1</span></code> 与 <code
                                  class="docutils literal"><span class="pre">princ</span></code> 的差别大致在于 <code
                                  class="docutils literal"><span class="pre">prin1</span></code> 给程序产生输出，而 <code
                                  class="docutils literal"><span class="pre">princ</span></code> 给人类产生输出。所以举例来说， <code
                                  class="docutils literal"><span class="pre">prin1</span></code> 会印出字符串左右的双引号，而 <code
                                  class="docutils literal"><span class="pre">princ</span></code> 不会:</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">prin1</span> <span class="s">&quot;Hello&quot;</span><span class="p">)</span>
<span class="s">&quot;Hello&quot;</span>
<span class="s">&quot;Hello&quot;</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="nb">princ</span> <span class="s">&quot;Hello&quot;</span><span class="p">)</span>
<span class="nv">Hello</span>
<span class="s">&quot;Hello&quot;</span>
</pre>
                                </div>
                              </div>
                              <p>两者皆返回它们的第一个参数 (译注: 第二个值是返回值) ── 顺道一提，是用 <code
                                  class="docutils literal"><span class="pre">prin1</span></code> 印出。 <code
                                  class="docutils literal"><span class="pre">terpri</span></code> 仅印出一新行。</p>
                              <p>有这些函数的背景知识在解释更为通用的 <code
                                  class="docutils literal"><span class="pre">format</span></code>
                                是很有用的。这个函数几乎可以用在所有的输出。他接受一个流 (或 <code
                                  class="docutils literal"><span class="pre">t</span></code> 或 <code
                                  class="docutils literal"><span class="pre">nil</span></code> )、一个格式化字符串 (format
                                string)以及零个或多个额外的参数。格式化字符串可以包含特定的格式化指令 (format directives)，这些指令前面有波浪号 <code
                                  class="docutils literal"><span class="pre">~</span></code> 。某些格式化指令作为字符串的占位符
                                (placeholder)使用。这些位置会被格式化字符串之后，所给入参数的表示法所取代。</p>
                              <p>如果我们把 <code class="docutils literal"><span class="pre">t</span></code> 作为第一个参数，输出会被送至
                                <code class="docutils literal"><span class="pre">*standard-output*</span></code> 。如果我们给
                                <code class="docutils literal"><span class="pre">nil</span></code> ， <code
                                  class="docutils literal"><span class="pre">format</span></code>
                                会返回一个它会如何印出的字符串。为了保持简短，我们会在所有的示例里演示怎么做。
                              </p>
                              <p>由于每人的观点不同， <code class="docutils literal"><span class="pre">format</span></code>
                                可以是令人惊讶的强大或是极为可怕的复杂。有大量的格式化指令可用，而只有少部分会被大多数程序设计师使用。两个最常用的格式化指令是 <code
                                  class="docutils literal"><span class="pre">~A</span></code> 以及 <code
                                  class="docutils literal"><span class="pre">~%</span></code> 。(你使用 <code
                                  class="docutils literal"><span class="pre">~a</span></code> 或 <code
                                  class="docutils literal"><span class="pre">~A</span></code>
                                都没关系，但后者较常见，因为它让格式化指令看起来一目了然。) 一个 <code
                                  class="docutils literal"><span class="pre">~A</span></code> 是一个值的占位符，它会像是用 <code
                                  class="docutils literal"><span class="pre">princ</span></code> 印出一般。一个 <code
                                  class="docutils literal"><span class="pre">~%</span></code> 代表着一个换行符 (newline)。</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">format</span> <span class="no">nil</span> <span class="s">&quot;Dear ~A, ~% Our records indicate...&quot;</span>
                                              <span class="s">&quot;Mr. Malatesta&quot;</span><span class="p">)</span>
      <span class="s">&quot;Dear Mr. Malatesta,</span>
<span class="s">         Our records indicate...&quot;</span>
</pre>
                                </div>
                              </div>
                              <p>这里 <code class="docutils literal"><span class="pre">format</span></code>
                                返回了一个值，由一个含有换行符的字符串组成。</p>
                              <p><code class="docutils literal"><span class="pre">~S</span></code> 格式化指令像是 <code
                                  class="docutils literal"><span class="pre">~A</span></code> ，但它使用 <code
                                  class="docutils literal"><span class="pre">prin1</span></code> 印出对象，而不是 <code
                                  class="docutils literal"><span class="pre">princ</span></code> 印出:</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;~S  ~A&quot;</span> <span class="s">&quot;z&quot;</span> <span class="s">&quot;z&quot;</span><span class="p">)</span>
<span class="s">&quot;z&quot;</span> <span class="nv">z</span>
<span class="no">NIL</span>
</pre>
                                </div>
                              </div>
                              <p>格式化指令可以接受参数。 <code class="docutils literal"><span class="pre">~F</span></code> 用来印出向右对齐
                                (right-justified)的浮点数，可接受五个参数:</p>
                              <ol class="arabic simple">
                                <li>要印出字符的总数。缺省是数字的长度。</li>
                                <li>小数之后要印几位数。缺省是全部。</li>
                                <li>小数点要往右移几位 (即等同于将数字乘 10)。缺省是没有。</li>
                                <li>若数字太长无法满足第一个参数时，所要印出的字符。如果没有指定字符，一个过长的数字会尽可能使用它所需的空间被印出。</li>
                                <li>数字开始印之前左边的字符。缺省是空白。</li>
                              </ol>
                              <p>下面是一个有五个参数的罕见例子:</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nv">?</span> <span class="p">(</span><span class="nb">format</span> <span class="no">nil</span> <span class="s">&quot;~10,2,0,&#39;*,&#39; F&quot;</span> <span class="mf">26.21875</span><span class="p">)</span>
<span class="s">&quot;     26.22&quot;</span>
</pre>
                                </div>
                              </div>
                              <p>这是原本的数字取至小数点第二位、(小数点向左移 0 位)、在 10 个字符的空间里向右对齐，左边补满空白。注意作为参数给入是写成 <code
                                  class="docutils literal"><span class="pre">'*</span></code> 而不是 <code
                                  class="docutils literal"><span class="pre">#\*</span></code> 。由于数字塞得下 10
                                个字符，不需要使用第四个参数。</p>
                              <p>所有的这些参数都是选择性的。要使用缺省值你可以直接忽略对应的参数。如果我们想要做的是，印出一个小数点取至第二位的数字，我们可以说:</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">format</span> <span class="no">nil</span> <span class="s">&quot;~,2,,,F&quot;</span> <span class="mf">26.21875</span><span class="p">)</span>
<span class="s">&quot;26.22&quot;</span>
</pre>
                                </div>
                              </div>
                              <p>你也可以忽略一系列的尾随逗号 (trailing commas)，前面指令更常见的写法会是:</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">format</span> <span class="no">nil</span> <span class="s">&quot;~,2F&quot;</span> <span class="mf">26.21875</span><span class="p">)</span>
<span class="s">&quot;26.22&quot;</span>
</pre>
                                </div>
                              </div>
                              <p><strong>警告:</strong> 当 <code
                                  class="docutils literal"><span class="pre">format</span></code>
                                取整数时，它不保证会向上进位或向下舍入。就是说 <code
                                  class="docutils literal"><span class="pre">(format</span> <span class="pre">nil</span> <span class="pre">&quot;~,1F&quot;</span> <span class="pre">1.25)</span></code>
                                可能会是 <code class="docutils literal"><span class="pre">&quot;1.2&quot;</span></code> 或
                                <code class="docutils literal"><span class="pre">&quot;1.3&quot;</span></code> 。所以如果你使用
                                <code class="docutils literal"><span class="pre">format</span></code>
                                来显示资讯时，而使用者期望看到某种特定取整数方式的数字 (如: 金额数量)，你应该在印出之前先显式地取好整数。
                              </p>
                            </div>
                            <div class="section" id="example-string-substitution">
                              <h4>7.4 示例：字符串代换 (Example: String Substitution)<a class="headerlink"
                                  href="#example-string-substitution" title="Permalink to this headline">¶</a></h4>
                              <p>作为一个 I/O 的示例，本节演示如何写一个简单的程序来对文本文件做字符串替换。我们即将写一个可以将一个文件中，旧的字符串 <code
                                  class="docutils literal"><span class="pre">old</span></code> 换成某个新的字符串 <code
                                  class="docutils literal"><span class="pre">new</span></code>
                                的函数。最简单的实现方式是将输入文件里的每一个字符与 <code
                                  class="docutils literal"><span class="pre">old</span></code>
                                的第一个字符比较。如果没有匹配，我们可以直接印出该字符至输出。如果匹配了，我们可以将输入的下一个字符与 <code
                                  class="docutils literal"><span class="pre">old</span></code> 的第二个字符比较，等等。如果输入字符与 <code
                                  class="docutils literal"><span class="pre">old</span></code> 完全相等时，我们有一个成功的匹配，则我们印出
                                <code class="docutils literal"><span class="pre">new</span></code> 至文件。
                              </p>
                              <p>而要是 <code class="docutils literal"><span class="pre">old</span></code>
                                在匹配途中失败了，会发生什么事呢？举例来说，假设我们要找的模式 (pattern)是 <code
                                  class="docutils literal"><span class="pre">&quot;abac&quot;</span></code> ，而输入文件包含的是
                                <code class="docutils literal"><span class="pre">&quot;ababac&quot;</span></code>
                                。输入会一直到第四个字符才发现不匹配，也就是在模式中的 <code
                                  class="docutils literal"><span class="pre">c</span></code> 以及输入的 <code
                                  class="docutils literal"><span class="pre">b</span></code> 才发现。在此时我们可以将原本的 <code
                                  class="docutils literal"><span class="pre">a</span></code>
                                写至输出文件，因为我们已经知道这里没有匹配。但有些我们从输入读入的字符还是需要留着: 举例来说，第三个 <code
                                  class="docutils literal"><span class="pre">a</span></code>
                                ，确实是成功匹配的开始。所以在我们要实现这个算法之前，我们需要一个地方来储存，我们已经从输入读入的字符，但之后仍然需要的字符。
                              </p>
                              <p>一个暂时储存输入的队列 (queue)称作缓冲区 (buffer)。在这个情况里，因为我们知道我们不需要储存超过一个预定的字符量，我们可以使用一个叫做环状缓冲区 <code
                                  class="docutils literal"><span class="pre">ring</span> <span class="pre">buffer</span></code>
                                的资料结构。一个环状缓冲区实际上是一个向量。是使用的方式使其成为环状: 我们将之后的元素所输入进来的值储存起来，而当我们到达向量结尾时，我们重头开始。如果我们不需要储存超过
                                <code class="docutils literal"><span class="pre">n</span></code> 个值，则我们只需要一个长度为 <code
                                  class="docutils literal"><span class="pre">n</span></code> 或是大于 <code
                                  class="docutils literal"><span class="pre">n</span></code> 的向量，这样我们就不需要覆写正在用的值。
                              </p>
                              <p>在图 7.1 的代码，实现了环状缓冲区的操作。 <code
                                  class="docutils literal"><span class="pre">buf</span></code> 有五个字段 (field):
                                一个包含存入缓冲区的向量，四个其它字段用来放指向向量的索引 (indices)。两个索引是 <code
                                  class="docutils literal"><span class="pre">start</span></code> 与 <code
                                  class="docutils literal"><span class="pre">end</span></code> ，任何环状缓冲区的使用都会需要这两个索引:
                                <code class="docutils literal"><span class="pre">start</span></code>
                                指向缓冲区的第一个值，当我们取出一个值时， <code
                                  class="docutils literal"><span class="pre">start</span></code> 会递增 (incremented)；
                                <code class="docutils literal"><span class="pre">end</span></code>
                                指向缓冲区的最后一个值，当我们插入一个新值时， <code
                                  class="docutils literal"><span class="pre">end</span></code> 会递增。
                              </p>
                              <p>另外两个索引， <code class="docutils literal"><span class="pre">used</span></code> 以及 <code
                                  class="docutils literal"><span class="pre">new</span></code>
                                ，是我们需要给这个应用的基本环状缓冲区所加入的东西。它们会介于 <code
                                  class="docutils literal"><span class="pre">start</span></code> 与 <code
                                  class="docutils literal"><span class="pre">end</span></code> 之间。实际上，它总是符合</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre>start ≤ used ≤ new ≤ end
</pre>
                                </div>
                              </div>
                              <p>你可以把 <code class="docutils literal"><span class="pre">used</span></code> 与 <code
                                  class="docutils literal"><span class="pre">new</span></code> 想成是当前匹配 (current match) 的
                                <code class="docutils literal"><span class="pre">start</span></code> 与 <code
                                  class="docutils literal"><span class="pre">end</span></code> 。当我们开始一轮匹配时， <code
                                  class="docutils literal"><span class="pre">used</span></code> 会等于 <code
                                  class="docutils literal"><span class="pre">start</span></code> 而 <code
                                  class="docutils literal"><span class="pre">new</span></code> 会等于 <code
                                  class="docutils literal"><span class="pre">end</span></code> 。当下一个字符 (successive
                                character)匹配时，我们需要递增 <code class="docutils literal"><span class="pre">used</span></code>
                                。当 <code class="docutils literal"><span class="pre">used</span></code> 与 <code
                                  class="docutils literal"><span class="pre">new</span></code>
                                相等时，我们将开始匹配时，所有存在缓冲区的字符读入。我们不想要使用超过从匹配时所存在缓冲区的字符，或是重复使用同样的字符。因此这个 <code
                                  class="docutils literal"><span class="pre">new</span></code> 索引，开始等于 <code
                                  class="docutils literal"><span class="pre">end</span></code>
                                ，但它不会在一轮匹配我们插入新字符至缓冲区一起递增。
                              </p>
                              <p>函数 <code class="docutils literal"><span class="pre">bref</span></code>
                                接受一个缓冲区与一个索引，并返回索引所在位置的元素。借由使用 <code
                                  class="docutils literal"><span class="pre">index</span></code> 对向量的长度取 <code
                                  class="docutils literal"><span class="pre">mod</span></code> ，我们可以假装我们有一个任意长的缓冲区。调用
                                <code
                                  class="docutils literal"><span class="pre">(new-buf</span> <span class="pre">n)</span></code>
                                会产生一个新的缓冲区，能够容纳 <code class="docutils literal"><span class="pre">n</span></code> 个对象。
                              </p>
                              <p>要插入一个新值至缓冲区，我们将使用 <code
                                  class="docutils literal"><span class="pre">buf-insert</span></code> 。它将 <code
                                  class="docutils literal"><span class="pre">end</span></code> 递增，并把新的值放在那个位置 (译注:
                                递增完的位置)。相反的 <code class="docutils literal"><span class="pre">buf-pop</span></code>
                                返回一个缓冲区的第一个数值，接着将 <code class="docutils literal"><span class="pre">start</span></code>
                                递增。任何环状缓冲区都会有这两个函数。</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defstruct</span> <span class="nv">buf</span>
  <span class="nv">vec</span> <span class="p">(</span><span class="nv">start</span> <span class="mi">-1</span><span class="p">)</span> <span class="p">(</span><span class="nv">used</span> <span class="mi">-1</span><span class="p">)</span> <span class="p">(</span><span class="nv">new</span> <span class="mi">-1</span><span class="p">)</span> <span class="p">(</span><span class="nv">end</span> <span class="mi">-1</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">bref</span> <span class="p">(</span><span class="nv">buf</span> <span class="nv">n</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">svref</span> <span class="p">(</span><span class="nv">buf-vec</span> <span class="nv">buf</span><span class="p">)</span>
         <span class="p">(</span><span class="nb">mod</span> <span class="nv">n</span> <span class="p">(</span><span class="nb">length</span> <span class="p">(</span><span class="nv">buf-vec</span> <span class="nv">buf</span><span class="p">)))))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="p">(</span><span class="nb">setf</span> <span class="nv">bref</span><span class="p">)</span> <span class="p">(</span><span class="nv">val</span> <span class="nv">buf</span> <span class="nv">n</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nb">svref</span> <span class="p">(</span><span class="nv">buf-vec</span> <span class="nv">buf</span><span class="p">)</span>
               <span class="p">(</span><span class="nb">mod</span> <span class="nv">n</span> <span class="p">(</span><span class="nb">length</span> <span class="p">(</span><span class="nv">buf-vec</span> <span class="nv">buf</span><span class="p">))))</span>
        <span class="nv">val</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">new-buf</span> <span class="p">(</span><span class="nv">len</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">make-buf</span> <span class="ss">:vec</span> <span class="p">(</span><span class="nb">make-array</span> <span class="nv">len</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">buf-insert</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">b</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nv">bref</span> <span class="nv">b</span> <span class="p">(</span><span class="nb">incf</span> <span class="p">(</span><span class="nv">buf-end</span> <span class="nv">b</span><span class="p">)))</span> <span class="nv">x</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">buf-pop</span> <span class="p">(</span><span class="nv">b</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">prog1</span>
    <span class="p">(</span><span class="nv">bref</span> <span class="nv">b</span> <span class="p">(</span><span class="nb">incf</span> <span class="p">(</span><span class="nv">buf-start</span> <span class="nv">b</span><span class="p">)))</span>
    <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nv">buf-used</span> <span class="nv">b</span><span class="p">)</span> <span class="p">(</span><span class="nv">buf-start</span> <span class="nv">b</span><span class="p">)</span>
          <span class="p">(</span><span class="nv">buf-new</span>  <span class="nv">b</span><span class="p">)</span> <span class="p">(</span><span class="nv">buf-end</span>   <span class="nv">b</span><span class="p">))))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">buf-next</span> <span class="p">(</span><span class="nv">b</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">when</span> <span class="p">(</span><span class="nb">&lt;</span> <span class="p">(</span><span class="nv">buf-used</span> <span class="nv">b</span><span class="p">)</span> <span class="p">(</span><span class="nv">buf-new</span> <span class="nv">b</span><span class="p">))</span>
    <span class="p">(</span><span class="nv">bref</span> <span class="nv">b</span> <span class="p">(</span><span class="nb">incf</span> <span class="p">(</span><span class="nv">buf-used</span> <span class="nv">b</span><span class="p">)))))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">buf-reset</span> <span class="p">(</span><span class="nv">b</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nv">buf-used</span> <span class="nv">b</span><span class="p">)</span> <span class="p">(</span><span class="nv">buf-start</span> <span class="nv">b</span><span class="p">)</span>
        <span class="p">(</span><span class="nv">buf-new</span>  <span class="nv">b</span><span class="p">)</span> <span class="p">(</span><span class="nv">buf-end</span>   <span class="nv">b</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">buf-clear</span> <span class="p">(</span><span class="nv">b</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nv">buf-start</span> <span class="nv">b</span><span class="p">)</span> <span class="mi">-1</span> <span class="p">(</span><span class="nv">buf-used</span>  <span class="nv">b</span><span class="p">)</span> <span class="mi">-1</span>
        <span class="p">(</span><span class="nv">buf-new</span>   <span class="nv">b</span><span class="p">)</span> <span class="mi">-1</span> <span class="p">(</span><span class="nv">buf-end</span>   <span class="nv">b</span><span class="p">)</span> <span class="mi">-1</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">buf-flush</span> <span class="p">(</span><span class="nv">b</span> <span class="nv">str</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">do</span> <span class="p">((</span><span class="nv">i</span> <span class="p">(</span><span class="nb">1+</span> <span class="p">(</span><span class="nv">buf-used</span> <span class="nv">b</span><span class="p">))</span> <span class="p">(</span><span class="nb">1+</span> <span class="nv">i</span><span class="p">)))</span>
      <span class="p">((</span><span class="nb">&gt;</span> <span class="nv">i</span> <span class="p">(</span><span class="nv">buf-end</span> <span class="nv">b</span><span class="p">)))</span>
    <span class="p">(</span><span class="nb">princ</span> <span class="p">(</span><span class="nv">bref</span> <span class="nv">b</span> <span class="nv">i</span><span class="p">)</span> <span class="nv">str</span><span class="p">)))</span>
</pre>
                                </div>
                              </div>
                              <p><strong>图 7.1 环状缓冲区的操作</strong></p>
                              <p>接下来我们需要两个特别为这个应用所写的函数: <code
                                  class="docutils literal"><span class="pre">buf-next</span></code> 从缓冲区读取一个值而不取出，而
                                <code class="docutils literal"><span class="pre">buf-reset</span></code> 重置 <code
                                  class="docutils literal"><span class="pre">used</span></code> 与 <code
                                  class="docutils literal"><span class="pre">new</span></code> 到初始值，分别是 <code
                                  class="docutils literal"><span class="pre">start</span></code> 与 <code
                                  class="docutils literal"><span class="pre">end</span></code> 。如果我们已经把至 <code
                                  class="docutils literal"><span class="pre">new</span></code> 的值全部读取完毕时， <code
                                  class="docutils literal"><span class="pre">buf-next</span></code> 返回 <code
                                  class="docutils literal"><span class="pre">nil</span></code>
                                。区别这个值与实际的值不会产生问题，因为我们只把值存在缓冲区。
                              </p>
                              <p>最后 <code class="docutils literal"><span class="pre">buf-flush</span></code>
                                透过将所有作用的元素，写至由第二个参数所给入的流，而 <code
                                  class="docutils literal"><span class="pre">buf-clear</span></code> 通过重置所有的索引至 <code
                                  class="docutils literal"><span class="pre">-1</span></code> 将缓冲区清空。</p>
                              <p>在图 7.1 定义的函数被图 7.2 所使用，包含了字符串替换的代码。函数 <code
                                  class="docutils literal"><span class="pre">file-subst</span></code>
                                接受四个参数；一个查询字符串，一个替换字符串，一个输入文件以及一个输出文件。它创建了代表每个文件的流，然后调用 <code
                                  class="docutils literal"><span class="pre">stream-subst</span></code> 来完成实际的工作。</p>
                              <p>第二个函数 <code class="docutils literal"><span class="pre">stream-subst</span></code>
                                使用本节开始所勾勒的算法。它一次从输入流读一个字符。直到输入字符匹配要寻找的字符串时，直接写至输出流 (1)。当一个匹配开始时，有关字符在缓冲区 <code
                                  class="docutils literal"><span class="pre">buf</span></code> 排队等候 (2)。</p>
                              <p>变数 <code class="docutils literal"><span class="pre">pos</span></code>
                                指向我们想要匹配的字符在寻找字符串的所在位置。如果 <code
                                  class="docutils literal"><span class="pre">pos</span></code>
                                等于这个字符串的长度，我们有一个完整的匹配，则我们将替换字符串写至输出流，并清空缓冲区
                                (3)。如果在这之前匹配失败，我们可以将缓冲区的第一个元素取出，并写至输出流，之后我们重置缓冲区，并从 <code
                                  class="docutils literal"><span class="pre">pos</span></code> 等于 0 重新开始 (4)。</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">file-subst</span> <span class="p">(</span><span class="nv">old</span> <span class="nv">new</span> <span class="nv">file1</span> <span class="nv">file2</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">with-open-file</span> <span class="p">(</span><span class="nv">in</span> <span class="nv">file1</span> <span class="ss">:direction</span> <span class="ss">:input</span><span class="p">)</span>
     <span class="p">(</span><span class="nb">with-open-file</span> <span class="p">(</span><span class="nv">out</span> <span class="nv">file2</span> <span class="ss">:direction</span> <span class="ss">:output</span>
                                <span class="ss">:if-exists</span> <span class="ss">:supersede</span><span class="p">)</span>
       <span class="p">(</span><span class="nv">stream-subst</span> <span class="nv">old</span> <span class="nv">new</span> <span class="nv">in</span> <span class="nv">out</span><span class="p">))))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">stream-subst</span> <span class="p">(</span><span class="nv">old</span> <span class="nv">new</span> <span class="nv">in</span> <span class="nv">out</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let*</span> <span class="p">((</span><span class="nv">pos</span> <span class="mi">0</span><span class="p">)</span>
         <span class="p">(</span><span class="nv">len</span> <span class="p">(</span><span class="nb">length</span> <span class="nv">old</span><span class="p">))</span>
         <span class="p">(</span><span class="nv">buf</span> <span class="p">(</span><span class="nv">new-buf</span> <span class="nv">len</span><span class="p">))</span>
         <span class="p">(</span><span class="nv">from-buf</span> <span class="no">nil</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">do</span> <span class="p">((</span><span class="nv">c</span> <span class="p">(</span><span class="nb">read-char</span> <span class="nv">in</span> <span class="no">nil</span> <span class="ss">:eof</span><span class="p">)</span>
            <span class="p">(</span><span class="nb">or</span> <span class="p">(</span><span class="nb">setf</span> <span class="nv">from-buf</span> <span class="p">(</span><span class="nv">buf-next</span> <span class="nv">buf</span><span class="p">))</span>
                <span class="p">(</span><span class="nb">read-char</span> <span class="nv">in</span> <span class="no">nil</span> <span class="ss">:eof</span><span class="p">))))</span>
        <span class="p">((</span><span class="nb">eql</span> <span class="nv">c</span> <span class="ss">:eof</span><span class="p">))</span>
      <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nb">char=</span> <span class="nv">c</span> <span class="p">(</span><span class="nb">char</span> <span class="nv">old</span> <span class="nv">pos</span><span class="p">))</span>
             <span class="p">(</span><span class="nb">incf</span> <span class="nv">pos</span><span class="p">)</span>
             <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nb">=</span> <span class="nv">pos</span> <span class="nv">len</span><span class="p">)</span>            <span class="c1">; 3</span>
                    <span class="p">(</span><span class="nb">princ</span> <span class="nv">new</span> <span class="nv">out</span><span class="p">)</span>
                    <span class="p">(</span><span class="nb">setf</span> <span class="nv">pos</span> <span class="mi">0</span><span class="p">)</span>
                    <span class="p">(</span><span class="nv">buf-clear</span> <span class="nv">buf</span><span class="p">))</span>
                   <span class="p">((</span><span class="nb">not</span> <span class="nv">from-buf</span><span class="p">)</span>         <span class="c1">; 2</span>
                    <span class="p">(</span><span class="nv">buf-insert</span> <span class="nv">c</span> <span class="nv">buf</span><span class="p">))))</span>
            <span class="p">((</span><span class="nb">zerop</span> <span class="nv">pos</span><span class="p">)</span>                   <span class="c1">; 1</span>
             <span class="p">(</span><span class="nb">princ</span> <span class="nv">c</span> <span class="nv">out</span><span class="p">)</span>
             <span class="p">(</span><span class="nb">when</span> <span class="nv">from-buf</span>
               <span class="p">(</span><span class="nv">buf-pop</span> <span class="nv">buf</span><span class="p">)</span>
               <span class="p">(</span><span class="nv">buf-reset</span> <span class="nv">buf</span><span class="p">)))</span>
            <span class="p">(</span><span class="no">t</span>                             <span class="c1">; 4</span>
             <span class="p">(</span><span class="nb">unless</span> <span class="nv">from-buf</span>
               <span class="p">(</span><span class="nv">buf-insert</span> <span class="nv">c</span> <span class="nv">buf</span><span class="p">))</span>
             <span class="p">(</span><span class="nb">princ</span> <span class="p">(</span><span class="nv">buf-pop</span> <span class="nv">buf</span><span class="p">)</span> <span class="nv">out</span><span class="p">)</span>
             <span class="p">(</span><span class="nv">buf-reset</span> <span class="nv">buf</span><span class="p">)</span>
             <span class="p">(</span><span class="nb">setf</span> <span class="nv">pos</span> <span class="mi">0</span><span class="p">))))</span>
    <span class="p">(</span><span class="nv">buf-flush</span> <span class="nv">buf</span> <span class="nv">out</span><span class="p">)))</span>
</pre>
                                </div>
                              </div>
                              <p><strong>图 7.2 字符串替换</strong></p>
                              <p>下列表格展示了当我们将文件中的 <code
                                  class="docutils literal"><span class="pre">&quot;baro&quot;</span></code> 替换成 <code
                                  class="docutils literal"><span class="pre">&quot;baric&quot;</span></code>
                                所发生的事，其中文件只有一个单字 <code
                                  class="docutils literal"><span class="pre">&quot;barbarous&quot;</span></code> :</p>
                              <table border="1" class="docutils">
                                <colgroup>
                                  <col width="20%" />
                                  <col width="19%" />
                                  <col width="13%" />
                                  <col width="11%" />
                                  <col width="15%" />
                                  <col width="22%" />
                                </colgroup>
                                <thead valign="bottom">
                                  <tr class="row-odd">
                                    <th class="head">CHARACTER</th>
                                    <th class="head">SOURCE</th>
                                    <th class="head">MATCH</th>
                                    <th class="head">CASE</th>
                                    <th class="head">OUTPUT</th>
                                    <th class="head">BUFFER</th>
                                  </tr>
                                </thead>
                                <tbody valign="top">
                                  <tr class="row-even">
                                    <td>b</td>
                                    <td>file</td>
                                    <td>b</td>
                                    <td>2</td>
                                    <td>&nbsp;</td>
                                    <td>b</td>
                                  </tr>
                                  <tr class="row-odd">
                                    <td>a</td>
                                    <td>file</td>
                                    <td>a</td>
                                    <td>2</td>
                                    <td>&nbsp;</td>
                                    <td>b a</td>
                                  </tr>
                                  <tr class="row-even">
                                    <td>r</td>
                                    <td>file</td>
                                    <td>r</td>
                                    <td>2</td>
                                    <td>&nbsp;</td>
                                    <td>b a r</td>
                                  </tr>
                                  <tr class="row-odd">
                                    <td>b</td>
                                    <td>file</td>
                                    <td>o</td>
                                    <td>4</td>
                                    <td>b</td>
                                    <td>b.a r b.</td>
                                  </tr>
                                  <tr class="row-even">
                                    <td>a</td>
                                    <td>buffer</td>
                                    <td>b</td>
                                    <td>1</td>
                                    <td>a</td>
                                    <td>a.r b.</td>
                                  </tr>
                                  <tr class="row-odd">
                                    <td>r</td>
                                    <td>buffer</td>
                                    <td>b</td>
                                    <td>1</td>
                                    <td>r</td>
                                    <td>r.b.</td>
                                  </tr>
                                  <tr class="row-even">
                                    <td>b</td>
                                    <td>buffer</td>
                                    <td>b</td>
                                    <td>1</td>
                                    <td>&nbsp;</td>
                                    <td>r b:</td>
                                  </tr>
                                  <tr class="row-odd">
                                    <td>a</td>
                                    <td>file</td>
                                    <td>a</td>
                                    <td>2</td>
                                    <td>&nbsp;</td>
                                    <td>r b:a</td>
                                  </tr>
                                  <tr class="row-even">
                                    <td>r</td>
                                    <td>file</td>
                                    <td>r</td>
                                    <td>2</td>
                                    <td>&nbsp;</td>
                                    <td>r b:a</td>
                                  </tr>
                                  <tr class="row-odd">
                                    <td>o</td>
                                    <td>file</td>
                                    <td>o</td>
                                    <td>3</td>
                                    <td>baric</td>
                                    <td>r b:a r</td>
                                  </tr>
                                  <tr class="row-even">
                                    <td>u</td>
                                    <td>file</td>
                                    <td>b</td>
                                    <td>1</td>
                                    <td>u</td>
                                    <td>&nbsp;</td>
                                  </tr>
                                  <tr class="row-odd">
                                    <td>a</td>
                                    <td>file</td>
                                    <td>b</td>
                                    <td>1</td>
                                    <td>s</td>
                                    <td>&nbsp;</td>
                                  </tr>
                                </tbody>
                              </table>
                              <p>第一栏是当前字符 ── <code class="docutils literal"><span class="pre">c</span></code>
                                的值；第二栏显示是从缓冲区或是直接从输入流读取；第三栏显示需要匹配的字符 ── <code
                                  class="docutils literal"><span class="pre">old</span></code> 的第 <strong>posth</strong>
                                字符；第四栏显示那一个条件式 (case)被求值作为结果；第五栏显示被写至输出流的字符；而最后一栏显示缓冲区之后的内容。在最后一栏里， <code
                                  class="docutils literal"><span class="pre">used</span></code> 与 <code
                                  class="docutils literal"><span class="pre">new</span></code> 的位置一样，由一个冒号 ( <code
                                  class="docutils literal"><span class="pre">:</span></code> colon)表示。</p>
                              <p>在文件 <code class="docutils literal"><span class="pre">&quot;test1&quot;</span></code>
                                里有如下文字：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nv">The</span> <span class="nv">struggle</span> <span class="nv">between</span> <span class="nv">Liberty</span> <span class="nb">and</span> <span class="nv">Authority</span> <span class="nv">is</span> <span class="k">the</span> <span class="nv">most</span> <span class="nv">conspicuous</span> <span class="nv">feature</span>
<span class="nv">in</span> <span class="k">the</span> <span class="nv">portions</span> <span class="nv">of</span> <span class="nv">history</span> <span class="nv">with</span> <span class="nv">which</span> <span class="nv">we</span> <span class="nv">are</span> <span class="nv">earliest</span> <span class="nv">familiar,</span> <span class="nv">particularly</span>
<span class="nv">in</span> <span class="nv">that</span> <span class="nv">of</span> <span class="nv">Greece,</span> <span class="nv">Rome,</span> <span class="nb">and</span> <span class="nv">England.</span>
</pre>
                                </div>
                              </div>
                              <p>在我们对 <code
                                  class="docutils literal"><span class="pre">(file-subst</span> <span class="pre">&quot;</span> <span class="pre">th&quot;</span> <span class="pre">&quot;</span> <span class="pre">z&quot;</span> <span class="pre">&quot;test1&quot;</span> <span class="pre">&quot;test2&quot;)</span></code>
                                求值之后，读取文件 <code
                                  class="docutils literal"><span class="pre">&quot;test2&quot;</span></code> 为:</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nv">The</span> <span class="nv">struggle</span> <span class="nv">between</span> <span class="nv">Liberty</span> <span class="nb">and</span> <span class="nv">Authority</span> <span class="nv">is</span> <span class="nv">ze</span> <span class="nv">most</span> <span class="nv">conspicuous</span> <span class="nv">feature</span>
<span class="nv">in</span> <span class="nv">ze</span> <span class="nv">portions</span> <span class="nv">of</span> <span class="nv">history</span> <span class="nv">with</span> <span class="nv">which</span> <span class="nv">we</span> <span class="nv">are</span> <span class="nv">earliest</span> <span class="nv">familiar,</span> <span class="nv">particularly</span>
<span class="nv">in</span> <span class="nv">zat</span> <span class="nv">of</span> <span class="nv">Greece,</span> <span class="nv">Rome,</span> <span class="nb">and</span> <span class="nv">England.</span>
</pre>
                                </div>
                              </div>
                              <p>为了使这个例子尽可能的简单，图 7.2 的代码只将一个字符串换成另一个字符串。很容易扩展为搜索一个模式而不是一个字面字符串。你只需要做的是，将 <code
                                  class="docutils literal"><span class="pre">char=</span></code> 调用换成一个你想要的更通用的匹配函数调用。
                              </p>
                            </div>
                            <div class="section" id="macro-characters">
                              <h4>7.5 宏字符 (Macro Characters)<a class="headerlink" href="#macro-characters"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>一个宏字符 (macro character)是获得 <code
                                  class="docutils literal"><span class="pre">read</span></code> 特别待遇的字符。比如小写的 <code
                                  class="docutils literal"><span class="pre">a</span></code> ，通常与小写 <code
                                  class="docutils literal"><span class="pre">b</span></code> 一样处理，但一个左括号就不同了: 它告诉 Lisp
                                开始读入一个列表。</p>
                              <p>一个宏字符或宏字符组合也称作 <code
                                  class="docutils literal"><span class="pre">read-macro</span></code> (读取宏) 。许多 Common
                                Lisp 预定义的读取宏是缩写。比如说引用 (Quote): 读入一个像是 <code
                                  class="docutils literal"><span class="pre">'a</span></code> 的表达式时，它被读取器展开成 <code
                                  class="docutils literal"><span class="pre">(quote</span> <span class="pre">a)</span></code>
                                。当你输入引用的表达式 (quoted expression)至顶层时，它们在读入之时就会被求值，所以一般来说你看不到这样的转换。你可以透过显式调用 <code
                                  class="docutils literal"><span class="pre">read</span></code> 使其现形:</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">car</span> <span class="p">(</span><span class="nb">read-from-string</span> <span class="s">&quot;&#39;a&quot;</span><span class="p">))</span>
<span class="nv">QUOTE</span>
</pre>
                                </div>
                              </div>
                              <p>引用对于读取宏来说是不寻常的，因为它用单一字符表示。有了一个有限的字符集，你可以在 Common Lisp 里有许多单一字符的读取宏，来表示一个或更多字符。</p>
                              <p>这样的读取宏叫做派发 (dispatching)读取宏，而第一个字符叫做派发字符 (dispatching character)。所有预定义的派发读取宏使用井号 (
                                <code class="docutils literal"><span class="pre">#</span></code> )作为派发字符。我们已经见过好几个。举例来说，
                                <code class="docutils literal"><span class="pre">#'</span></code> 是 <code
                                  class="docutils literal"><span class="pre">(function</span> <span class="pre">...)</span></code>
                                的缩写，同样的 <code class="docutils literal"><span class="pre">'</span></code> 是 <code
                                  class="docutils literal"><span class="pre">(quote</span> <span class="pre">...)</span></code>
                                的缩写。
                              </p>
                              <p>其它我们见过的派发读取宏包括 <code class="docutils literal"><span class="pre">#(...)</span></code>
                                ，产生一个向量； <code class="docutils literal"><span class="pre">#nA(...)</span></code> 产生数组；
                                <code class="docutils literal"><span class="pre">#\</span></code> 产生一个字符； <code
                                  class="docutils literal"><span class="pre">#S(n</span> <span class="pre">...)</span></code>
                                产生一个结构。当这些类型的每个对象被 <code class="docutils literal"><span class="pre">prin1</span></code>
                                显示时 (或是 <code class="docutils literal"><span class="pre">format</span></code> 搭配 <code
                                  class="docutils literal"><span class="pre">~S</span></code>)，它们使用对应的读取宏 <a
                                  class="footnote-reference" href="#id6" id="id3">[2]</a> 。这表示着你可以写出或读回这样的对象:
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="vg">*print-array*</span> <span class="no">t</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">vectorp</span> <span class="p">(</span><span class="nb">read-from-string</span> <span class="p">(</span><span class="nb">format</span> <span class="no">nil</span> <span class="s">&quot;~S&quot;</span>
                                       <span class="p">(</span><span class="nb">vector</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">)))))</span>
<span class="no">T</span>
</pre>
                                </div>
                              </div>
                              <p>当然我们拿回来的不是同一个向量，而是具有同样元素的新向量。</p>
                              <p>不是所有对象被显示时都有着清楚 (distinct)、可读的形式。举例来说，函数与哈希表，倾向于这样 <code
                                  class="docutils literal"><span class="pre">#&lt;...&gt;</span></code> 被显示。实际上 <code
                                  class="docutils literal"><span class="pre">#&lt;...&gt;</span></code>
                                也是一个读取宏，但是特别用来产生当遇到 <code class="docutils literal"><span class="pre">read</span></code>
                                的错误。函数与哈希表不能被写出与读回来，而这个读取宏确保使用者不会有这样的幻觉。 <a class="footnote-reference" href="#id7"
                                  id="id4">[3]</a></p>
                              <p>当你定义你自己的事物表示法时 (举例来说，结构的印出函数)，你要将此准则记住。要不使用一个可以被读回来的表示法，或是使用 <code
                                  class="docutils literal"><span class="pre">#&lt;...&gt;</span></code> 。</p>
                            </div>
                            <div class="section" id="chapter-7-summary">
                              <h4>Chapter 7 总结 (Summary)<a class="headerlink" href="#chapter-7-summary"
                                  title="Permalink to this headline">¶</a></h4>
                              <ol class="arabic simple">
                                <li>流是输入的来源或终点。在字符流里，输入输出是由字符组成。</li>
                                <li>缺省的流指向顶层。新的流可以由开启文件产生。</li>
                                <li>你可以解析对象、字符组成的字符串、或是单独的字符。</li>
                                <li><code class="docutils literal"><span class="pre">format</span></code> 函数提供了完整的输出控制。
                                </li>
                                <li>为了要替换文本文件中的字符串，你需要将字符读入缓冲区。</li>
                                <li>当 <code class="docutils literal"><span class="pre">read</span></code> 遇到一个宏字符像是
                                  <code class="docutils literal"><span class="pre">'</span></code> ，它调用相关的函数。
                                </li>
                              </ol>
                            </div>
                            <div class="section" id="chapter-7-exercises">
                              <h4>Chapter 7 练习 (Exercises)<a class="headerlink" href="#chapter-7-exercises"
                                  title="Permalink to this headline">¶</a></h4>
                              <ol class="arabic simple">
                                <li>定义一个函数，接受一个文件名并返回一个由字符串组成的列表，来表示文件里的每一行。</li>
                                <li>定义一个函数，接受一个文件名并返回一个由表达式组成的列表，来表示文件里的每一行。</li>
                                <li>假设有某种格式的文件文件，注解是由 <code class="docutils literal"><span class="pre">%</span></code>
                                  字符表示。从这个字符开始直到行尾都会被忽略。定义一个函数，接受两个文件名称，并拷贝第一个文件的内容去掉注解，写至第二个文件。</li>
                                <li>定义一个函数，接受一个二维浮点数组，将其用简洁的栏位显示。每个元素应印至小数点二位，一栏十个字符宽。（假设所有的字符可以容纳）。你会需要 <code
                                    class="docutils literal"><span class="pre">array-dimensions</span></code> (参见 361
                                  页，译注: Appendix D)。</li>
                                <li>修改 <code class="docutils literal"><span class="pre">stream-subst</span></code>
                                  来允许万用字符 (wildcard) 可以在模式中使用。若字符 <code
                                    class="docutils literal"><span class="pre">+</span></code> 出现在 <code
                                    class="docutils literal"><span class="pre">old</span></code> 里，它应该匹配任何输入字符。</li>
                                <li>修改 <code class="docutils literal"><span class="pre">stream-subst</span></code>
                                  来允许模式可以包含一个用来匹配任何数字的元素，以及一个可以匹配任何英文字符的元素或是一个可以匹配任何字符的元素。模式必须可以匹配任何特定的输入字符。(提示: <code
                                    class="docutils literal"><span class="pre">old</span></code> 可以不是一个字符串。)</li>
                              </ol>
                              <p class="rubric">脚注</p>
                              <table class="docutils footnote" frame="void" id="id5" rules="none">
                                <colgroup>
                                  <col class="label" />
                                  <col />
                                </colgroup>
                                <tbody valign="top">
                                  <tr>
                                    <td class="label"><a class="fn-backref" href="#id2">[1]</a></td>
                                    <td>你可以给一个字符串取代路径名，但这样就不可携了 (portable)。</td>
                                  </tr>
                                </tbody>
                              </table>
                              <table class="docutils footnote" frame="void" id="id6" rules="none">
                                <colgroup>
                                  <col class="label" />
                                  <col />
                                </colgroup>
                                <tbody valign="top">
                                  <tr>
                                    <td class="label"><a class="fn-backref" href="#id3">[2]</a></td>
                                    <td>要让向量与数组这样被显示，将 <code
                                        class="docutils literal"><span class="pre">*print-array*</span></code> 设为真。</td>
                                  </tr>
                                </tbody>
                              </table>
                              <table class="docutils footnote" frame="void" id="id7" rules="none">
                                <colgroup>
                                  <col class="label" />
                                  <col />
                                </colgroup>
                                <tbody valign="top">
                                  <tr>
                                    <td class="label"><a class="fn-backref" href="#id4">[3]</a></td>
                                    <td>Lisp 不能只用 <code class="docutils literal"><span class="pre">#'</span></code>
                                      来表示函数，因为 <code class="docutils literal"><span class="pre">#'</span></code>
                                      本身无法提供表示闭包的方式。</td>
                                  </tr>
                                </tbody>
                              </table>
                            </div>
                          </div>
                          <div class="section">
                            <h3 id="8">第八章：符号</h3>
                            <p>
                              我们一直在使用符号。符号，在看似简单的表面之下，又好像没有那么简单。起初最好不要纠结于背后的实现机制。可以把符号当成数据对象与名字那样使用，而不需要理解两者是如何关联起来的。但到了某个时间点，停下来思考背后是究竟是如何工作会是很有用的。本章解释了背后实现的细节。
                            </p>
                            <div class="section" id="symbol-names">
                              <h4>8.1 符号名 (Symbol Names)<a class="headerlink" href="#symbol-names"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>第二章描述过，符号是变量的名字，符号本身以对象所存在。但 Lisp
                                符号的可能性，要比在多数语言仅允许作为变量名来得广泛许多。实际上，符号可以用任何字符串当作名字。可以通过调用 <code
                                  class="docutils literal"><span class="pre">symbol-name</span></code> 来获得符号的名字：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">symbol-name</span> <span class="ss">&#39;abc</span><span class="p">)</span>
<span class="s">&quot;ABC&quot;</span>
</pre>
                                </div>
                              </div>
                              <p>注意到这个符号的名字，打印出来都是大写字母。缺省情况下， Common Lisp 在读入时，会把符号名字所有的英文字母都转成大写。代表 Common Lisp
                                缺省是不分大小写的：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">eql</span> <span class="ss">&#39;abc</span> <span class="ss">&#39;Abc</span><span class="p">)</span>
<span class="no">T</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="nv">CaR</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">))</span>
<span class="nv">A</span>
</pre>
                                </div>
                              </div>
                              <p>一个名字包含空白，或其它可能被读取器认为是重要的字符的符号，要用特殊的语法来引用。任何存在垂直杠 (vertical
                                bar)之间的字符序列将被视为符号。可以如下这般在符号的名字中，放入任何字符：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre>&gt; (list &#39;|Lisp 1.5| &#39;|| &#39;|abc| &#39;|ABC|)
(|Lisp 1.5| || |abc| ABC)
</pre>
                                </div>
                              </div>
                              <p>当这种符号被读入时，不会有大小写转换，而宏字符与其他的字符被视为一般字符。</p>
                              <p>那什么样的符号不需要使用垂直杠来参照呢？基本上任何不是数字，或不包含读取器视为重要的字符的符号。一个快速找出你是否可以不用垂直杠来引用符号的方法，是看看 Lisp
                                如何印出它的。如果 Lisp 没有用垂直杠表示一个符号，如上述列表的最后一个，那么你也可以不用垂直杠。</p>
                              <p>记得，垂直杠是一种表示符号的特殊语法。它们不是符号的名字之一：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">symbol-name</span> <span class="ss">&#39;|a b c|</span><span class="p">)</span>
<span class="s">&quot;a b c&quot;</span>
</pre>
                                </div>
                              </div>
                              <p>(如果想要在符号名称内使用垂直杠，可以放一个反斜线在垂直杠的前面。)</p>
                              <p>译注: 反斜线是 <code class="docutils literal"><span class="pre">\</span></code> (backslash)。
                              </p>
                            </div>
                            <div class="section" id="property-lists">
                              <h4>8.2 属性列表 (Property Lists)<a class="headerlink" href="#property-lists"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>在 Common Lisp 里，每个符号都有一个属性列表（property-list）或称为 <code
                                  class="docutils literal"><span class="pre">plist</span></code> 。函数 <code
                                  class="docutils literal"><span class="pre">get</span></code>
                                接受符号及任何类型的键值，然后返回在符号的属性列表中，与键值相关的数值：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">get</span> <span class="ss">&#39;alizarin</span> <span class="ss">&#39;color</span><span class="p">)</span>
<span class="no">NIL</span>
</pre>
                                </div>
                              </div>
                              <p>它使用 <code class="docutils literal"><span class="pre">eql</span></code>
                                来比较各个键。若某个特定的属性没有找到时， <code class="docutils literal"><span class="pre">get</span></code>
                                返回 <code class="docutils literal"><span class="pre">nil</span></code> 。</p>
                              <p>要将值与键关联起来时，你可以使用 <code class="docutils literal"><span class="pre">setf</span></code> 及
                                <code class="docutils literal"><span class="pre">get</span></code> :
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nb">get</span> <span class="ss">&#39;alizarin</span> <span class="ss">&#39;color</span><span class="p">)</span> <span class="ss">&#39;red</span><span class="p">)</span>
<span class="nv">RED</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="nb">get</span> <span class="ss">&#39;alizarin</span> <span class="ss">&#39;color</span><span class="p">)</span>
<span class="nv">RED</span>
</pre>
                                </div>
                              </div>
                              <p>现在符号 <code class="docutils literal"><span class="pre">alizarin</span></code> 的 <code
                                  class="docutils literal"><span class="pre">color</span></code> 属性是 <code
                                  class="docutils literal"><span class="pre">red</span></code> 。</p>
                              <div class="figure">
                                <img alt="_images/Figure-8.1.png" src="_images/Figure-8.1.png" />
                              </div>
                              <p><strong>图 8.1 符号的结构</strong></p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nb">get</span> <span class="ss">&#39;alizarin</span> <span class="ss">&#39;transparency</span><span class="p">)</span> <span class="ss">&#39;high</span><span class="p">)</span>
<span class="nv">HIGH</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="nb">symbol-plist</span> <span class="ss">&#39;alizarin</span><span class="p">)</span>
<span class="p">(</span><span class="nv">TRANSPARENCY</span> <span class="nv">HIGH</span> <span class="nv">COLOR</span> <span class="nv">RED</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>注意，属性列表不以关联列表（assoc-lists）的形式表示，虽然用起来感觉是一样的。</p>
                              <p>在 Common Lisp 里，属性列表用得不多。他们大部分被哈希表取代了（4.8 小节）。</p>
                            </div>
                            <div class="section" id="symbols-are-big">
                              <h4>8.3 符号很不简单 (Symbols Are Big)<a class="headerlink" href="#symbols-are-big"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>当我们输入名字时，符号就被悄悄地创建出来了，而当它们被显示时，我们只看的到符号的名字。某些情况下，把符号想成是表面所见的东西就好，别想太多。但有时候符号不像看起来那么简单。
                              </p>
                              <p>从我们如何使用和检查符号的方式来看，符号像是整数那样的小对象。而符号实际上确实是一个对象，差不多像是由 <code
                                  class="docutils literal"><span class="pre">defstruct</span></code> 定义的那种结构。符号可以有名字、
                                主包（home package）、作为变量的值、作为函数的值以及带有一个属性列表。图 8.1 演示了符号在内部是如何表示的。</p>
                              <p>
                                很少有程序会使用很多符号，以致于值得用其它的东西来代替符号以节省空间。但需要记住的是，符号是实际的对象，不仅是名字而已。当两个变量设成相同的符号时，与两个变量设成相同列表一样：两个变量的指针都指向同样的对象。
                              </p>
                            </div>
                            <div class="section" id="creating-symbols">
                              <h4>8.4 创建符号 (Creating Symbols)<a class="headerlink" href="#creating-symbols"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>8.1 节演示了如何取得符号的名字。另一方面，用字符串生成符号也是有可能的。但比较复杂一点，因为我们需要先介绍包（package）。</p>
                              <p>
                                概念上来说，包是将名字映射到符号的符号表（symbol-tables）。每个普通的符号都属于一个特定的包。符号属于某个包，我们称为符号被包扣押（intern）了。函数与变量用符号作为名称。包借由限制哪个符号可以访问来实现模块化（modularity），也是因为这样，我们才可以引用到函数与变量。
                              </p>
                              <p>大多数的符号在读取时就被扣押了。在第一次输入一个新符号的名字时，Lisp 会产生一个新的符号对象，并将它扣押到当下的包里（缺省是 <code
                                  class="docutils literal"><span class="pre">common-lisp-user</span></code>
                                包)。但也可以通过给入字符串与选择性包参数给 <code
                                  class="docutils literal"><span class="pre">intern</span></code> 函数，来扣押一个名称为字符串名的符号:
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">intern</span> <span class="s">&quot;RANDOM-SYMBOL&quot;</span><span class="p">)</span>
<span class="nv">RANDOM-SYMBOL</span>
<span class="no">NIL</span>
</pre>
                                </div>
                              </div>
                              <p>选择性包参数缺省是当前的包，所以前述的表达式，返回当前包里的一个符号，此符号的名字是
                                “RANDOM-SYMBOL”，若此符号尚未存在时，会创建一个这样的符号出来。第二个返回值告诉我们符号是否存在；在这个情况，它不存在。</p>
                              <p>不是所有的符号都会被扣押。有时候有一个自由的（uninterned）符号是有用的，这和公用电话本是一样的原因。自由的符号叫做 <em>gensyms</em> 。我们将会在第
                                10 章讨论宏（Macro）时，理解 <code class="docutils literal"><span class="pre">gensym</span></code>
                                的作用。</p>
                            </div>
                            <div class="section" id="multiple-packages">
                              <h4>8.5 多重包 (Multiple Packages)<a class="headerlink" href="#multiple-packages"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>大的程序通常切分为多个包。如果程序的每个部分都是一个包，那么开发程序另一个部分的某个人，将可以使用符号来作为函数名或变量名，而不必担心名字在别的地方已经被用过了。</p>
                              <p>
                                在没有提供定义多个命名空间的语言里，工作于大项目的程序员，通常需要想出某些规范（convention），来确保他们不会使用同样的名称。举例来说，程序员写显示相关的代码（display
                                code）可能用 <code class="docutils literal"><span class="pre">disp_</span></code>
                                开头的名字，而写数学相关的代码（math code）的程序员仅使用由 <code
                                  class="docutils literal"><span class="pre">math_</span></code>
                                开始的代码。所以若是数学相关的代码里，包含一个做快速傅立叶转换的函数时，可能会叫做 <code
                                  class="docutils literal"><span class="pre">math_fft</span></code> 。</p>
                              <p>包不过是提供了一种便捷方式来自动办到此事。如果你将函数定义在单独的包里，可以随意使用你喜欢的名字。只有你明确导出（ <code
                                  class="docutils literal"><span class="pre">export</span></code>
                                ）的符号会被别的包看到，而通常前面会有包的名字(或修饰符)。</p>
                              <p>举例来说，假设一个程序分为两个包， <code class="docutils literal"><span class="pre">math</span></code> 与
                                <code class="docutils literal"><span class="pre">disp</span></code> 。如果符号 <code
                                  class="docutils literal"><span class="pre">fft</span></code> 被 <code
                                  class="docutils literal"><span class="pre">math</span></code> 包导出，则 <code
                                  class="docutils literal"><span class="pre">disp</span></code> 包里可以用 <code
                                  class="docutils literal"><span class="pre">math:fft</span></code> 来参照它。在 <code
                                  class="docutils literal"><span class="pre">math</span></code> 包里，可以只用 <code
                                  class="docutils literal"><span class="pre">fft</span></code> 来参照。
                              </p>
                              <p>下面是你可能会放在文件最上方，包含独立包的代码：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defpackage</span> <span class="s">&quot;MY-APPLICATION&quot;</span>
            <span class="p">(</span><span class="ss">:use</span> <span class="s">&quot;COMMON-LISP&quot;</span> <span class="s">&quot;MY-UTILITIES&quot;</span><span class="p">)</span>
            <span class="p">(</span><span class="ss">:nicknames</span> <span class="s">&quot;APP&quot;</span><span class="p">)</span>
            <span class="p">(</span><span class="ss">:export</span> <span class="s">&quot;WIN&quot;</span> <span class="s">&quot;LOSE&quot;</span> <span class="s">&quot;DRAW&quot;</span><span class="p">))</span>

<span class="p">(</span><span class="nb">in-package</span> <span class="nv">my-application</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p><code class="docutils literal"><span class="pre">defpackage</span></code> 定义一个新的包叫做
                                <code class="docutils literal"><span class="pre">my-application</span></code> <a
                                  class="footnote-reference" href="#id4" id="id2">[1]</a> 它使用了其他两个包， <code
                                  class="docutils literal"><span class="pre">common-lisp</span></code> 与 <code
                                  class="docutils literal"><span class="pre">my-utilities</span></code>
                                ，这代表着可以不需要用包修饰符（package qualifiers）来存取这些包所导出的符号。许多包都使用了 <code
                                  class="docutils literal"><span class="pre">common-lisp</span></code> 包 ── 因为你不会想给 Lisp
                                自带的操作符与变量再加上修饰符。
                              </p>
                              <p><code class="docutils literal"><span class="pre">my-application</span></code>
                                包本身只输出三个符号: <code class="docutils literal"><span class="pre">WIN</span></code> 、 <code
                                  class="docutils literal"><span class="pre">LOSE</span></code> 以及 <code
                                  class="docutils literal"><span class="pre">DRAW</span></code> 。由于调用 <code
                                  class="docutils literal"><span class="pre">defpackage</span></code> 给了 <code
                                  class="docutils literal"><span class="pre">my-application</span></code> 一个匿称 <code
                                  class="docutils literal"><span class="pre">app</span></code> ，则别的包可以这样引用到这些符号，比如 <code
                                  class="docutils literal"><span class="pre">app:win</span></code> 。</p>
                              <p><code class="docutils literal"><span class="pre">defpackage</span></code> 伴随着一个 <code
                                  class="docutils literal"><span class="pre">in-package</span></code> ，确保当前包是 <code
                                  class="docutils literal"><span class="pre">my-application</span></code>
                                。所有其它未修饰的符号会被扣押至 <code
                                  class="docutils literal"><span class="pre">my-application</span></code> ── 除非之后有别的
                                <code class="docutils literal"><span class="pre">in-package</span></code>
                                出现。当一个文件被载入时，当前的包总是被重置成载入之前的值。
                              </p>
                            </div>
                            <div class="section" id="keywords">
                              <h4>8.6 关键字 (Keywords)<a class="headerlink" href="#keywords"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>在 <code class="docutils literal"><span class="pre">keyword</span></code> 包的符号
                                (称为关键字)有两个独特的性质：它们总是对自己求值，以及可以在任何地方引用它们，如 <code
                                  class="docutils literal"><span class="pre">:x</span></code> 而不是 <code
                                  class="docutils literal"><span class="pre">keyword:x</span></code> 。我们首次在 44 页 (译注:
                                3.10 小节）介绍关键字参数时， <code
                                  class="docutils literal"><span class="pre">(member</span> <span class="pre">'(a)</span> <span class="pre">'((a)</span> <span class="pre">(z))</span> <span class="pre">test:</span> <span class="pre">#'equal)</span></code>
                                比 <code
                                  class="docutils literal"><span class="pre">(member</span> <span class="pre">'(a)</span> <span class="pre">'((a)</span> <span class="pre">(z))</span> <span class="pre">:test</span> <span class="pre">#'equal)</span></code>
                                读起来更自然。现在我们知道为什么第二个较别扭的形式才是对的。 <code
                                  class="docutils literal"><span class="pre">test</span></code> 前的冒号字首，是关键字的识别符。</p>
                              <p>为什么使用关键字而不用一般的符号？因为关键字在哪都可以存取。一个函数接受符号作为实参，应该要写成预期关键字的函数。举例来说，这个函数可以安全地在任何包里调用:</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">noise</span> <span class="p">(</span><span class="nv">animal</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">case</span> <span class="nv">animal</span>
    <span class="p">(</span><span class="ss">:dog</span> <span class="ss">:woof</span><span class="p">)</span>
    <span class="p">(</span><span class="ss">:cat</span> <span class="ss">:meow</span><span class="p">)</span>
    <span class="p">(</span><span class="ss">:pig</span> <span class="ss">:oink</span><span class="p">)))</span>
</pre>
                                </div>
                              </div>
                              <p>但如果是用一般符号写成的话，它只在被定义的包内正常工作，除非关键字也被导出了。</p>
                            </div>
                            <div class="section" id="symbols-and-variables">
                              <h4>8.7 符号与变量 (Symbols and Variables)<a class="headerlink" href="#symbols-and-variables"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>Lisp 有一件可能会使你困惑的事情是，符号与变量的从两个非常不同的层面互相关联。当符号是特别变量（special variable）的名字时，变量的值存在符号的 value
                                栏位（图 8.1）。 <code class="docutils literal"><span class="pre">symbol-value</span></code>
                                函数引用到那个栏位，所以在符号与特殊变量的值之间，有直接的连接关系。</p>
                              <p>而对于词法变量（lexical
                                variables）来说，事情就完全不一样了。一个作为词法变量的符号只不过是个占位符（placeholder）。编译器会将其转为一个寄存器（register）或内存位置的引用位址。在最后编译出来的代码中，我们无法追踪这个符号
                                (除非它被保存在调试器「debugger」的某个地方)。因此符号与词法变量的值之间是没有连接的；只要一有值，符号就消失了。</p>
                            </div>
                            <div class="section" id="example-random-text">
                              <h4>8.8 示例：随机文本 (Example: Random Text)<a class="headerlink" href="#example-random-text"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>如果你要写一个操作单词的程序，通常使用符号会比字符串来得好，因为符号概念上是原子性的（atomic）。符号可以用 <code
                                  class="docutils literal"><span class="pre">eql</span></code> 一步比较完成，而字符串需要使用 <code
                                  class="docutils literal"><span class="pre">string=</span></code> 或 <code
                                  class="docutils literal"><span class="pre">string-equal</span></code>
                                逐一字符做比较。作为一个示例，本节将演示如何写一个程序来产生随机文本。程序的第一部分会读入一个示例文件（越大越好），用来累积之后所给入的相关单词的可能性（likeilhood）的信息。第二部分在每一个单词都根据原本的示例，产生一个随机的权重（weight）之后，随机走访根据第一部分所产生的网络。
                              </p>
                              <p>产生的文字将会是部分可信的（locally plausible），因为任两个出现的单词也是输入文件里，两个同时出现的单词。令人惊讶的是，获得看起来是 ── 有意义的整句 ──
                                甚至整个段落是的频率相当高。</p>
                              <p>图 8.2 包含了程序的上半部，用来读取示例文件的代码。</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defparameter</span> <span class="vg">*words*</span> <span class="p">(</span><span class="nb">make-hash-table</span> <span class="ss">:size</span> <span class="mi">10000</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defconstant</span> <span class="nv">maxword</span> <span class="mi">100</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">read-text</span> <span class="p">(</span><span class="nb">pathname</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">with-open-file</span> <span class="p">(</span><span class="nv">s</span> <span class="nb">pathname</span> <span class="ss">:direction</span> <span class="ss">:input</span><span class="p">)</span>
    <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">buffer</span> <span class="p">(</span><span class="nb">make-string</span> <span class="nv">maxword</span><span class="p">))</span>
          <span class="p">(</span><span class="nv">pos</span> <span class="mi">0</span><span class="p">))</span>
      <span class="p">(</span><span class="nb">do</span> <span class="p">((</span><span class="nv">c</span> <span class="p">(</span><span class="nb">read-char</span> <span class="nv">s</span> <span class="no">nil</span> <span class="ss">:eof</span><span class="p">)</span>
              <span class="p">(</span><span class="nb">read-char</span> <span class="nv">s</span> <span class="no">nil</span> <span class="ss">:eof</span><span class="p">)))</span>
          <span class="p">((</span><span class="nb">eql</span> <span class="nv">c</span> <span class="ss">:eof</span><span class="p">))</span>
        <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">or</span> <span class="p">(</span><span class="nb">alpha-char-p</span> <span class="nv">c</span><span class="p">)</span> <span class="p">(</span><span class="nb">char=</span> <span class="nv">c</span> <span class="sc">#\&#39;</span><span class="p">))</span>
            <span class="p">(</span><span class="k">progn</span>
              <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nb">aref</span> <span class="nv">buffer</span> <span class="nv">pos</span><span class="p">)</span> <span class="nv">c</span><span class="p">)</span>
              <span class="p">(</span><span class="nb">incf</span> <span class="nv">pos</span><span class="p">))</span>
            <span class="p">(</span><span class="k">progn</span>
              <span class="p">(</span><span class="nb">unless</span> <span class="p">(</span><span class="nb">zerop</span> <span class="nv">pos</span><span class="p">)</span>
                <span class="p">(</span><span class="nv">see</span> <span class="p">(</span><span class="nb">intern</span> <span class="p">(</span><span class="nb">string-downcase</span>
                               <span class="p">(</span><span class="nb">subseq</span> <span class="nv">buffer</span> <span class="mi">0</span> <span class="nv">pos</span><span class="p">))))</span>
                <span class="p">(</span><span class="nb">setf</span> <span class="nv">pos</span> <span class="mi">0</span><span class="p">))</span>
              <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">p</span> <span class="p">(</span><span class="nv">punc</span> <span class="nv">c</span><span class="p">)))</span>
                <span class="p">(</span><span class="k">if</span> <span class="nv">p</span> <span class="p">(</span><span class="nv">see</span> <span class="nv">p</span><span class="p">)))))))))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">punc</span> <span class="p">(</span><span class="nv">c</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">case</span> <span class="nv">c</span>
    <span class="p">(</span><span class="sc">#\.</span> <span class="ss">&#39;|.|</span><span class="p">)</span> <span class="p">(</span><span class="sc">#\,</span> <span class="ss">&#39;|,|</span><span class="p">)</span> <span class="p">(</span><span class="sc">#\;</span> <span class="ss">&#39;|;|</span><span class="p">)</span>
    <span class="p">(</span><span class="sc">#\!</span> <span class="ss">&#39;|!|</span><span class="p">)</span> <span class="p">(</span><span class="sc">#\?</span> <span class="ss">&#39;|?|</span><span class="p">)</span> <span class="p">))</span>

<span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">prev</span> <span class="o">`</span><span class="nv">|.|</span><span class="p">))</span>
  <span class="p">(</span><span class="nb">defun</span> <span class="nv">see</span> <span class="p">(</span><span class="nv">symb</span><span class="p">)</span>
    <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">pair</span> <span class="p">(</span><span class="nb">assoc</span> <span class="nv">symb</span> <span class="p">(</span><span class="nb">gethash</span> <span class="nv">prev</span> <span class="vg">*words*</span><span class="p">))))</span>
      <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">null</span> <span class="nv">pair</span><span class="p">)</span>
          <span class="p">(</span><span class="nb">push</span> <span class="p">(</span><span class="nb">cons</span> <span class="nv">symb</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">gethash</span> <span class="nv">prev</span> <span class="vg">*words*</span><span class="p">))</span>
          <span class="p">(</span><span class="nb">incf</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">pair</span><span class="p">))))</span>
    <span class="p">(</span><span class="nb">setf</span> <span class="nv">prev</span> <span class="nv">symb</span><span class="p">)))</span>
</pre>
                                </div>
                              </div>
                              <p><strong>图 8.2 读取示例文件</strong></p>
                              <p>从图 8.2 所导出的数据，会被存在哈希表 <code
                                  class="docutils literal"><span class="pre">*words*</span></code>
                                里。这个哈希表的键是代表单词的符号，而值会像是下列的关联列表（assoc-lists）:</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">((</span><span class="nv">|sin|</span> <span class="o">.</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nv">|wide|</span> <span class="o">.</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="nv">|sights|</span> <span class="o">.</span> <span class="mi">1</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p>使用<a class="reference external"
                                  href="http://zh.wikipedia.org/wiki/%E5%A4%B1%E6%A8%82%E5%9C%92">弥尔顿的失乐园</a>作为示例文件时，这是与键
                                <code class="docutils literal"><span class="pre">|discover|</span></code> 有关的值。它指出了
                                “discover” 这个单词，在诗里面用了四次，与 “wide” 用了两次，而 “sin” 与 ”sights” 各一次。(译注: 诗可以在这里找到 <a
                                  class="reference external"
                                  href="http://www.paradiselost.org/">http://www.paradiselost.org/</a> )
                              </p>
                              <p>函数 <code class="docutils literal"><span class="pre">read-text</span></code>
                                累积了这个信息。这个函数接受一个路径名（pathname），然后替每一个出现在文件中的单词，生成一个上面所展示的关联列表。它的工作方式是，逐字读取文件的每个字符，将累积的单词存在字符串
                                <code class="docutils literal"><span class="pre">buffer</span></code> 。 <code
                                  class="docutils literal"><span class="pre">maxword</span></code> 设成 <code
                                  class="docutils literal"><span class="pre">100</span></code> ，程序可以读取至多 100
                                个单词，对英语来说足够了。
                              </p>
                              <p>只要下个字符是一个字（由 <code
                                  class="docutils literal"><span class="pre">alpha-char-p</span></code> 决定）或是一撇
                                (apostrophe) ，就持续累积字符。任何使单词停止累积的字符会送给 <code
                                  class="docutils literal"><span class="pre">see</span></code>
                                。数种标点符号（punctuation）也被视为是单词；函数 <code
                                  class="docutils literal"><span class="pre">punc</span></code> 返回标点字符的伪单词（pseudo-word）。
                              </p>
                              <p>函数 <code class="docutils literal"><span class="pre">see</span></code>
                                注册每一个我们看过的单词。它需要知道前一个单词，以及我们刚确认过的单词 ── 这也是为什么要有变量 <code
                                  class="docutils literal"><span class="pre">prev</span></code> 存在。起初这个变量设为伪单词里的句点；在
                                <code class="docutils literal"><span class="pre">see</span></code> 函数被调用后， <code
                                  class="docutils literal"><span class="pre">prev</span></code> 变量包含了我们最后见过的单词。
                              </p>
                              <p>在 <code class="docutils literal"><span class="pre">read-text</span></code> 返回之后， <code
                                  class="docutils literal"><span class="pre">*words*</span></code>
                                会包含输入文件的每一个单词的条目（entry）。通过调用 <code
                                  class="docutils literal"><span class="pre">hash-table-count</span></code>
                                你可以了解有多少个不同的单词存在。鲜少有英文文件会超过 10000 个单词。</p>
                              <p>现在来到了有趣的部份。图 8.3 包含了从图 8.2 所累积的数据来产生文字的代码。 <code
                                  class="docutils literal"><span class="pre">generate-text</span></code>
                                函数导出整个过程。它接受一个要产生几个单词的数字，以及选择性传入前一个单词。使用缺省值，会让产生出来的文件从句子的开头开始。</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">generate-text</span> <span class="p">(</span><span class="nv">n</span> <span class="k">&amp;optional</span> <span class="p">(</span><span class="nv">prev</span> <span class="ss">&#39;|.|</span><span class="p">))</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">zerop</span> <span class="nv">n</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">terpri</span><span class="p">)</span>
      <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">next</span> <span class="p">(</span><span class="nv">random-next</span> <span class="nv">prev</span><span class="p">)))</span>
        <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;~A &quot;</span> <span class="nv">next</span><span class="p">)</span>
        <span class="p">(</span><span class="nv">generate-text</span> <span class="p">(</span><span class="nb">1-</span> <span class="nv">n</span><span class="p">)</span> <span class="nv">next</span><span class="p">))))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">random-next</span> <span class="p">(</span><span class="nv">prev</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let*</span> <span class="p">((</span><span class="nv">choices</span> <span class="p">(</span><span class="nb">gethash</span> <span class="nv">prev</span> <span class="vg">*words*</span><span class="p">))</span>
         <span class="p">(</span><span class="nv">i</span> <span class="p">(</span><span class="nb">random</span> <span class="p">(</span><span class="nb">reduce</span> <span class="nf">#&#39;</span><span class="nb">+</span> <span class="nv">choices</span>
                            <span class="ss">:key</span> <span class="nf">#&#39;</span><span class="nb">cdr</span><span class="p">))))</span>
    <span class="p">(</span><span class="nb">dolist</span> <span class="p">(</span><span class="nv">pair</span> <span class="nv">choices</span><span class="p">)</span>
      <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">minusp</span> <span class="p">(</span><span class="nb">decf</span> <span class="nv">i</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">pair</span><span class="p">)))</span>
          <span class="p">(</span><span class="nb">return</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">pair</span><span class="p">))))))</span>
</pre>
                                </div>
                              </div>
                              <p><strong>图 8.3 产生文字</strong></p>
                              <p>要取得一个新的单词， <code class="docutils literal"><span class="pre">generate-text</span></code>
                                使用前一个单词，接著调用 <code class="docutils literal"><span class="pre">random-next</span></code>
                                。 <code class="docutils literal"><span class="pre">random-next</span></code>
                                函数根据每个单词出现的机率加上权重，随机选择伴随输入文本中 <code
                                  class="docutils literal"><span class="pre">prev</span></code> 之后的单词。</p>
                              <p>现在会是测试运行下程序的好时机。但其实你早看过一个它所产生的示例： 就是本书开头的那首诗，是使用弥尔顿的失乐园作为输入文件所产生的。</p>
                              <p>(译注: 诗可在这里看，或是浏览书的第 vi 页)</p>
                              <p>Half lost on my firmness gains more glad heart,</p>
                              <p>Or violent and from forage drives</p>
                              <p>A glimmering of all sun new begun</p>
                              <p>Both harp thy discourse they match&#8217;d,</p>
                              <p>Forth my early, is not without delay;</p>
                              <p>For their soft with whirlwind; and balm.</p>
                              <p>Undoubtedly he scornful turn&#8217;d round ninefold,</p>
                              <p>Though doubled now what redounds,</p>
                              <p>And chains these a lower world devote, yet inflicted?</p>
                              <p>Till body or rare, and best things else enjoy&#8217;d in heav&#8217;n</p>
                              <p>To stand divided light at ev&#8217;n and poise their eyes,</p>
                              <p>Or nourish, lik&#8217;ning spiritual, I have thou appear.</p>
                              <p>── Henley</p>
                            </div>
                            <div class="section" id="chapter-8-summary">
                              <h4>Chapter 8 总结 (Summary)<a class="headerlink" href="#chapter-8-summary"
                                  title="Permalink to this headline">¶</a></h4>
                              <ol class="arabic simple">
                                <li>符号的名字可以是任何字符串，但由 <code class="docutils literal"><span class="pre">read</span></code>
                                  创建的符号缺省会被转成大写。</li>
                                <li>符号带有相关联的属性列表，虽然他们不需要是相同的形式，但行为像是 assoc-lists 。</li>
                                <li>符号是实质的对象，比较像结构，而不是名字。</li>
                                <li>包将字符串映射至符号。要在包里给符号创造一个条目的方法是扣留它。符号不需要被扣留。</li>
                                <li>包通过限制可以引用的名称增加模块化。缺省的包会是 user 包，但为了提高模块化，大的程序通常分成数个包。</li>
                                <li>可以让符号在别的包被存取。关键字是自身求值并在所有的包里都可以存取。</li>
                                <li>当一个程序用来操作单词时，用符号来表示单词是很方便的。</li>
                              </ol>
                            </div>
                            <div class="section" id="chapter-8-exercises">
                              <h4>Chapter 8 练习 (Exercises)<a class="headerlink" href="#chapter-8-exercises"
                                  title="Permalink to this headline">¶</a></h4>
                              <ol class="arabic simple">
                                <li>可能有两个同名符号，但却不 <code class="docutils literal"><span class="pre">eql</span></code> 吗？
                                </li>
                                <li>估计一下用字符串表示 &#8220;FOO&#8221; 与符号表示 foo 所使用内存空间的差异。</li>
                                <li>只使用字符串作为实参 来调用 137 页的 <code
                                    class="docutils literal"><span class="pre">defpackage</span></code>
                                  。应该使用符号比较好。为什么使用字符串可能比较危险呢？</li>
                                <li>加入需要的代码，使图 7.1 的代码可以放在一个叫做 <code
                                    class="docutils literal"><span class="pre">&quot;RING&quot;</span></code> 的包里，而图 7.2
                                  的代码放在一个叫做 <code
                                    class="docutils literal"><span class="pre">&quot;FILE&quot;</span></code>
                                  包里。不需要更动现有的代码。</li>
                                <li>写一个确认引用的句子是否是由 Henley 生成的程序 (8.8 节)。</li>
                                <li>写一版 Henley，接受一个单词，并产生一个句子，该单词在句子的中间。</li>
                              </ol>
                              <p class="rubric">脚注</p>
                              <table class="docutils footnote" frame="void" id="id4" rules="none">
                                <colgroup>
                                  <col class="label" />
                                  <col />
                                </colgroup>
                                <tbody valign="top">
                                  <tr>
                                    <td class="label"><a class="fn-backref" href="#id2">[1]</a></td>
                                    <td>调用 <code class="docutils literal"><span class="pre">defpackage</span></code>
                                      里的名字全部大写的缘故在 8.1 节提到过，符号的名字缺省被转成大写。</td>
                                  </tr>
                                </tbody>
                              </table>
                            </div>
                          </div>
                          <div class="section">
                            <h3 id="9">第九章：数字</h3>
                            <p>处理数字是 Common Lisp 的强项之一。Common Lisp 有着丰富的数值类型，而 Common Lisp 操作数字的特性与其他语言比起来更受人喜爱。</p>
                            <div class="section" id="types">
                              <h4>9.1 类型 (Types)<a class="headerlink" href="#types"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>Common Lisp 提供了四种不同类型的数字：整数、浮点数、比值与复数。本章所讲述的函数适用于所有类型的数字。有几个不能用在复数的函数会特别说明。</p>
                              <p>整数写成一串数字：如 <code class="docutils literal"><span class="pre">2001</span></code>
                                。浮点数是可以写成一串包含小数点的数字，如 <code
                                  class="docutils literal"><span class="pre">253.72</span></code> ，或是用科学表示法，如 <code
                                  class="docutils literal"><span class="pre">2.5372e2</span></code> 。比值是写成由整数组成的分数：如
                                <code class="docutils literal"><span class="pre">2/3</span></code> 。而复数 <code
                                  class="docutils literal"><span class="pre">a+bi</span></code> 写成 <code
                                  class="docutils literal"><span class="pre">#c(a</span> <span class="pre">b)</span></code>
                                ，其中 <code class="docutils literal"><span class="pre">a</span></code> 与 <code
                                  class="docutils literal"><span class="pre">b</span></code> 是任两个类型相同的实数。
                              </p>
                              <p>谓词 <code class="docutils literal"><span class="pre">integerp</span></code> 、 <code
                                  class="docutils literal"><span class="pre">floatp</span></code> 以及 <code
                                  class="docutils literal"><span class="pre">complexp</span></code> 针对相应的数字类型返回真。图 9.1
                                展示了数值类型的层级。</p>
                              <div class="figure">
                                <img alt="_images/Figure-9.1.png" src="_images/Figure-9.1.png" />
                              </div>
                              <p><strong>图 9.1: 数值类型</strong></p>
                              <p>要决定计算过程会返回何种数字，以下是某些通用的经验法则：</p>
                              <ol class="arabic simple">
                                <li>如果数值函数接受一个或多个浮点数作为参数，则返回值会是浮点数 (或是由浮点数组成的复数)。所以 <code
                                    class="docutils literal"><span class="pre">(+</span> <span class="pre">1.0</span> <span class="pre">2)</span></code>
                                  求值为 <code class="docutils literal"><span class="pre">3.0</span></code> ，而 <code
                                    class="docutils literal"><span class="pre">(+</span> <span class="pre">#c(0</span> <span class="pre">1.0)</span> <span class="pre">2)</span></code>
                                  求值为 <code
                                    class="docutils literal"><span class="pre">#c(2.0</span> <span class="pre">1.0)</span></code>
                                  。</li>
                                <li>可约分的比值会被转换成最简分数。所以 <code
                                    class="docutils literal"><span class="pre">(/</span> <span class="pre">10</span> <span class="pre">2)</span></code>
                                  会返回 <code class="docutils literal"><span class="pre">5</span></code> 。</li>
                                <li>若计算过程中复数的虚部变成 <code class="docutils literal"><span class="pre">0</span></code>
                                  时，则复数会被转成实数 。所以 <code
                                    class="docutils literal"><span class="pre">(+</span> <span class="pre">#c(1</span> <span class="pre">-1)</span> <span class="pre">#c(2</span> <span class="pre">1))</span></code>
                                  求值成 <code class="docutils literal"><span class="pre">3</span></code> 。</li>
                              </ol>
                              <p>第二、第三个规则可以在读入参数时直接应用，所以：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">list</span> <span class="p">(</span><span class="nv">ratiop</span> <span class="m">2/2</span><span class="p">)</span> <span class="p">(</span><span class="nb">complexp</span> <span class="m">#c</span><span class="p">(</span><span class="mi">1</span> <span class="mi">0</span><span class="p">)))</span>
<span class="p">(</span><span class="no">NIL</span> <span class="no">NIL</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                            </div>
                            <div class="section" id="conversion-and-extraction">
                              <h4>9.2 转换及取出 (Conversion and Extraction)<a class="headerlink"
                                  href="#conversion-and-extraction" title="Permalink to this headline">¶</a></h4>
                              <p>Lisp 提供四种不同类型的数字的转换及取出位数的函数。函数 <code
                                  class="docutils literal"><span class="pre">float</span></code> 将任何实数转换成浮点数:</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">mapcar</span> <span class="nf">#&#39;</span><span class="nb">float</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="m">2/3</span> <span class="mf">.5</span><span class="p">))</span>
<span class="p">(</span><span class="mf">1.0</span> <span class="mf">0.6666667</span> <span class="mf">0.5</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>将数字转成整数未必需要转换，因为它可能牵涉到某些资讯的丧失。函数 <code
                                  class="docutils literal"><span class="pre">truncate</span></code> 返回任何实数的整数部分:</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">truncate</span> <span class="mf">1.3</span><span class="p">)</span>
<span class="mi">1</span>
<span class="mf">0.29999995</span>
</pre>
                                </div>
                              </div>
                              <p>第二个返回值 <code class="docutils literal"><span class="pre">0.29999995</span></code>
                                是传入的参数减去第一个返回值。(会有 0.00000005 的误差是因为浮点数的计算本身就不精确。)</p>
                              <p>函数 <code class="docutils literal"><span class="pre">floor</span></code> 与 <code
                                  class="docutils literal"><span class="pre">ceiling</span></code> 以及 <code
                                  class="docutils literal"><span class="pre">round</span></code> 也从它们的参数中导出整数。使用 <code
                                  class="docutils literal"><span class="pre">floor</span></code> 返回小于等于其参数的最大整数，而 <code
                                  class="docutils literal"><span class="pre">ceiling</span></code> 返回大于或等于其参数的最小整数，我们可以将
                                <code class="docutils literal"><span class="pre">mirror?</span></code> (46 页，译注: 3.11
                                节)改成可以找出所有回文（palindromes）的版本:
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">palindrome?</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">mid</span> <span class="p">(</span><span class="nb">/</span> <span class="p">(</span><span class="nb">length</span> <span class="nv">x</span><span class="p">)</span> <span class="mi">2</span><span class="p">)))</span>
    <span class="p">(</span><span class="nb">equal</span> <span class="p">(</span><span class="nb">subseq</span> <span class="nv">x</span> <span class="mi">0</span> <span class="p">(</span><span class="nb">floor</span> <span class="nv">mid</span><span class="p">))</span>
           <span class="p">(</span><span class="nb">reverse</span> <span class="p">(</span><span class="nb">subseq</span> <span class="nv">x</span> <span class="p">(</span><span class="nb">ceiling</span> <span class="nv">mid</span><span class="p">))))))</span>
</pre>
                                </div>
                              </div>
                              <p>和 <code class="docutils literal"><span class="pre">truncate</span></code> 一样， <code
                                  class="docutils literal"><span class="pre">floor</span></code> 与 <code
                                  class="docutils literal"><span class="pre">ceiling</span></code>
                                也返回传入参数与第一个返回值的差，作为第二个返回值。</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">floor</span> <span class="mf">1.5</span><span class="p">)</span>
<span class="mi">1</span>
<span class="mf">0.5</span>
</pre>
                                </div>
                              </div>
                              <p>实际上，我们可以把 <code class="docutils literal"><span class="pre">truncate</span></code>
                                想成是这样定义的:</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">our-truncate</span> <span class="p">(</span><span class="nv">n</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">&gt;</span> <span class="nv">n</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">(</span><span class="nb">floor</span> <span class="nv">n</span><span class="p">)</span>
        <span class="p">(</span><span class="nb">ceiling</span> <span class="nv">n</span><span class="p">)))</span>
</pre>
                                </div>
                              </div>
                              <p>函数 <code class="docutils literal"><span class="pre">round</span></code>
                                返回最接近其参数的整数。当参数与两个整数的距离相等时， Common Lisp 和很多程序语言一样，不会往上取（round up）整数。而是取最近的偶数：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">mapcar</span> <span class="nf">#&#39;</span><span class="nb">round</span> <span class="o">&#39;</span><span class="p">(</span><span class="mf">-2.5</span> <span class="mf">-1.5</span> <span class="mf">1.5</span> <span class="mf">2.5</span><span class="p">))</span>
<span class="p">(</span><span class="mi">-2</span> <span class="mi">-2</span> <span class="mi">2</span> <span class="mi">2</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>在某些数值应用中这是好事，因为舍入误差（rounding error）通常会互相抵消。但要是用户期望你的程序将某些值取整数时，你必须自己提供这个功能。 <a
                                  class="footnote-reference" href="#id5" id="id2">[1]</a> 与其他的函数一样， <code
                                  class="docutils literal"><span class="pre">round</span></code>
                                返回传入参数与第一个返回值的差，作为第二个返回值。</p>
                              <p>函数 <code class="docutils literal"><span class="pre">mod</span></code> 仅返回 <code
                                  class="docutils literal"><span class="pre">floor</span></code> 返回的第二个返回值；而 <code
                                  class="docutils literal"><span class="pre">rem</span></code> 返回 <code
                                  class="docutils literal"><span class="pre">truncate</span></code> 返回的第二个返回值。我们在 94
                                页（译注： 5.7 节）曾使用 <code class="docutils literal"><span class="pre">mod</span></code>
                                来决定一个数是否可被另一个整除，以及 127 页（译注： 7.4 节）用来找出环状缓冲区（ring buffer）中，元素实际的位置。</p>
                              <p>关于实数，函数 <code class="docutils literal"><span class="pre">signum</span></code> 返回 <code
                                  class="docutils literal"><span class="pre">1</span></code> 、 <code
                                  class="docutils literal"><span class="pre">0</span></code> 或 <code
                                  class="docutils literal"><span class="pre">-1</span></code> ，取决于它的参数是正数、零或负数。函数 <code
                                  class="docutils literal"><span class="pre">abs</span></code> 返回其参数的绝对值。因此 <code
                                  class="docutils literal"><span class="pre">(*</span> <span class="pre">(abs</span> <span class="pre">x)</span> <span class="pre">(signum</span> <span class="pre">x))</span></code>
                                等于 <code class="docutils literal"><span class="pre">x</span></code> 。</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">mapcar</span> <span class="nf">#&#39;</span><span class="nb">signum</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">-2</span> <span class="mf">-0.0</span> <span class="mf">0.0</span> <span class="mi">0</span> <span class="mf">.5</span> <span class="mi">3</span><span class="p">))</span>
<span class="p">(</span><span class="mi">-1</span> <span class="mf">-0.0</span> <span class="mf">0.0</span> <span class="mi">0</span> <span class="mf">1.0</span> <span class="mi">1</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>在某些应用里， <code class="docutils literal"><span class="pre">-0.0</span></code> 可能自成一格（in
                                its own right），如上所示。实际上功能上几乎没有差别，因为数值 <code
                                  class="docutils literal"><span class="pre">-0.0</span></code> 与 <code
                                  class="docutils literal"><span class="pre">0.0</span></code> 有着一样的行为。</p>
                              <p>比值与复数概念上是两部分的结构。(译注：像 <strong>Cons</strong> 这样的两部分结构) 函数 <code
                                  class="docutils literal"><span class="pre">numerator</span></code> 与 <code
                                  class="docutils literal"><span class="pre">denominator</span></code>
                                返回比值或整数的分子与分母。（如果数字是整数，前者返回该数，而后者返回 <code
                                  class="docutils literal"><span class="pre">1</span></code> 。）函数 <code
                                  class="docutils literal"><span class="pre">realpart</span></code> 与 <code
                                  class="docutils literal"><span class="pre">imgpart</span></code>
                                返回任何数字的实数与虚数部分。（如果数字不是复数，前者返回该数字，后者返回 <code
                                  class="docutils literal"><span class="pre">0</span></code> 。）</p>
                              <p>函数 <code class="docutils literal"><span class="pre">random</span></code>
                                接受一个整数或浮点数。这样形式的表达式 <code
                                  class="docutils literal"><span class="pre">(random</span> <span class="pre">n)</span></code>
                                ，会返回一个大于等于 <code class="docutils literal"><span class="pre">0</span></code> 并小于 <code
                                  class="docutils literal"><span class="pre">n</span></code> 的数字，并有着与 <code
                                  class="docutils literal"><span class="pre">n</span></code> 相同的类型。</p>
                            </div>
                            <div class="section" id="comparison">
                              <h4>9.3 比较 (Comparison)<a class="headerlink" href="#comparison"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>谓词 <code class="docutils literal"><span class="pre">=</span></code> 比较其参数，当数值上相等时 ──
                                即两者的差为零时，返回真。</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">=</span> <span class="mi">1</span> <span class="mf">1.0</span><span class="p">)</span>
<span class="no">T</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="nb">eql</span> <span class="mi">1</span> <span class="mf">1.0</span><span class="p">)</span>
<span class="no">NIL</span>
</pre>
                                </div>
                              </div>
                              <p><code class="docutils literal"><span class="pre">=</span></code> 比起 <code
                                  class="docutils literal"><span class="pre">eql</span></code> 来得宽松，但参数的类型需一致。</p>
                              <p>用来比较数字的谓词为 <code class="docutils literal"><span class="pre">&lt;</span></code> （小于）、
                                <code class="docutils literal"><span class="pre">&lt;=</span></code> （小于等于）、 <code
                                  class="docutils literal"><span class="pre">=</span></code> （等于）、 <code
                                  class="docutils literal"><span class="pre">&gt;=</span></code> （大于等于）、 <code
                                  class="docutils literal"><span class="pre">&gt;</span></code> (大于) 以及 <code
                                  class="docutils literal"><span class="pre">/=</span></code>
                                （不相等）。以上所有皆接受一个或多个参数。只有一个参数时，它们全返回真。
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">&lt;=</span> <span class="nv">w</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>等同于二元操作符的结合（conjunction），应用至每一对参数上:</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nb">&lt;=</span> <span class="nv">w</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">&lt;=</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="nb">&lt;=</span> <span class="nv">y</span> <span class="nv">z</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p>由于 <code class="docutils literal"><span class="pre">/=</span></code>
                                若它的两个参数不等于时会返回真，表达式</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">/=</span> <span class="nv">w</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>等同于</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nb">/=</span> <span class="nv">w</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">/=</span> <span class="nv">w</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="nb">/=</span> <span class="nv">w</span> <span class="nv">z</span><span class="p">)</span>
     <span class="p">(</span><span class="nb">/=</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="nb">/=</span> <span class="nv">y</span> <span class="nv">z</span><span class="p">)</span> <span class="p">(</span><span class="nb">/=</span> <span class="nv">y</span> <span class="nv">z</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p>特殊的谓词 <code class="docutils literal"><span class="pre">zerop</span></code> 、 <code
                                  class="docutils literal"><span class="pre">plusp</span></code> 与 <code
                                  class="docutils literal"><span class="pre">minusp</span></code> 接受一个参数，分别于参数 <code
                                  class="docutils literal"><span class="pre">=</span></code> 、 <code
                                  class="docutils literal"><span class="pre">&gt;</span></code> 、 <code
                                  class="docutils literal"><span class="pre">&lt;</span></code> 零时，返回真。虽然 <code
                                  class="docutils literal"><span class="pre">-0.0</span></code> （如果实现有使用它）前面有个负号，但它
                                <code class="docutils literal"><span class="pre">=</span></code> 零，
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">list</span> <span class="p">(</span><span class="nb">minusp</span> <span class="mf">-0.0</span><span class="p">)</span> <span class="p">(</span><span class="nb">zerop</span> <span class="mf">-0.0</span><span class="p">))</span>
<span class="p">(</span><span class="no">NIL</span> <span class="no">T</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>因此对 <code class="docutils literal"><span class="pre">-0.0</span></code> 使用 <code
                                  class="docutils literal"><span class="pre">zerop</span></code> ，而不是 <code
                                  class="docutils literal"><span class="pre">minusp</span></code> 。</p>
                              <p>谓词 <code class="docutils literal"><span class="pre">oddp</span></code> 与 <code
                                  class="docutils literal"><span class="pre">evenp</span></code>
                                只能用在整数。前者只对奇数返回真，后者只对偶数返回真。</p>
                              <p>本节定义的谓词中，只有 <code class="docutils literal"><span class="pre">=</span></code> 、 <code
                                  class="docutils literal"><span class="pre">/=</span></code> 与 <code
                                  class="docutils literal"><span class="pre">zerop</span></code> 可以用在复数。</p>
                              <p>函数 <code class="docutils literal"><span class="pre">max</span></code> 与 <code
                                  class="docutils literal"><span class="pre">min</span></code>
                                分别返回其参数的最大值与最小值。两者至少需要给一个参数:</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">list</span> <span class="p">(</span><span class="nb">max</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">)</span> <span class="p">(</span><span class="nb">min</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">))</span>
<span class="p">(</span><span class="mi">5</span> <span class="mi">1</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>如果参数含有浮点数的话，结果的类型取决于各家实现。</p>
                            </div>
                            <div class="section" id="arithematic">
                              <h4>9.4 算术 (Arithematic)<a class="headerlink" href="#arithematic"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>用来做加减的函数是 <code class="docutils literal"><span class="pre">+</span></code> 与 <code
                                  class="docutils literal"><span class="pre">-</span></code>
                                。两者皆接受任何数量的参数，包括没有参数，在没有参数的情况下返回 <code
                                  class="docutils literal"><span class="pre">0</span></code> 。（译注: <code
                                  class="docutils literal"><span class="pre">-</span></code>
                                在没有参数的情况下会报错，至少要一个参数）一个这样形式的表达式 <code
                                  class="docutils literal"><span class="pre">(-</span> <span class="pre">n)</span></code>
                                返回 <code class="docutils literal"><span class="pre">-n</span></code> 。一个这样形式的表达式</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">-</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>等同于</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">-</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span> <span class="nv">z</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>有两个函数 <code class="docutils literal"><span class="pre">1+</span></code> 与 <code
                                  class="docutils literal"><span class="pre">1-</span></code> ，分别将参数加 <code
                                  class="docutils literal"><span class="pre">1</span></code> 与减 <code
                                  class="docutils literal"><span class="pre">1</span></code> 后返回。 <code
                                  class="docutils literal"><span class="pre">1-</span></code> 有一点误导，因为 <code
                                  class="docutils literal"><span class="pre">(1-</span> <span class="pre">x)</span></code>
                                返回 <code class="docutils literal"><span class="pre">x-1</span></code> 而不是 <code
                                  class="docutils literal"><span class="pre">1-x</span></code> 。</p>
                              <p>宏 <code class="docutils literal"><span class="pre">incf</span></code> 及 <code
                                  class="docutils literal"><span class="pre">decf</span></code> 分别递增与递减数字。这样形式的表达式 <code
                                  class="docutils literal"><span class="pre">(incf</span> <span class="pre">x</span> <span class="pre">n)</span></code>
                                类似于 <code
                                  class="docutils literal"><span class="pre">(setf</span> <span class="pre">x</span> <span class="pre">(+</span> <span class="pre">x</span> <span class="pre">n))</span></code>
                                的效果，而 <code
                                  class="docutils literal"><span class="pre">(decf</span> <span class="pre">x</span> <span class="pre">n)</span></code>
                                类似于 <code
                                  class="docutils literal"><span class="pre">(setf</span> <span class="pre">x</span> <span class="pre">(-</span> <span class="pre">x</span> <span class="pre">n))</span></code>
                                的效果。这两个形式里，第二个参数皆是选择性给入的，缺省值为 <code
                                  class="docutils literal"><span class="pre">1</span></code> 。</p>
                              <p>用来做乘法的函数是 <code class="docutils literal"><span class="pre">*</span></code>
                                。接受任何数量的参数。没有参数时返回 <code class="docutils literal"><span class="pre">1</span></code>
                                。否则返回参数的乘积。</p>
                              <p>除法函数 <code class="docutils literal"><span class="pre">/</span></code> 至少要给一个参数。这样形式的调用
                                <code
                                  class="docutils literal"><span class="pre">(/</span> <span class="pre">n)</span></code>
                                等同于 <code
                                  class="docutils literal"><span class="pre">(/</span> <span class="pre">1</span> <span class="pre">n)</span></code>
                                ，
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">/</span> <span class="mi">3</span><span class="p">)</span>
<span class="m">1/3</span>
</pre>
                                </div>
                              </div>
                              <p>而这样形式的调用</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">/</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>等同于</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">/</span> <span class="p">(</span><span class="nb">/</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span> <span class="nv">z</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>注意 <code class="docutils literal"><span class="pre">-</span></code> 与 <code
                                  class="docutils literal"><span class="pre">/</span></code> 两者在这方面的相似性。</p>
                              <p>当给定两个整数时， <code class="docutils literal"><span class="pre">/</span></code>
                                若第一个不是第二个的倍数时，会返回一个比值:</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">/</span> <span class="mi">365</span> <span class="mi">12</span><span class="p">)</span>
<span class="m">365/12</span>
</pre>
                                </div>
                              </div>
                              <p>举例来说，如果你试着找出平均每一个月有多长，可能会有解释器在逗你玩的感觉。在这个情况下，你需要的是，对比值调用 <code
                                  class="docutils literal"><span class="pre">float</span></code> ，而不是对两个整数做 <code
                                  class="docutils literal"><span class="pre">/</span></code> 。</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">float</span> <span class="m">365/12</span><span class="p">)</span>
<span class="mf">30.416666</span>
</pre>
                                </div>
                              </div>
                            </div>
                            <div class="section" id="exponentiation">
                              <h4>9.5 指数 (Exponentiation)<a class="headerlink" href="#exponentiation"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>要找到 <span class="math">\(x^n\)</span> 调用 <code
                                  class="docutils literal"><span class="pre">(expt</span> <span class="pre">x</span> <span class="pre">n)</span></code>
                                ，</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">expt</span> <span class="mi">2</span> <span class="mi">5</span><span class="p">)</span>
<span class="mi">32</span>
</pre>
                                </div>
                              </div>
                              <p>而要找到 <span class="math">\(log_nx\)</span> 调用 <code
                                  class="docutils literal"><span class="pre">(log</span> <span class="pre">x</span> <span class="pre">n)</span></code>
                                :</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">log</span> <span class="mi">32</span> <span class="mi">2</span><span class="p">)</span>
<span class="mf">5.0</span>
</pre>
                                </div>
                              </div>
                              <p>通常返回一个浮点数。</p>
                              <p>要找到 <span class="math">\(e^x\)</span> 有一个特别的函数 <code
                                  class="docutils literal"><span class="pre">exp</span></code> ，</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">exp</span> <span class="mi">2</span><span class="p">)</span>
<span class="mf">7.389056</span>
</pre>
                                </div>
                              </div>
                              <p>而要找到自然对数，你可以使用 <code class="docutils literal"><span class="pre">log</span></code>
                                就好，因为第二个参数缺省为 <code class="docutils literal"><span class="pre">e</span></code> :</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">log</span> <span class="mf">7.389056</span><span class="p">)</span>
<span class="mf">2.0</span>
</pre>
                                </div>
                              </div>
                              <p>要找到立方根，你可以调用 <code class="docutils literal"><span class="pre">expt</span></code>
                                用一个比值作为第二个参数，</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">expt</span> <span class="mi">27</span> <span class="m">1/3</span><span class="p">)</span>
<span class="mf">3.0</span>
</pre>
                                </div>
                              </div>
                              <p>但要找到平方根，函数 <code class="docutils literal"><span class="pre">sqrt</span></code> 会比较快:
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">sqrt</span> <span class="mi">4</span><span class="p">)</span>
<span class="mf">2.0</span>
</pre>
                                </div>
                              </div>
                            </div>
                            <div class="section" id="trigometric-functions">
                              <h4>9.6 三角函数 (Trigometric Functions)<a class="headerlink" href="#trigometric-functions"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>常量 <code class="docutils literal"><span class="pre">pi</span></code> 是 <code
                                  class="docutils literal"><span class="pre">π</span></code> 的浮点表示法。它的精度取决于各家实现。函数 <code
                                  class="docutils literal"><span class="pre">sin</span></code> 、 <code
                                  class="docutils literal"><span class="pre">cos</span></code> 及 <code
                                  class="docutils literal"><span class="pre">tan</span></code>
                                分别可以找到正弦、余弦及正交函数，其中角度以径度表示：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">x</span> <span class="p">(</span><span class="nb">/</span> <span class="nv">pi</span> <span class="mi">4</span><span class="p">)))</span>
    <span class="p">(</span><span class="nb">list</span> <span class="p">(</span><span class="nb">sin</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">cos</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">tan</span> <span class="nv">x</span><span class="p">)))</span>
<span class="p">(</span><span class="mf">0.7071067811865475d0</span> <span class="mf">0.7071067811865476d0</span> <span class="mf">1.0d0</span><span class="p">)</span>
<span class="c1">;;; 译注: CCL 1.8  SBCL 1.0.55 下的结果是</span>
<span class="c1">;;; (0.7071067811865475D0 0.7071067811865476D0 0.9999999999999999D0)</span>
</pre>
                                </div>
                              </div>
                              <p>这些函数都接受负数及复数参数。</p>
                              <p>函数 <code class="docutils literal"><span class="pre">asin</span></code> 、 <code
                                  class="docutils literal"><span class="pre">acos</span></code> 及 <code
                                  class="docutils literal"><span class="pre">atan</span></code> 实现了正弦、余弦及正交的反函数。参数介于
                                <code class="docutils literal"><span class="pre">-1</span></code> 与 <code
                                  class="docutils literal"><span class="pre">1</span></code> 之间（包含）时， <code
                                  class="docutils literal"><span class="pre">asin</span></code> 与 <code
                                  class="docutils literal"><span class="pre">acos</span></code> 返回实数。
                              </p>
                              <p>双曲正弦、双曲余弦及双曲正交分别由 <code class="docutils literal"><span class="pre">sinh</span></code> 、
                                <code class="docutils literal"><span class="pre">cosh</span></code> 及 <code
                                  class="docutils literal"><span class="pre">tanh</span></code> 实现。它们的反函数同样为 <code
                                  class="docutils literal"><span class="pre">asinh</span></code> 、 <code
                                  class="docutils literal"><span class="pre">acosh</span></code> 以及 <code
                                  class="docutils literal"><span class="pre">atanh</span></code> 。
                              </p>
                            </div>
                            <div class="section" id="representations">
                              <h4>9.7 表示法 (Representations)<a class="headerlink" href="#representations"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>Common Lisp 没有限制整数的大小。可以塞进一个字（word）内存的小整数称为定长数(fixnums)。在计算过程中，整数无法塞入一个字时，Lisp
                                切换至使用多个字的表示法（一个大数 「bignum」）。所以整数的大小限制取决于实体内存，而不是语言。</p>
                              <p>常量 <code class="docutils literal"><span class="pre">most-positive-fixnum</span></code>
                                与 <code class="docutils literal"><span class="pre">most-negative-fixnum</span></code>
                                表示一个实现不使用大数所可表示的最大与最小的数字大小。在很多实现里，它们为：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">values</span> <span class="nv">most-positive-fixnum</span> <span class="nv">most-negative-fixnum</span><span class="p">)</span>
<span class="mi">536870911</span>
<span class="mi">-536870912</span>
<span class="c1">;;; 译注: CCL 1.8 的结果为</span>
<span class="mi">1152921504606846975</span>
<span class="mi">-1152921504606846976</span>
<span class="c1">;;; SBCL 1.0.55 的结果为</span>
<span class="mi">4611686018427387903</span>
<span class="mi">-4611686018427387904</span>
</pre>
                                </div>
                              </div>
                              <p>谓词 <code class="docutils literal"><span class="pre">typep</span></code>
                                接受一个参数及一个类型名称，并返回指定类型的参数。所以，</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">typep</span> <span class="mi">1</span> <span class="ss">&#39;fixnum</span><span class="p">)</span>
<span class="no">T</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="k">type</span> <span class="p">(</span><span class="nb">1+</span> <span class="nv">most-positive-fixnum</span><span class="p">)</span> <span class="ss">&#39;bignum</span><span class="p">)</span>
<span class="no">T</span>
</pre>
                                </div>
                              </div>
                              <p>浮点数的数值限制是取决于各家实现的。 Common Lisp 提供了至多四种类型的浮点数：短浮点 <code
                                  class="docutils literal"><span class="pre">short-float</span></code> 、 单浮点 <code
                                  class="docutils literal"><span class="pre">single-float</span></code> 、双浮点 <code
                                  class="docutils literal"><span class="pre">double-float</span></code> 以及长浮点 <code
                                  class="docutils literal"><span class="pre">long-float</span></code> 。Common Lisp
                                的实现是不需要用不同的格式来表示这四种类型（很少有实现这么干）。</p>
                              <p>
                                一般来说，短浮点应可塞入一个字，单浮点与双浮点提供普遍的单精度与双精度浮点数的概念，而长浮点，如果想要的话，可以是很大的数。但实现可以不对这四种类型做区别，也是完全没有问题的。
                              </p>
                              <p>你可以指定你想要何种格式的浮点数，当数字是用科学表示法时，可以通过将 <code
                                  class="docutils literal"><span class="pre">e</span></code> 替换为 <code
                                  class="docutils literal"><span class="pre">s</span></code> <code
                                  class="docutils literal"><span class="pre">f</span></code> <code
                                  class="docutils literal"><span class="pre">d</span></code> <code
                                  class="docutils literal"><span class="pre">l</span></code>
                                来得到不同的浮点数。（你也可以使用大写，这对长浮点来说是个好主意，因为 <code
                                  class="docutils literal"><span class="pre">l</span></code> 看起来太像 <code
                                  class="docutils literal"><span class="pre">1</span></code> 了。）所以要表示最大的 <code
                                  class="docutils literal"><span class="pre">1.0</span></code> 你可以写 <code
                                  class="docutils literal"><span class="pre">1L0</span></code> 。</p>
                              <p>（译注: <code class="docutils literal"><span class="pre">s</span></code> 为短浮点、 <code
                                  class="docutils literal"><span class="pre">f</span></code> 为单浮点、 <code
                                  class="docutils literal"><span class="pre">d</span></code> 为双浮点、 <code
                                  class="docutils literal"><span class="pre">l</span></code> 为长浮点。）</p>
                              <p>在给定的实现里，用十六个全局常量标明了每个格式的限制。它们的名字是这种形式: <code
                                  class="docutils literal"><span class="pre">m-s-f</span></code> ，其中 <code
                                  class="docutils literal"><span class="pre">m</span></code> 是 <code
                                  class="docutils literal"><span class="pre">most</span></code> 或 <code
                                  class="docutils literal"><span class="pre">least</span></code> ， <code
                                  class="docutils literal"><span class="pre">s</span></code> 是 <code
                                  class="docutils literal"><span class="pre">positive</span></code> 或 <code
                                  class="docutils literal"><span class="pre">negative</span></code> ，而 <code
                                  class="docutils literal"><span class="pre">f</span></code> 是四种浮点数之一。 <a
                                  class="reference external"
                                  href="http://acl.readthedocs.org/en/latest/zhCN/notes-cn.html#notes-150">λ</a></p>
                              <p>浮点数下溢（underflow）与溢出（overflow），都会被 Common Lisp 视为错误 :</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">most-positive-long-float</span> <span class="mi">10</span><span class="p">)</span>
<span class="nv">Error:</span> <span class="kt">floating-point-overflow</span>
</pre>
                                </div>
                              </div>
                            </div>
                            <div class="section" id="example-ray-tracing">
                              <h4>9.8 范例：追踪光线 (Example: Ray-Tracing)<a class="headerlink" href="#example-ray-tracing"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>作为一个数值应用的范例，本节示范了如何撰写一个光线追踪器 (ray-tracer)。光线追踪是一个高级的 (deluxe)渲染算法: 它产生出逼真的图像，但需要花点时间。
                              </p>
                              <p>要产生一个 3D 的图像，我们至少需要定义四件事: 一个观测点 (eye)、一个或多个光源、一个由一个或多个平面所组成的模拟世界 (simulated
                                world)，以及一个作为通往这个世界的窗户的平面 (图像平面「image plane」)。我们产生出的是模拟世界投影在图像平面区域的图像。</p>
                              <p>光线追踪独特的地方在于，我们如何找到这个投影: 我们一个一个像素地沿着图像平面走，追踪回到模拟世界里的光线。这个方法带来三个主要的优势: 它让我们容易得到现实世界的光学效应
                                (optical effect)，如透明度 (transparency)、反射光 (reflected light)以及产生阴影 (cast
                                shadows)；它让我们可以直接用任何我们想要的几何的物体，来定义出模拟的世界，而不需要用多边形 (polygons)来建构它们；以及它很简单实现。</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">sq</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">x</span> <span class="nv">x</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">mag</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">sqrt</span> <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nv">sq</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nv">sq</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="nv">sq</span> <span class="nv">z</span><span class="p">))))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">unit-vector</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">d</span> <span class="p">(</span><span class="nv">mag</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span><span class="p">)))</span>
    <span class="p">(</span><span class="nb">values</span> <span class="p">(</span><span class="nb">/</span> <span class="nv">x</span> <span class="nv">d</span><span class="p">)</span> <span class="p">(</span><span class="nb">/</span> <span class="nv">y</span> <span class="nv">d</span><span class="p">)</span> <span class="p">(</span><span class="nb">/</span> <span class="nv">z</span> <span class="nv">d</span><span class="p">))))</span>

<span class="p">(</span><span class="nb">defstruct</span> <span class="p">(</span><span class="nv">point</span> <span class="p">(</span><span class="ss">:conc-name</span> <span class="no">nil</span><span class="p">))</span>
  <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">distance</span> <span class="p">(</span><span class="nv">p1</span> <span class="nv">p2</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">mag</span> <span class="p">(</span><span class="nb">-</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">p1</span><span class="p">)</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">p2</span><span class="p">))</span>
       <span class="p">(</span><span class="nb">-</span> <span class="p">(</span><span class="nv">y</span> <span class="nv">p1</span><span class="p">)</span> <span class="p">(</span><span class="nv">y</span> <span class="nv">p2</span><span class="p">))</span>
       <span class="p">(</span><span class="nb">-</span> <span class="p">(</span><span class="nv">z</span> <span class="nv">p1</span><span class="p">)</span> <span class="p">(</span><span class="nv">z</span> <span class="nv">p2</span><span class="p">))))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">minroot</span> <span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">zerop</span> <span class="nv">a</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">/</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">c</span><span class="p">)</span> <span class="nv">b</span><span class="p">)</span>
      <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">disc</span> <span class="p">(</span><span class="nb">-</span> <span class="p">(</span><span class="nv">sq</span> <span class="nv">b</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="mi">4</span> <span class="nv">a</span> <span class="nv">c</span><span class="p">))))</span>
        <span class="p">(</span><span class="nb">unless</span> <span class="p">(</span><span class="nb">minusp</span> <span class="nv">disc</span><span class="p">)</span>
          <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">discrt</span> <span class="p">(</span><span class="nb">sqrt</span> <span class="nv">disc</span><span class="p">)))</span>
            <span class="p">(</span><span class="nb">min</span> <span class="p">(</span><span class="nb">/</span> <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">b</span><span class="p">)</span> <span class="nv">discrt</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="mi">2</span> <span class="nv">a</span><span class="p">))</span>
                 <span class="p">(</span><span class="nb">/</span> <span class="p">(</span><span class="nb">-</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">b</span><span class="p">)</span> <span class="nv">discrt</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="mi">2</span> <span class="nv">a</span><span class="p">))))))))</span>
</pre>
                                </div>
                              </div>
                              <p><strong>图 9.2 实用数学函数</strong></p>
                              <p>图 9.2 包含了我们在光线追踪器里会需要用到的一些实用数学函数。第一个 <code
                                  class="docutils literal"><span class="pre">sq</span></code> ，返回其参数的平方。下一个 <code
                                  class="docutils literal"><span class="pre">mag</span></code> ，返回一个给定 <code
                                  class="docutils literal"><span class="pre">x</span></code> <code
                                  class="docutils literal"><span class="pre">y</span></code> <code
                                  class="docutils literal"><span class="pre">z</span></code> 所组成向量的大小
                                (magnitude)。这个函数被接下来两个函数用到。我们在 <code
                                  class="docutils literal"><span class="pre">unit-vector</span></code>
                                用到了，此函数返回三个数值，来表示与单位向量有着同样方向的向量，其中向量是由 <code
                                  class="docutils literal"><span class="pre">x</span></code> <code
                                  class="docutils literal"><span class="pre">y</span></code> <code
                                  class="docutils literal"><span class="pre">z</span></code> 所组成的:</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="k">multiple-value-call</span> <span class="nf">#&#39;</span><span class="nv">mag</span> <span class="p">(</span><span class="nv">unit-vector</span> <span class="mi">23</span> <span class="mi">12</span> <span class="mi">47</span><span class="p">))</span>
<span class="mf">1.0</span>
</pre>
                                </div>
                              </div>
                              <p>我们在 <code class="docutils literal"><span class="pre">distance</span></code> 也用到了 <code
                                  class="docutils literal"><span class="pre">mag</span></code> ，它返回三维空间中，两点的距离。（定义 <code
                                  class="docutils literal"><span class="pre">point</span></code> 结构来有一个 <code
                                  class="docutils literal"><span class="pre">nil</span></code> 的 <code
                                  class="docutils literal"><span class="pre">conc-name</span></code>
                                意味着栏位存取的函数会有跟栏位一样的名字: 举例来说， <code
                                  class="docutils literal"><span class="pre">x</span></code> 而不是 <code
                                  class="docutils literal"><span class="pre">point-x</span></code> 。)</p>
                              <p>最后 <code class="docutils literal"><span class="pre">minroot</span></code> 接受三个实数， <code
                                  class="docutils literal"><span class="pre">a</span></code> , <code
                                  class="docutils literal"><span class="pre">b</span></code> 与 <code
                                  class="docutils literal"><span class="pre">c</span></code> ，并返回满足等式 <span
                                  class="math">\(ax^2+bx+c=0\)</span> 的最小实数 <code
                                  class="docutils literal"><span class="pre">x</span></code> 。当 <code
                                  class="docutils literal"><span class="pre">a</span></code> 不为 <span
                                  class="math">\(0\)</span> 时，这个等式的根由下面这个熟悉的式子给出:</p>
                              <div class="math">
                                \[x = \dfrac{-b \pm \sqrt{b^2 - 4ac}}{2a}\]</div>
                              <p>图 9.3 包含了定义一个最小光线追踪器的代码。 它产生通过单一光源照射的黑白图像，与观测点 (eye)处于同个位置。 (结果看起来像是闪光摄影术 (flash
                                photography)拍出来的)</p>
                              <p><code class="docutils literal"><span class="pre">surface</span></code>
                                结构用来表示模拟世界中的物体。更精确的说，它会被 <code
                                  class="docutils literal"><span class="pre">included</span></code> 至定义具体类型物体的结构里，像是球体
                                (spheres)。 <code class="docutils literal"><span class="pre">surface</span></code>
                                结构本身只包含一个栏位: 一个 <code class="docutils literal"><span class="pre">color</span></code> 范围从
                                0 (黑色) 至 1 (白色)。</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defstruct</span> <span class="nv">surface</span> <span class="nv">color</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defparameter</span> <span class="vg">*world*</span> <span class="no">nil</span><span class="p">)</span>
<span class="p">(</span><span class="nb">defconstant</span> <span class="nv">eye</span> <span class="p">(</span><span class="nv">make-point</span> <span class="ss">:x</span> <span class="mi">0</span> <span class="ss">:y</span> <span class="mi">0</span> <span class="ss">:z</span> <span class="mi">200</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">tracer</span> <span class="p">(</span><span class="nb">pathname</span> <span class="k">&amp;optional</span> <span class="p">(</span><span class="nv">res</span> <span class="mi">1</span><span class="p">))</span>
  <span class="p">(</span><span class="nb">with-open-file</span> <span class="p">(</span><span class="nv">p</span> <span class="nb">pathname</span> <span class="ss">:direction</span> <span class="ss">:output</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">format</span> <span class="nv">p</span> <span class="s">&quot;P2 ~A ~A 255&quot;</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">res</span> <span class="mi">100</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">res</span> <span class="mi">100</span><span class="p">))</span>
    <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">inc</span> <span class="p">(</span><span class="nb">/</span> <span class="nv">res</span><span class="p">)))</span>
      <span class="p">(</span><span class="nb">do</span> <span class="p">((</span><span class="nv">y</span> <span class="mi">-50</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">y</span> <span class="nv">inc</span><span class="p">)))</span>
          <span class="p">((</span><span class="nb">&lt;</span> <span class="p">(</span><span class="nb">-</span> <span class="mi">50</span> <span class="nv">y</span><span class="p">)</span> <span class="nv">inc</span><span class="p">))</span>
        <span class="p">(</span><span class="nb">do</span> <span class="p">((</span><span class="nv">x</span> <span class="mi">-50</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="nv">inc</span><span class="p">)))</span>
            <span class="p">((</span><span class="nb">&lt;</span> <span class="p">(</span><span class="nb">-</span> <span class="mi">50</span> <span class="nv">x</span><span class="p">)</span> <span class="nv">inc</span><span class="p">))</span>
          <span class="p">(</span><span class="nb">print</span> <span class="p">(</span><span class="nv">color-at</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span> <span class="nv">p</span><span class="p">))))))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">color-at</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">multiple-value-bind</span> <span class="p">(</span><span class="nv">xr</span> <span class="nv">yr</span> <span class="nv">zr</span><span class="p">)</span>
                       <span class="p">(</span><span class="nv">unit-vector</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">x</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">eye</span><span class="p">))</span>
                                    <span class="p">(</span><span class="nb">-</span> <span class="nv">y</span> <span class="p">(</span><span class="nv">y</span> <span class="nv">eye</span><span class="p">))</span>
                                    <span class="p">(</span><span class="nb">-</span> <span class="mi">0</span> <span class="p">(</span><span class="nv">z</span> <span class="nv">eye</span><span class="p">)))</span>
    <span class="p">(</span><span class="nb">round</span> <span class="p">(</span><span class="nb">*</span> <span class="p">(</span><span class="nv">sendray</span> <span class="nv">eye</span> <span class="nv">xr</span> <span class="nv">yr</span> <span class="nv">zr</span><span class="p">)</span> <span class="mi">255</span><span class="p">))))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">sendray</span> <span class="p">(</span><span class="nv">pt</span> <span class="nv">xr</span> <span class="nv">yr</span> <span class="nv">zr</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">multiple-value-bind</span> <span class="p">(</span><span class="nv">s</span> <span class="nv">int</span><span class="p">)</span> <span class="p">(</span><span class="nv">first-hit</span> <span class="nv">pt</span> <span class="nv">xr</span> <span class="nv">yr</span> <span class="nv">zr</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if</span> <span class="nv">s</span>
        <span class="p">(</span><span class="nb">*</span> <span class="p">(</span><span class="nv">lambert</span> <span class="nv">s</span> <span class="nv">int</span> <span class="nv">xr</span> <span class="nv">yr</span> <span class="nv">zr</span><span class="p">)</span> <span class="p">(</span><span class="nv">surface-color</span> <span class="nv">s</span><span class="p">))</span>
        <span class="mi">0</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">first-hit</span> <span class="p">(</span><span class="nv">pt</span> <span class="nv">xr</span> <span class="nv">yr</span> <span class="nv">zr</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">(</span><span class="nv">surface</span> <span class="nv">hit</span> <span class="nv">dist</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">dolist</span> <span class="p">(</span><span class="nv">s</span> <span class="vg">*world*</span><span class="p">)</span>
      <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">h</span> <span class="p">(</span><span class="nv">intersect</span> <span class="nv">s</span> <span class="nv">pt</span> <span class="nv">xr</span> <span class="nv">yr</span> <span class="nv">zr</span><span class="p">)))</span>
        <span class="p">(</span><span class="nb">when</span> <span class="nv">h</span>
          <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">d</span> <span class="p">(</span><span class="nv">distance</span> <span class="nv">h</span> <span class="nv">pt</span><span class="p">)))</span>
            <span class="p">(</span><span class="nb">when</span> <span class="p">(</span><span class="nb">or</span> <span class="p">(</span><span class="nb">null</span> <span class="nv">dist</span><span class="p">)</span> <span class="p">(</span><span class="nb">&lt;</span> <span class="nv">d</span> <span class="nv">dist</span><span class="p">))</span>
              <span class="p">(</span><span class="nb">setf</span> <span class="nv">surface</span> <span class="nv">s</span> <span class="nv">hit</span> <span class="nv">h</span> <span class="nv">dist</span> <span class="nv">d</span><span class="p">))))))</span>
    <span class="p">(</span><span class="nb">values</span> <span class="nv">surface</span> <span class="nv">hit</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">lambert</span> <span class="p">(</span><span class="nv">s</span> <span class="nv">int</span> <span class="nv">xr</span> <span class="nv">yr</span> <span class="nv">zr</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">multiple-value-bind</span> <span class="p">(</span><span class="nv">xn</span> <span class="nv">yn</span> <span class="nv">zn</span><span class="p">)</span> <span class="p">(</span><span class="nv">normal</span> <span class="nv">s</span> <span class="nv">int</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">max</span> <span class="mi">0</span> <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">xr</span> <span class="nv">xn</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">yr</span> <span class="nv">yn</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">zr</span> <span class="nv">zn</span><span class="p">)))))</span>
</pre>
                                </div>
                              </div>
                              <p><strong>图 9.3 光线追踪。</strong></p>
                              <p>图像平面会是由 x 轴与 y 轴所定义的平面。观测者 (eye) 会在 z 轴，距离原点 200 个单位。所以要在图像平面可以被看到，插入至 <code
                                  class="docutils literal"><span class="pre">*worlds*</span></code> 的表面 (一开始为 <code
                                  class="docutils literal"><span class="pre">nil</span></code>)会有着负的 z 座标。图 9.4
                                说明了一个光线穿过图像平面上的一点，并击中一个球体。</p>
                              <div class="figure">
                                <img alt="_images/Figure-9.4.png" src="_images/Figure-9.4.png" />
                              </div>
                              <p><strong>图 9.4: 追踪光线。</strong></p>
                              <p>函数 <code class="docutils literal"><span class="pre">tracer</span></code>
                                接受一个路径名称，并写入一张图片至对应的文件。图片文件会用一种简单的 ASCII 称作 PGM 的格式写入。默认情况下，图像会是 100x100 。我们 PGM 文件的标头
                                (headers) 会由标签 <code class="docutils literal"><span class="pre">P2</span></code>
                                组成，伴随着指定图片宽度 (breadth)与高度 (height)的整数，初始为 100，单位为 pixel，以及可能的最大值 (255)。文件剩余的部份会由 10000
                                个介于 0 (黑)与 1 (白)整数组成，代表着 100 条 100 像素的水平线。</p>
                              <p>图片的解析度可以通过给入明确的 <code class="docutils literal"><span class="pre">res</span></code>
                                来调整。举例来说，如果 <code class="docutils literal"><span class="pre">res</span></code> 是 <code
                                  class="docutils literal"><span class="pre">2</span></code> ，则同样的图像会被渲染成 200x200 。</p>
                              <p>图片是一个在图像平面 100x100 的正方形。每一个像素代表着穿过图像平面抵达观测点的光的数量。要找到每个像素光的数量， <code
                                  class="docutils literal"><span class="pre">tracer</span></code> 调用 <code
                                  class="docutils literal"><span class="pre">color-at</span></code>
                                。这个函数找到从观测点至该点的向量，并调用 <code
                                  class="docutils literal"><span class="pre">sendray</span></code> 来追踪这个向量回到模拟世界的轨迹；
                                <code class="docutils literal"><span class="pre">sandray</span></code> 会返回一个数值介于 0 与 1
                                之间的亮度 (intensity)，之后会缩放成一个 0 至 255 的整数来显示。
                              </p>
                              <p>要决定一个光线的亮度， <code class="docutils literal"><span class="pre">sendray</span></code>
                                需要找到光是从哪个物体所反射的。要办到这件事，我们调用 <code
                                  class="docutils literal"><span class="pre">first-hit</span></code> ，此函数研究在 <code
                                  class="docutils literal"><span class="pre">*world*</span></code>
                                里的所有平面，并返回光线最先抵达的平面（如果有的话）。如果光没有击中任何东西， <code
                                  class="docutils literal"><span class="pre">sendray</span></code> 仅返回背景颜色，按惯例是 <code
                                  class="docutils literal"><span class="pre">0</span></code>
                                (黑色)。如果光线有击中某物的话，我们需要找出在光击中时，有多少数量的光照在该平面。</p>
                              <p><a class="reference external"
                                  href="http://zh.wikipedia.org/zh-tw/%E6%AF%94%E5%B0%94%EF%BC%8D%E6%9C%97%E4%BC%AF%E5%AE%9A%E5%BE%8B">朗伯定律</a>
                                告诉我们，由平面上一点所反射的光的强度，正比于该点的单位法向量 (unit normal vector) <em>N</em>
                                (这里是与平面垂直且长度为一的向量)与该点至光源的单位向量 <em>L</em> 的点积 (dot-product):</p>
                              <div class="math">
                                \[i = N·L\]</div>
                              <p>如果光刚好照到这点， <em>N</em> 与 <em>L</em> 会重合 (coincident)，则点积会是最大值， <code
                                  class="docutils literal"><span class="pre">1</span></code> 。如果将在这时候将平面朝光转 90 度，则
                                <em>N</em> 与 <em>L</em> 会垂直，则两者点积会是 <code
                                  class="docutils literal"><span class="pre">0</span></code> 。如果光在平面后面，则点积会是负数。
                              </p>
                              <p>在我们的程序里，我们假设光源在观测点 (eye)，所以 <code
                                  class="docutils literal"><span class="pre">lambert</span></code> 使用了这个规则来找到平面上某点的亮度
                                (illumination)，返回我们追踪的光的单位向量与法向量的点积。</p>
                              <p>在 <code class="docutils literal"><span class="pre">sendray</span></code> 这个值会乘上平面的颜色
                                (即便是有好的照明，一个暗的平面还是暗的)来决定该点之后总体亮度。</p>
                              <p>为了简单起见，我们在模拟世界里会只有一种物体，球体。图 9.5 包含了与球体有关的代码。球体结构包含了 <code
                                  class="docutils literal"><span class="pre">surface</span></code> ，所以一个球体会有一种颜色以及 <code
                                  class="docutils literal"><span class="pre">center</span></code> 和 <code
                                  class="docutils literal"><span class="pre">radius</span></code> 。调用 <code
                                  class="docutils literal"><span class="pre">defsphere</span></code> 添加一个新球体至世界里。</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defstruct</span> <span class="p">(</span><span class="nv">sphere</span> <span class="p">(</span><span class="ss">:include</span> <span class="nv">surface</span><span class="p">))</span>
  <span class="nv">radius</span> <span class="nv">center</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">defsphere</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> <span class="nv">r</span> <span class="nv">c</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">s</span> <span class="p">(</span><span class="nv">make-sphere</span>
             <span class="ss">:radius</span> <span class="nv">r</span>
             <span class="ss">:center</span> <span class="p">(</span><span class="nv">make-point</span> <span class="ss">:x</span> <span class="nv">x</span> <span class="ss">:y</span> <span class="nv">y</span> <span class="ss">:z</span> <span class="nv">z</span><span class="p">)</span>
             <span class="ss">:color</span>  <span class="nv">c</span><span class="p">)))</span>
    <span class="p">(</span><span class="nb">push</span> <span class="nv">s</span> <span class="vg">*world*</span><span class="p">)</span>
    <span class="nv">s</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">intersect</span> <span class="p">(</span><span class="nv">s</span> <span class="nv">pt</span> <span class="nv">xr</span> <span class="nv">yr</span> <span class="nv">zr</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">funcall</span> <span class="p">(</span><span class="nb">typecase</span> <span class="nv">s</span> <span class="p">(</span><span class="nv">sphere</span> <span class="nf">#&#39;</span><span class="nv">sphere-intersect</span><span class="p">))</span>
           <span class="nv">s</span> <span class="nv">pt</span> <span class="nv">xr</span> <span class="nv">yr</span> <span class="nv">zr</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">sphere-intersect</span> <span class="p">(</span><span class="nv">s</span> <span class="nv">pt</span> <span class="nv">xr</span> <span class="nv">yr</span> <span class="nv">zr</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let*</span> <span class="p">((</span><span class="nv">c</span> <span class="p">(</span><span class="nv">sphere-center</span> <span class="nv">s</span><span class="p">))</span>
         <span class="p">(</span><span class="nv">n</span> <span class="p">(</span><span class="nv">minroot</span> <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nv">sq</span> <span class="nv">xr</span><span class="p">)</span> <span class="p">(</span><span class="nv">sq</span> <span class="nv">yr</span><span class="p">)</span> <span class="p">(</span><span class="nv">sq</span> <span class="nv">zr</span><span class="p">))</span>
                     <span class="p">(</span><span class="nb">*</span> <span class="mi">2</span> <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nb">*</span> <span class="p">(</span><span class="nb">-</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">pt</span><span class="p">)</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">c</span><span class="p">))</span> <span class="nv">xr</span><span class="p">)</span>
                             <span class="p">(</span><span class="nb">*</span> <span class="p">(</span><span class="nb">-</span> <span class="p">(</span><span class="nv">y</span> <span class="nv">pt</span><span class="p">)</span> <span class="p">(</span><span class="nv">y</span> <span class="nv">c</span><span class="p">))</span> <span class="nv">yr</span><span class="p">)</span>
                             <span class="p">(</span><span class="nb">*</span> <span class="p">(</span><span class="nb">-</span> <span class="p">(</span><span class="nv">z</span> <span class="nv">pt</span><span class="p">)</span> <span class="p">(</span><span class="nv">z</span> <span class="nv">c</span><span class="p">))</span> <span class="nv">zr</span><span class="p">)))</span>
                     <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nv">sq</span> <span class="p">(</span><span class="nb">-</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">pt</span><span class="p">)</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">c</span><span class="p">)))</span>
                        <span class="p">(</span><span class="nv">sq</span> <span class="p">(</span><span class="nb">-</span> <span class="p">(</span><span class="nv">y</span> <span class="nv">pt</span><span class="p">)</span> <span class="p">(</span><span class="nv">y</span> <span class="nv">c</span><span class="p">)))</span>
                        <span class="p">(</span><span class="nv">sq</span> <span class="p">(</span><span class="nb">-</span> <span class="p">(</span><span class="nv">z</span> <span class="nv">pt</span><span class="p">)</span> <span class="p">(</span><span class="nv">z</span> <span class="nv">c</span><span class="p">)))</span>
                        <span class="p">(</span><span class="nb">-</span> <span class="p">(</span><span class="nv">sq</span> <span class="p">(</span><span class="nv">sphere-radius</span> <span class="nv">s</span><span class="p">)))))))</span>
    <span class="p">(</span><span class="k">if</span> <span class="nv">n</span>
        <span class="p">(</span><span class="nv">make-point</span> <span class="ss">:x</span>  <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">pt</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">n</span> <span class="nv">xr</span><span class="p">))</span>
                    <span class="ss">:y</span>  <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nv">y</span> <span class="nv">pt</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">n</span> <span class="nv">yr</span><span class="p">))</span>
                    <span class="ss">:z</span>  <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nv">z</span> <span class="nv">pt</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">n</span> <span class="nv">zr</span><span class="p">))))))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">normal</span> <span class="p">(</span><span class="nv">s</span> <span class="nv">pt</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">funcall</span> <span class="p">(</span><span class="nb">typecase</span> <span class="nv">s</span> <span class="p">(</span><span class="nv">sphere</span> <span class="nf">#&#39;</span><span class="nv">sphere-normal</span><span class="p">))</span>
           <span class="nv">s</span> <span class="nv">pt</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">sphere-normal</span> <span class="p">(</span><span class="nv">s</span> <span class="nv">pt</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">c</span> <span class="p">(</span><span class="nv">sphere-center</span> <span class="nv">s</span><span class="p">)))</span>
    <span class="p">(</span><span class="nv">unit-vector</span> <span class="p">(</span><span class="nb">-</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">c</span><span class="p">)</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">pt</span><span class="p">))</span>
                 <span class="p">(</span><span class="nb">-</span> <span class="p">(</span><span class="nv">y</span> <span class="nv">c</span><span class="p">)</span> <span class="p">(</span><span class="nv">y</span> <span class="nv">pt</span><span class="p">))</span>
                 <span class="p">(</span><span class="nb">-</span> <span class="p">(</span><span class="nv">z</span> <span class="nv">c</span><span class="p">)</span> <span class="p">(</span><span class="nv">z</span> <span class="nv">pt</span><span class="p">)))))</span>
</pre>
                                </div>
                              </div>
                              <p><strong>图 9.5 球体。</strong></p>
                              <p>函数 <code class="docutils literal"><span class="pre">intersect</span></code>
                                判断与何种平面有关，并调用对应的函数。在此时只有一种， <code
                                  class="docutils literal"><span class="pre">sphere-intersect</span></code> ，但 <code
                                  class="docutils literal"><span class="pre">intersect</span></code> 是写成可以容易扩展处理别种物体。
                              </p>
                              <p>我们要怎么找到一束光与一个球体的交点 (intersection)呢？光线是表示成点 <span class="math">\(p
                                  =〈x_0,y_0,x_0〉\)</span> 以及单位向量 <span class="math">\(v =〈x_r,y_r,x_r〉\)</span>
                                。每个在光上的点可以表示为 <span class="math">\(p+nv\)</span> ，对于某个 <em>n</em> ── 即 <span
                                  class="math">\(〈x_0+nx_r,y_0+ny_r,z_0+nz_r〉\)</span> 。光击中球体的点的距离至中心 <span
                                  class="math">\(〈x_c,y_c,z_c〉\)</span> 会等于球体的半径 <em>r</em> 。所以在下列这个交点的方程序会成立:</p>
                              <div class="math">
                                \[r = \sqrt{ (x_0 + nx_r - x_c)^2 + (y_0 + ny_r - y_c)^2 + (z_0 + nz_r - z_c)^2 }\]
                              </div>
                              <p>这会给出</p>
                              <div class="math">
                                \[an^2 + bn + c = 0\]</div>
                              <p>其中</p>
                              <div class="math">
                                \[\begin{split}a = x_r^2 + y_r^2 + z_r^2\\b = 2((x_0-x_c)x_r + (y_0-y_c)y_r +
                                (z_0-z_c)z_r)\\c = (x_0-x_c)^2 + (y_0-y_c)^2 + (z_0-z_c)^2 - r^2\end{split}\]</div>
                              <p>要找到交点我们只需要找到这个二次方程序的根。它可能是零、一个或两个实数根。没有根代表光没有击中球体；一个根代表光与球体交于一点 (擦过 「grazing
                                hit」)；两个根代表光与球体交于两点 (一点交于进入时、一点交于离开时)。在最后一个情况里，我们想要两个根之中较小的那个； <em>n</em>
                                与光离开观测点的距离成正比，所以先击中的会是较小的 <em>n</em> 。所以我们调用 <code
                                  class="docutils literal"><span class="pre">minroot</span></code> 。如果有一个根， <code
                                  class="docutils literal"><span class="pre">sphere-intersect</span></code> 返回代表该点的
                                <span class="math">\(〈x_0+nx_r,y_0+ny_r,z_0+nz_r〉\)</span> 。
                              </p>
                              <p>图 9.5 的另外两个函数， <code class="docutils literal"><span class="pre">normal</span></code> 与
                                <code class="docutils literal"><span class="pre">sphere-normal</span></code> 类比于 <code
                                  class="docutils literal"><span class="pre">intersect</span></code> 与 <code
                                  class="docutils literal"><span class="pre">sphere-intersect</span></code> 。要找到垂直于球体很简单
                                ── 不过是从该点至球体中心的向量而已。
                              </p>
                              <p>图 9.6 示范了我们如何产生图片； <code
                                  class="docutils literal"><span class="pre">ray-test</span></code> 定义了 38
                                个球体（不全都看的见）然后产生一张图片，叫做 &#8220;sphere.pgm&#8221; 。</p>
                              <p>(译注：PGM 可移植灰度图格式，更多信息参见 <a class="reference external"
                                  href="http://en.wikipedia.org/wiki/Portable_graymap">wiki</a> )</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">ray-test</span> <span class="p">(</span><span class="k">&amp;optional</span> <span class="p">(</span><span class="nv">res</span> <span class="mi">1</span><span class="p">))</span>
  <span class="p">(</span><span class="nb">setf</span> <span class="vg">*world*</span> <span class="no">nil</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">defsphere</span> <span class="mi">0</span> <span class="mi">-300</span> <span class="mi">-1200</span> <span class="mi">200</span> <span class="mf">.8</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">defsphere</span> <span class="mi">-80</span> <span class="mi">-150</span> <span class="mi">-1200</span> <span class="mi">200</span> <span class="mf">.7</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">defsphere</span> <span class="mi">70</span> <span class="mi">-100</span> <span class="mi">-1200</span> <span class="mi">200</span> <span class="mf">.9</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">do</span> <span class="p">((</span><span class="nv">x</span> <span class="mi">-2</span> <span class="p">(</span><span class="nb">1+</span> <span class="nv">x</span><span class="p">)))</span>
      <span class="p">((</span><span class="nb">&gt;</span> <span class="nv">x</span> <span class="mi">2</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">do</span> <span class="p">((</span><span class="nv">z</span> <span class="mi">2</span> <span class="p">(</span><span class="nb">1+</span> <span class="nv">z</span><span class="p">)))</span>
        <span class="p">((</span><span class="nb">&gt;</span> <span class="nv">z</span> <span class="mi">7</span><span class="p">))</span>
      <span class="p">(</span><span class="nv">defsphere</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">x</span> <span class="mi">200</span><span class="p">)</span> <span class="mi">300</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">z</span> <span class="mi">-400</span><span class="p">)</span> <span class="mi">40</span> <span class="mf">.75</span><span class="p">)))</span>
  <span class="p">(</span><span class="nv">tracer</span> <span class="p">(</span><span class="nb">make-pathname</span> <span class="ss">:name</span> <span class="s">&quot;spheres.pgm&quot;</span><span class="p">)</span> <span class="nv">res</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p><strong>图 9.6 使用光线追踪器</strong></p>
                              <p>图 9.7 是产生出来的图片，其中 <code class="docutils literal"><span class="pre">res</span></code>
                                参数为 10。</p>
                              <div class="figure">
                                <img alt="_images/Figure-9.7.png" src="_images/Figure-9.7.png" />
                              </div>
                              <p><strong>图 9.7: 追踪光线的图</strong></p>
                              <p>
                                一个实际的光线追踪器可以产生更复杂的图片，因为它会考虑更多，我们只考虑了单一光源至平面某一点。可能会有多个光源，每一个有不同的强度。它们通常不会在观测点，在这个情况程序需要检查至光源的向量是否与其他平面相交，这会在第一个相交的平面上产生阴影。将光源放置于观测点让我们不需要考虑这麽复杂的情况，因为我们看不见在阴影中的任何点。
                              </p>
                              <p>一个实际的光线追踪器不仅追踪光第一个击中的平面，也会加入其它平面的反射光。一个实际的光线追踪器会是有颜色的，并可以模型化出透明或是闪耀的平面。但基本的算法会与图 9.3
                                所演示的差不多，而许多改进只需要递回的使用同样的成分。</p>
                              <p>一个实际的光线追踪器可以是高度优化的。这里给出的程序为了精简写成，甚至没有如 Lisp 程序员会最佳化的那样，就仅是一个光线追踪器而已。仅加入类型与行内宣告 (13.3
                                节)就可以让它变得两倍以上快。</p>
                            </div>
                            <div class="section" id="chapter-9-summary">
                              <h4>Chapter 9 总结 (Summary)<a class="headerlink" href="#chapter-9-summary"
                                  title="Permalink to this headline">¶</a></h4>
                              <ol class="arabic simple">
                                <li>Common Lisp 提供整数 (integers)、比值 (ratios)、浮点数 (floating-point numbers)以及复数 (complex
                                  numbers)。</li>
                                <li>数字可以被约分或转换 (converted)，而它们的位数 (components)可以被取出。</li>
                                <li>用来比较数字的谓词可以接受任意数量的参数，以及比较下一数对 (successive pairs) ── <cite>/=</cite> 函数除外，它是用来比较所有的数对
                                  (pairs)。</li>
                                <li>Common Lisp 几乎提供你在低阶科学计算机可以看到的数值函数。同样的函数普遍可应用在多种类型的数字上。</li>
                                <li>Fixnum 是小至可以塞入一个字 (word)的整数。它们在必要时会悄悄但花费昂贵地转成大数 (bignum)。Common Lisp
                                  提供最多四种浮点数。每一个浮点表示法的限制是实现相关的 (implementation-dependent)常量。</li>
                                <li>一个光线追踪器 (ray-tracer)通过追踪光线来产生图像，使得每一像素回到模拟的世界。</li>
                              </ol>
                            </div>
                            <div class="section" id="chapter-9-exercises">
                              <h4>Chapter 9 练习 (Exercises)<a class="headerlink" href="#chapter-9-exercises"
                                  title="Permalink to this headline">¶</a></h4>
                              <ol class="arabic simple">
                                <li>定义一个函数，接受一个实数列表，若且唯若 (iff)它们是非递减 (nondecreasing)顺序时返回真。</li>
                                <li>定义一个函数，接受一个整数 <code class="docutils literal"><span class="pre">cents</span></code>
                                  并返回四个值，将数字用 <code class="docutils literal"><span class="pre">25-</span></code> , <code
                                    class="docutils literal"><span class="pre">10-</span></code> , <code
                                    class="docutils literal"><span class="pre">5-</span></code> , <code
                                    class="docutils literal"><span class="pre">1-</span></code> 来显示，使用最少数量的硬币。(译注: <code
                                    class="docutils literal"><span class="pre">25-</span></code> 是 25 美分，以此类推)</li>
                                <li>一个遥远的星球住着两种生物， wigglies 与 wobblies 。 Wigglies 与 wobblies
                                  唱歌一样厉害。每年都有一个比赛来选出十大最佳歌手。下面是过去十年的结果:</li>
                              </ol>
                              <table border="1" class="docutils">
                                <colgroup>
                                  <col width="24%" />
                                  <col width="7%" />
                                  <col width="7%" />
                                  <col width="7%" />
                                  <col width="7%" />
                                  <col width="7%" />
                                  <col width="7%" />
                                  <col width="7%" />
                                  <col width="7%" />
                                  <col width="7%" />
                                  <col width="10%" />
                                </colgroup>
                                <thead valign="bottom">
                                  <tr class="row-odd">
                                    <th class="head">YEAR</th>
                                    <th class="head">1</th>
                                    <th class="head">2</th>
                                    <th class="head">3</th>
                                    <th class="head">4</th>
                                    <th class="head">5</th>
                                    <th class="head">6</th>
                                    <th class="head">7</th>
                                    <th class="head">8</th>
                                    <th class="head">9</th>
                                    <th class="head">10</th>
                                  </tr>
                                </thead>
                                <tbody valign="top">
                                  <tr class="row-even">
                                    <td>WIGGLIES</td>
                                    <td>6</td>
                                    <td>5</td>
                                    <td>6</td>
                                    <td>4</td>
                                    <td>5</td>
                                    <td>5</td>
                                    <td>4</td>
                                    <td>5</td>
                                    <td>6</td>
                                    <td>5</td>
                                  </tr>
                                  <tr class="row-odd">
                                    <td>WOBBLIES</td>
                                    <td>4</td>
                                    <td>5</td>
                                    <td>4</td>
                                    <td>6</td>
                                    <td>5</td>
                                    <td>5</td>
                                    <td>6</td>
                                    <td>5</td>
                                    <td>4</td>
                                    <td>5</td>
                                  </tr>
                                </tbody>
                              </table>
                              <p>写一个程序来模拟这样的比赛。你的结果实际上有建议委员会每年选出 10 个最佳歌手吗？</p>
                              <ol class="arabic simple" start="4">
                                <li>定义一个函数，接受 8 个表示二维空间中两个线段端点的实数，若线段没有相交，则返回假，或返回两个值表示相交点的 <code
                                    class="docutils literal"><span class="pre">x</span></code> 座标与 <code
                                    class="docutils literal"><span class="pre">y</span></code> 座标。</li>
                                <li>假设 <code class="docutils literal"><span class="pre">f</span></code> 是一个接受一个 (实数)
                                  参数的函数，而 <code class="docutils literal"><span class="pre">min</span></code> 与 <code
                                    class="docutils literal"><span class="pre">max</span></code> 是有着不同正负号的非零实数，使得 <code
                                    class="docutils literal"><span class="pre">f</span></code> 对于参数 <code
                                    class="docutils literal"><span class="pre">i</span></code> 有一个根 (返回零)并满足 <code
                                    class="docutils literal"><span class="pre">min</span> <span class="pre">&lt;</span> <span class="pre">i</span> <span class="pre">&lt;</span> <span class="pre">max</span></code>
                                  。定义一个函数，接受四个参数， <code class="docutils literal"><span class="pre">f</span></code> ,
                                  <code class="docutils literal"><span class="pre">min</span></code> , <code
                                    class="docutils literal"><span class="pre">max</span></code> 以及 <code
                                    class="docutils literal"><span class="pre">epsilon</span></code> ，并返回一个 <code
                                    class="docutils literal"><span class="pre">i</span></code> 的近似值，准确至正负 <code
                                    class="docutils literal"><span class="pre">epsilon</span></code> 之内。
                                </li>
                                <li><em>Honer&#8217;s method</em> 是一个有效率求出多项式的技巧。要找到 <span
                                    class="math">\(ax^3+bx^2+cx+d\)</span> 你对 <code
                                    class="docutils literal"><span class="pre">x(x(ax+b)+c)+d</span></code>
                                  求值。定义一个函数，接受一个或多个参数 ── x 的值伴随着 <em>n</em> 个实数，用来表示 <code
                                    class="docutils literal"><span class="pre">(n-1)</span></code> 次方的多项式的系数 ── 并用
                                  <em>Honer&#8217;s method</em> 计算出多项式的值。
                                </li>
                              </ol>
                              <p>译注: <a class="reference external"
                                  href="http://en.wikipedia.org/wiki/Horner's_method">Honer&#8217;s method on wiki</a>
                              </p>
                              <ol class="arabic simple" start="7">
                                <li>你的 Common Lisp 实现使用了几个位元来表示定长数？</li>
                                <li>你的 Common Lisp 实现提供几种不同的浮点数？</li>
                              </ol>
                              <p class="rubric">脚注</p>
                              <table class="docutils footnote" frame="void" id="id5" rules="none">
                                <colgroup>
                                  <col class="label" />
                                  <col />
                                </colgroup>
                                <tbody valign="top">
                                  <tr>
                                    <td class="label"><a class="fn-backref" href="#id2">[1]</a></td>
                                    <td>当 <code class="docutils literal"><span class="pre">format</span></code>
                                      取整显示时，它不保证会取成偶数或奇数。见 125 页 (译注: 7.4 节)。</td>
                                  </tr>
                                </tbody>
                              </table>
                            </div>
                          </div>
                          <div class="section">
                            <h3 id="10">第十章：宏</h3>
                            <p>Lisp 代码是由 Lisp 对象的列表来表示。2.3 节宣称这让 Lisp 可以写出<strong>可自己写程序的程序</strong>。本章将示范如何跨越表达式与代码的界线。
                            </p>
                            <div class="section" id="eval">
                              <h4>10.1 求值 (Eval)<a class="headerlink" href="#eval"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>如何产生表达式是很直观的：调用 <code class="docutils literal"><span class="pre">list</span></code>
                                即可。我们没有考虑到的是，如何使 Lisp 将列表视为代码。这之间缺少的一环是函数 <code
                                  class="docutils literal"><span class="pre">eval</span></code> ，它接受一个表达式，将其求值，然后返回它的值:
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">eval</span> <span class="o">&#39;</span><span class="p">(</span><span class="nb">+</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">))</span>
<span class="mi">6</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="nb">eval</span> <span class="o">&#39;</span><span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;Hello&quot;</span><span class="p">))</span>
<span class="nv">Hello</span>
<span class="no">NIL</span>
</pre>
                                </div>
                              </div>
                              <p>如果这看起很熟悉的话，这是应该的。这就是我们一直交谈的那个 <code
                                  class="docutils literal"><span class="pre">eval</span></code> 。下面这个函数实现了与顶层非常相似的东西:
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">our-toplevel</span> <span class="p">()</span>
  <span class="p">(</span><span class="nb">do</span> <span class="p">()</span>
      <span class="p">(</span><span class="no">nil</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;~%&gt; &quot;</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">print</span> <span class="p">(</span><span class="nb">eval</span> <span class="p">(</span><span class="nb">read</span><span class="p">)))))</span>
</pre>
                                </div>
                              </div>
                              <p>也是因为这个原因，顶层也称为<strong>读取─求值─打印循环</strong> (read-eval-print loop, REPL)。</p>
                              <p>调用 <code class="docutils literal"><span class="pre">eval</span></code>
                                是跨越代码与列表界线的一种方法。但它不是一个好方法:</p>
                              <ol class="arabic simple">
                                <li>它的效率低下： <code class="docutils literal"><span class="pre">eval</span></code> 处理的是原始列表
                                  (raw list)，或者当下编译它，或者用直译器求值。两种方法都比执行编译过的代码来得慢许多。</li>
                                <li>表达式在没有词法语境 (lexical context)的情况下被求值。举例来说，如果你在一个 <code
                                    class="docutils literal"><span class="pre">let</span></code> 里调用 <code
                                    class="docutils literal"><span class="pre">eval</span></code> ，传给 <code
                                    class="docutils literal"><span class="pre">eval</span></code> 的表达式将无法引用由 <code
                                    class="docutils literal"><span class="pre">let</span></code> 所设置的变量。</li>
                              </ol>
                              <p>有许多更好的方法 (下一节叙述)来利用产生代码的这个可能性。当然 <code
                                  class="docutils literal"><span class="pre">eval</span></code> 也是有用的，唯一合法的用途像是在顶层循环使用它。
                              </p>
                              <p>对于程序员来说， <code class="docutils literal"><span class="pre">eval</span></code> 的主要价值大概是作为
                                Lisp 的概念模型。我们可以想像 Lisp 是由一个长的 <code
                                  class="docutils literal"><span class="pre">cond</span></code> 表达式定义而成:</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nb">eval</span> <span class="p">(</span><span class="nv">expr</span> <span class="nv">env</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">cond</span> <span class="o">...</span>
        <span class="p">((</span><span class="nb">eql</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">expr</span><span class="p">)</span> <span class="ss">&#39;quote</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">expr</span><span class="p">))</span>
        <span class="o">...</span>
        <span class="p">(</span><span class="no">t</span> <span class="p">(</span><span class="nb">apply</span> <span class="p">(</span><span class="nb">symbol-function</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">expr</span><span class="p">))</span>
                  <span class="p">(</span><span class="nb">mapcar</span> <span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span>
                              <span class="p">(</span><span class="nb">eval</span> <span class="nv">x</span> <span class="nv">env</span><span class="p">))</span>
                          <span class="p">(</span><span class="nb">cdr</span> <span class="nv">expr</span><span class="p">))))))</span>
</pre>
                                </div>
                              </div>
                              <p>许多表达式由预设子句 (default clause)来处理，预设子句获得 <code
                                  class="docutils literal"><span class="pre">car</span></code> 所引用的函数，将 <code
                                  class="docutils literal"><span class="pre">cdr</span></code> 所有的参数求值，并返回将前者应用至后者的结果。
                                <a class="footnote-reference" href="#id5" id="id2">[1]</a>
                              </p>
                              <p>但是像 <code
                                  class="docutils literal"><span class="pre">(quote</span> <span class="pre">x)</span></code>
                                那样的句子就不能用这样的方式来处理，因为 <code
                                  class="docutils literal"><span class="pre">quote</span></code>
                                就是为了防止它的参数被求值而存在的。所以我们需要给 <code
                                  class="docutils literal"><span class="pre">quote</span></code>
                                写一个特别的子句。这也是为什么本质上将其称为特殊操作符 (special operator): 一个需要被实现为 <code
                                  class="docutils literal"><span class="pre">eval</span></code> 的一个特殊情况的操作符。</p>
                              <p>函数 <code class="docutils literal"><span class="pre">coerce</span></code> 与 <code
                                  class="docutils literal"><span class="pre">compile</span></code>
                                提供了一个类似的桥梁，让你把列表转成代码。你可以 <code
                                  class="docutils literal"><span class="pre">coerce</span></code> 一个 lambda 表达式，使其成为函数，
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre>&gt; (coerce &#39;(lambda (x) x) &#39;function)
#&lt;Interpreted-Function BF9D96&gt;
</pre>
                                </div>
                              </div>
                              <p>而如果你将 <code class="docutils literal"><span class="pre">nil</span></code> 作为第一个参数传给
                                <code class="docutils literal"><span class="pre">compile</span></code> ，它会编译作为第二个参数传入的
                                lambda 表达式。
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre>&gt; (compile nil &#39;(lambda (x) (+ x 2)))
#&lt;Compiled-Function BF55BE&gt;
NIL
NIL
</pre>
                                </div>
                              </div>
                              <p>由于 <code class="docutils literal"><span class="pre">coerce</span></code> 与 <code
                                  class="docutils literal"><span class="pre">compile</span></code>
                                可接受列表作为参数，一个程序可以在动态执行时 (on the fly)构造新函数。但与调用 <code
                                  class="docutils literal"><span class="pre">eval</span></code>
                                比起来，这不是一个从根本解决的办法，并且需抱有同样的疑虑来检视这两个函数。</p>
                              <p>函数 <code class="docutils literal"><span class="pre">eval</span></code> , <code
                                  class="docutils literal"><span class="pre">coerce</span></code> 与 <code
                                  class="docutils literal"><span class="pre">compile</span></code>
                                的麻烦不是它们跨越了代码与列表之间的界线，而是它们在执行期做这件事。跨越界线的代价昂贵。大多数情况下，在编译期做这件事是没问题的，当你的程序执行时，几乎不用成本。下一节会示范如何办到这件事。
                              </p>
                            </div>
                            <div class="section" id="macros">
                              <h4>10.2 宏 (Macros)<a class="headerlink" href="#macros"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>写出能写程序的程序的最普遍方法是通过定义宏。<em>宏</em>是通过转换
                                (transformation)而实现的操作符。你通过说明你一个调用应该要翻译成什么，来定义一个宏。这个翻译称为宏展开(macro-expansion)，宏展开由编译器自动完成。所以宏所产生的代码，会变成程序的一个部分，就像你自己输入的程序一样。
                              </p>
                              <p>宏通常通过调用 <code class="docutils literal"><span class="pre">defmacro</span></code> 来定义。一个
                                <code class="docutils literal"><span class="pre">defmacro</span></code> 看起来很像 <code
                                  class="docutils literal"><span class="pre">defun</span></code>
                                。但是与其定义一个函数调用应该产生的值，它定义了该怎么翻译出一个函数调用。举例来说，一个将其参数设为 <code
                                  class="docutils literal"><span class="pre">nil</span></code> 的宏可以定义成如下:
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defmacro</span> <span class="nv">nil!</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">list</span> <span class="ss">&#39;setf</span> <span class="nv">x</span> <span class="no">nil</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p>这定义了一个新的操作符，称为 <code class="docutils literal"><span class="pre">nil!</span></code>
                                ，它接受一个参数。一个这样形式 <code
                                  class="docutils literal"><span class="pre">(nil!</span> <span class="pre">a)</span></code>
                                的调用，会在求值或编译前，被翻译成 <code
                                  class="docutils literal"><span class="pre">(setf</span> <span class="pre">a</span> <span class="pre">nil)</span></code>
                                。所以如果我们输入 <code
                                  class="docutils literal"><span class="pre">(nil!</span> <span class="pre">x)</span></code>
                                至顶层，</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">nil!</span> <span class="nv">x</span><span class="p">)</span>
<span class="no">NIL</span>
<span class="nb">&gt;</span> <span class="nv">x</span>
<span class="no">NIL</span>
</pre>
                                </div>
                              </div>
                              <p>完全等同于输入表达式 <code
                                  class="docutils literal"><span class="pre">(setf</span> <span class="pre">x</span> <span class="pre">nil)</span></code>
                                。</p>
                              <p>要测试一个函数，我们调用它，但要测试一个宏，我们看它的展开式 (expansion)。</p>
                              <p>函数 <code class="docutils literal"><span class="pre">macroexpand-1</span></code>
                                接受一个宏调用，并产生它的展开式:</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">macroexpand-1</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">nil!</span> <span class="nv">x</span><span class="p">))</span>
<span class="p">(</span><span class="nv">SETF</span> <span class="nv">X</span> <span class="no">NIL</span><span class="p">)</span>
<span class="no">T</span>
</pre>
                                </div>
                              </div>
                              <p>一个宏调用可以展开成另一个宏调用。当编译器（或顶层）遇到一个宏调用时，它持续展开它，直到不可展开为止。</p>
                              <p>理解宏的秘密是理解它们是如何被实现的。在台面底下，它们只是转换成表达式的函数。举例来说，如果你传入这个形式 <code
                                  class="docutils literal"><span class="pre">(nil!</span> <span class="pre">a)</span></code>
                                的表达式给这个函数</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">expr</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">apply</span> <span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">list</span> <span class="ss">&#39;setf</span> <span class="nv">x</span> <span class="no">nil</span><span class="p">))</span>
         <span class="p">(</span><span class="nb">cdr</span> <span class="nv">expr</span><span class="p">)))</span>
</pre>
                                </div>
                              </div>
                              <p>它会返回 <code
                                  class="docutils literal"><span class="pre">(setf</span> <span class="pre">a</span> <span class="pre">nil)</span></code>
                                。当你使用 <code class="docutils literal"><span class="pre">defmacro</span></code>
                                ，你定义一个类似这样的函数。 <code
                                  class="docutils literal"><span class="pre">macroexpand-1</span></code>
                                全部所做的事情是，当它看到一个表达式的 <code class="docutils literal"><span class="pre">car</span></code>
                                是宏时，将表达式传给对应的函数。</p>
                            </div>
                            <div class="section" id="backquote">
                              <h4>10.3 反引号 (Backquote)<a class="headerlink" href="#backquote"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>反引号读取宏 (read-macro)使得从模版 (templates)建构列表变得有可能。反引号广泛使用在宏定义中。一个平常的引用是键盘上的右引号
                                (apostrophe)，然而一个反引号是一个左引号。(译注: open quote 左引号，closed quote 右引号)。它称作“反引号”是因为它看起来像是反过来的引号
                                (titled backwards)。</p>
                              <p>(译注: 反引号是键盘左上方数字 1 左边那个: <code
                                  class="docutils literal"><span class="pre">`</span></code> ，而引号是 enter 左边那个 <code
                                  class="docutils literal"><span class="pre">'</span></code>)</p>
                              <p>一个反引号单独使用时，等于普通的引号:</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="o">`</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">)</span>
<span class="p">(</span><span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>和普通引号一样，单一个反引号保护其参数被求值。</p>
                              <p>反引号的优点是，在一个反引号表达式里，你可以使用 <code
                                  class="docutils literal"><span class="pre">,</span></code> （逗号）与 <code
                                  class="docutils literal"><span class="pre">,&#64;</span></code>
                                （comma-at）来重启求值。如果你在反引号表达式里，在某个东西前面加逗号，则它会被求值。所以我们可以使用反引号与逗号来建构列表模版:</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">setf</span> <span class="nv">a</span> <span class="mi">1</span> <span class="nv">b</span> <span class="mi">2</span><span class="p">)</span>
<span class="mi">2</span>
<span class="nb">&gt;</span> <span class="o">`</span><span class="p">(</span><span class="nv">a</span> <span class="nv">is</span> <span class="o">,</span><span class="nv">a</span> <span class="nb">and</span> <span class="nv">b</span> <span class="nv">is</span> <span class="o">,</span><span class="nv">b</span><span class="p">)</span>
<span class="p">(</span><span class="nv">A</span> <span class="nv">IS</span> <span class="mi">1</span> <span class="nv">AND</span> <span class="nv">B</span> <span class="nv">IS</span> <span class="mi">2</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>通过使用反引号取代调用 <code class="docutils literal"><span class="pre">list</span></code>
                                ，我们可以写出会产生出展开式的宏。举例来说 <code
                                  class="docutils literal"><span class="pre">nil!</span></code> 可以定义为:</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defmacro</span> <span class="nv">nil!</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span>
  <span class="o">`</span><span class="p">(</span><span class="nb">setf</span> <span class="o">,</span><span class="nv">x</span> <span class="no">nil</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p><code class="docutils literal"><span class="pre">,&#64;</span></code>
                                与逗号相似，但将（本来应该是列表的）参数扒开。将列表的元素插入模版来取代列表。</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">setf</span> <span class="nv">lst</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">))</span>
<span class="p">(</span><span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span><span class="p">)</span>
<span class="nb">&gt;</span> <span class="o">`</span><span class="p">(</span><span class="nv">lst</span> <span class="nv">is</span> <span class="o">,</span><span class="nv">lst</span><span class="p">)</span>
<span class="p">(</span><span class="nv">LST</span> <span class="nv">IS</span> <span class="p">(</span><span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span><span class="p">))</span>
<span class="nb">&gt;</span> <span class="o">`</span><span class="p">(</span><span class="nv">its</span> <span class="nv">elements</span> <span class="nv">are</span> <span class="o">,@</span><span class="nv">lst</span><span class="p">)</span>
<span class="p">(</span><span class="nv">ITS</span> <span class="nv">ELEMENTS</span> <span class="nv">ARE</span> <span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p><code class="docutils literal"><span class="pre">,&#64;</span></code>
                                在宏里很有用，举例来说，在用剩余参数表示代码主体的宏。假设我们想要一个 <code
                                  class="docutils literal"><span class="pre">while</span></code> 宏，只要初始测试表达式为真，对其主体求值:
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">x</span> <span class="mi">0</span><span class="p">))</span>
    <span class="p">(</span><span class="nv">while</span> <span class="p">(</span><span class="nb">&lt;</span> <span class="nv">x</span> <span class="mi">10</span><span class="p">)</span>
       <span class="p">(</span><span class="nb">princ</span> <span class="nv">x</span><span class="p">)</span>
       <span class="p">(</span><span class="nb">incf</span> <span class="nv">x</span><span class="p">)))</span>
<span class="mi">0123456789</span>
<span class="no">NIL</span>
</pre>
                                </div>
                              </div>
                              <p>我们可以通过使用一个剩余参数 (rest parameter) ，搜集主体的表达式列表，来定义一个这样的宏，接着使用 comma-at 来扒开这个列表放至展开式里:</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defmacro</span> <span class="nv">while</span> <span class="p">(</span><span class="nv">test</span> <span class="k">&amp;rest</span> <span class="nv">body</span><span class="p">)</span>
  <span class="o">`</span><span class="p">(</span><span class="nb">do</span> <span class="p">()</span>
       <span class="p">((</span><span class="nb">not</span> <span class="o">,</span><span class="nv">test</span><span class="p">))</span>
     <span class="o">,@</span><span class="nv">body</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                            </div>
                            <div class="section" id="example-quicksort">
                              <h4>10.4 示例：快速排序法(Example: Quicksort)<a class="headerlink" href="#example-quicksort"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>图 10.1 包含了重度依赖宏的一个示例函数 ── 一个使用快速排序演算法 <a class="reference external"
                                  href="http://acl.readthedocs.org/en/latest/zhCN/notes-cn.html#notes-164">λ</a>
                                来排序向量的函数。这个函数的工作方式如下:</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">quicksort</span> <span class="p">(</span><span class="nv">vec</span> <span class="nv">l</span> <span class="nv">r</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">i</span> <span class="nv">l</span><span class="p">)</span>
        <span class="p">(</span><span class="nv">j</span> <span class="nv">r</span><span class="p">)</span>
        <span class="p">(</span><span class="nv">p</span> <span class="p">(</span><span class="nb">svref</span> <span class="nv">vec</span> <span class="p">(</span><span class="nb">round</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">l</span> <span class="nv">r</span><span class="p">)</span> <span class="mi">2</span><span class="p">))))</span>    <span class="c1">; 1</span>
    <span class="p">(</span><span class="nv">while</span> <span class="p">(</span><span class="nb">&lt;=</span> <span class="nv">i</span> <span class="nv">j</span><span class="p">)</span>                           <span class="c1">; 2</span>
      <span class="p">(</span><span class="nv">while</span> <span class="p">(</span><span class="nb">&lt;</span> <span class="p">(</span><span class="nb">svref</span> <span class="nv">vec</span> <span class="nv">i</span><span class="p">)</span> <span class="nv">p</span><span class="p">)</span> <span class="p">(</span><span class="nb">incf</span> <span class="nv">i</span><span class="p">))</span>
      <span class="p">(</span><span class="nv">while</span> <span class="p">(</span><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">svref</span> <span class="nv">vec</span> <span class="nv">j</span><span class="p">)</span> <span class="nv">p</span><span class="p">)</span> <span class="p">(</span><span class="nb">decf</span> <span class="nv">j</span><span class="p">))</span>
      <span class="p">(</span><span class="nb">when</span> <span class="p">(</span><span class="nb">&lt;=</span> <span class="nv">i</span> <span class="nv">j</span><span class="p">)</span>
        <span class="p">(</span><span class="nb">rotatef</span> <span class="p">(</span><span class="nb">svref</span> <span class="nv">vec</span> <span class="nv">i</span><span class="p">)</span> <span class="p">(</span><span class="nb">svref</span> <span class="nv">vec</span> <span class="nv">j</span><span class="p">))</span>
        <span class="p">(</span><span class="nb">incf</span> <span class="nv">i</span><span class="p">)</span>
        <span class="p">(</span><span class="nb">decf</span> <span class="nv">j</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">&gt;=</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">j</span> <span class="nv">l</span><span class="p">)</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nv">quicksort</span> <span class="nv">vec</span> <span class="nv">l</span> <span class="nv">j</span><span class="p">))</span>    <span class="c1">; 3</span>
    <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">&gt;=</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">r</span> <span class="nv">i</span><span class="p">)</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nv">quicksort</span> <span class="nv">vec</span> <span class="nv">i</span> <span class="nv">r</span><span class="p">)))</span>
  <span class="nv">vec</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p><strong>图 10.1 快速排序。</strong></p>
                              <ol class="arabic simple">
                                <li>开始你通过选择某个元素作为主键（ <em>pivot</em> ）。许多实现选择要被排序的序列中间元素。</li>
                                <li>接着你分割（partition）向量，持续交换元素，直到所有主键左边的元素小于主键，右边的元素大于主键。</li>
                                <li>最后，如果左右分割之一有两个或更多元素时，你递归地应用这个算法至向量的那些分割上。</li>
                              </ol>
                              <p>每一次递归时，分割越变越小，直到向量完整排序为止。</p>
                              <p>在图 10.1 的实现里，接受一个向量以及标记欲排序范围的两个整数。这个范围当下的中间元素被选为主键 ( <code
                                  class="docutils literal"><span class="pre">p</span></code>
                                )。接着从左右两端开始产生分割，并将左边太大或右边太小的元素交换过来。(将两个参数传给 <code
                                  class="docutils literal"><span class="pre">rotatef</span></code>
                                函数，交换它们的值。)最后，如果一个分割含有多个元素时，用同样的流程来排序它们。</p>
                              <p>除了我们前一节定义的 <code class="docutils literal"><span class="pre">while</span></code> 宏之外，图
                                10.1 也用了内置的 <code class="docutils literal"><span class="pre">when</span></code> , <code
                                  class="docutils literal"><span class="pre">incf</span></code> , <code
                                  class="docutils literal"><span class="pre">decf</span></code> 以及 <code
                                  class="docutils literal"><span class="pre">rotatef</span></code> 宏。使用这些宏使程序看起来更加简洁与清晰。
                              </p>
                            </div>
                            <div class="section" id="macro-design">
                              <h4>10.5 设计宏 (Macro Design)<a class="headerlink" href="#macro-design"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>撰写宏是一种独特的程序设计，它有着独一无二的目标与问题。能够改变编译器所看到的东西，就像是能够重写它一样。所以当你开始撰写宏时，你需要像语言设计者一样思考。</p>
                              <p>本节快速给出宏所牵涉问题的概要，以及解决它们的技巧。作为一个例子，我们会定义一个称为 <code
                                  class="docutils literal"><span class="pre">ntimes</span></code> 的宏，它接受一个数字 <em>n</em>
                                并对其主体求值 <em>n</em> 次。</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">ntimes</span> <span class="mi">10</span>
    <span class="p">(</span><span class="nb">princ</span> <span class="s">&quot;.&quot;</span><span class="p">))</span>
<span class="o">..........</span>
<span class="no">NIL</span>
</pre>
                                </div>
                              </div>
                              <p>下面是一个不正确的 <code class="docutils literal"><span class="pre">ntimes</span></code>
                                定义，说明了宏设计中的某些议题:</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defmacro</span> <span class="nv">ntimes</span> <span class="p">(</span><span class="nv">n</span> <span class="k">&amp;rest</span> <span class="nv">body</span><span class="p">)</span>
  <span class="o">`</span><span class="p">(</span><span class="nb">do</span> <span class="p">((</span><span class="nv">x</span> <span class="mi">0</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="mi">1</span><span class="p">)))</span>
       <span class="p">((</span><span class="nb">&gt;=</span> <span class="nv">x</span> <span class="o">,</span><span class="nv">n</span><span class="p">))</span>
     <span class="o">,@</span><span class="nv">body</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p>这个定义第一眼看起来可能没问题。在上面这个情况，它会如预期的工作。但实际上它在两个方面坏掉了。</p>
                              <p>一个宏设计者需要考虑的问题之一是，不小心引入的变量捕捉 (variable
                                capture)。这发生在当一个在宏展开式里用到的变量，恰巧与展开式即将插入的语境里，有使用同样名字作为变量的情况。不正确的 <code
                                  class="docutils literal"><span class="pre">ntimes</span></code> 定义创造了一个变量 <code
                                  class="docutils literal"><span class="pre">x</span></code> 。所以如果这个宏在已经有 <code
                                  class="docutils literal"><span class="pre">x</span></code> 作为名字的地方被调用时，它可能无法做到我们所预期的:
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">x</span> <span class="mi">10</span><span class="p">))</span>
    <span class="p">(</span><span class="nv">ntimes</span> <span class="mi">5</span>
       <span class="p">(</span><span class="nb">setf</span> <span class="nv">x</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="mi">1</span><span class="p">)))</span>
    <span class="nv">x</span><span class="p">)</span>
<span class="mi">10</span>
</pre>
                                </div>
                              </div>
                              <p>如果 <code class="docutils literal"><span class="pre">ntimes</span></code>
                                如我们预期般的执行，这个表达式应该会对 <code class="docutils literal"><span class="pre">x</span></code>
                                递增五次，最后返回 <code class="docutils literal"><span class="pre">15</span></code> 。但因为宏展开刚好使用
                                <code class="docutils literal"><span class="pre">x</span></code> 作为迭代变量， <code
                                  class="docutils literal"><span class="pre">setf</span></code> 表达式递增那个 <code
                                  class="docutils literal"><span class="pre">x</span></code>
                                ，而不是我们要递增的那个。一旦宏调用被展开，前述的展开式变成:
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">x</span> <span class="mi">10</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">do</span> <span class="p">((</span><span class="nv">x</span> <span class="mi">0</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="mi">1</span><span class="p">)))</span>
        <span class="p">((</span><span class="nb">&gt;=</span> <span class="nv">x</span> <span class="mi">5</span><span class="p">))</span>
      <span class="p">(</span><span class="nb">setf</span> <span class="nv">x</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="mi">1</span><span class="p">)))</span>
    <span class="nv">x</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>最普遍的解法是不要使用任何可能会被捕捉的一般符号。取而代之的我们使用 gensym (8.4 小节)。因为 <code
                                  class="docutils literal"><span class="pre">read</span></code> 函数 <code
                                  class="docutils literal"><span class="pre">intern</span></code>
                                每个它见到的符号，所以在一个程序里，没有可能会有任何符号会 <code
                                  class="docutils literal"><span class="pre">eql</span></code> gensym。如果我们使用 gensym 而不是
                                <code class="docutils literal"><span class="pre">x</span></code> 来重写 <code
                                  class="docutils literal"><span class="pre">ntimes</span></code> 的定义，至少对于变量捕捉来说，它是安全的:
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defmacro</span> <span class="nv">ntimes</span> <span class="p">(</span><span class="nv">n</span> <span class="k">&amp;rest</span> <span class="nv">body</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">g</span> <span class="p">(</span><span class="nb">gensym</span><span class="p">)))</span>
    <span class="o">`</span><span class="p">(</span><span class="nb">do</span> <span class="p">((</span><span class="o">,</span><span class="nv">g</span> <span class="mi">0</span> <span class="p">(</span><span class="nb">+</span> <span class="o">,</span><span class="nv">g</span> <span class="mi">1</span><span class="p">)))</span>
         <span class="p">((</span><span class="nb">&gt;=</span> <span class="o">,</span><span class="nv">g</span> <span class="o">,</span><span class="nv">n</span><span class="p">))</span>
       <span class="o">,@</span><span class="nv">body</span><span class="p">)))</span>
</pre>
                                </div>
                              </div>
                              <p>但这个宏在另一问题上仍有疑虑: 多重求值 (multiple evaluation)。因为第一个参数被直接插入 <code
                                  class="docutils literal"><span class="pre">do</span></code>
                                表达式，它会在每次迭代时被求值。当第一个参数是有副作用的表达式，这个错误非常清楚地表现出来:</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">v</span> <span class="mi">10</span><span class="p">))</span>
    <span class="p">(</span><span class="nv">ntimes</span> <span class="p">(</span><span class="nb">setf</span> <span class="nv">v</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">v</span> <span class="mi">1</span><span class="p">))</span>
      <span class="p">(</span><span class="nb">princ</span> <span class="s">&quot;.&quot;</span><span class="p">)))</span>
<span class="o">.....</span>
<span class="no">NIL</span>
</pre>
                                </div>
                              </div>
                              <p>由于 <code class="docutils literal"><span class="pre">v</span></code> 一开始是 <code
                                  class="docutils literal"><span class="pre">10</span></code> ，而 <code
                                  class="docutils literal"><span class="pre">setf</span></code>
                                返回其第二个参数的值，应该印出九个句点。实际上它只印出五个。</p>
                              <p>如果我们看看宏调用所展开的表达式，就可以知道为什么:</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">v</span> <span class="mi">10</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">do</span> <span class="p">((</span><span class="ss">#:g1</span> <span class="mi">0</span> <span class="p">(</span><span class="nb">+</span> <span class="ss">#:g1</span> <span class="mi">1</span><span class="p">)))</span>
        <span class="p">((</span><span class="nb">&gt;=</span> <span class="ss">#:g1</span> <span class="p">(</span><span class="nb">setf</span> <span class="nv">v</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">v</span> <span class="mi">1</span><span class="p">))))</span>
      <span class="p">(</span><span class="nb">princ</span> <span class="s">&quot;.&quot;</span><span class="p">)))</span>
</pre>
                                </div>
                              </div>
                              <p>每次迭代我们不是把迭代变量 (gensym 通常印出前面有 <code
                                  class="docutils literal"><span class="pre">#:</span></code> 的符号)与 <code
                                  class="docutils literal"><span class="pre">9</span></code>
                                比较，而是与每次求值时会递减的表达式比较。这如同每次我们查看地平线时，地平线都越来越近。</p>
                              <p>避免非预期的多重求值的方法是设置一个变量，在任何迭代前将其设为有疑惑的那个表达式。这通常牵扯到另一个 gensym:</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defmacro</span> <span class="nv">ntimes</span> <span class="p">(</span><span class="nv">n</span> <span class="k">&amp;rest</span> <span class="nv">body</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">g</span> <span class="p">(</span><span class="nb">gensym</span><span class="p">))</span>
        <span class="p">(</span><span class="nv">h</span> <span class="p">(</span><span class="nb">gensym</span><span class="p">)))</span>
    <span class="o">`</span><span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="o">,</span><span class="nv">h</span> <span class="o">,</span><span class="nv">n</span><span class="p">))</span>
       <span class="p">(</span><span class="nb">do</span> <span class="p">((</span><span class="o">,</span><span class="nv">g</span> <span class="mi">0</span> <span class="p">(</span><span class="nb">+</span> <span class="o">,</span><span class="nv">g</span> <span class="mi">1</span><span class="p">)))</span>
           <span class="p">((</span><span class="nb">&gt;=</span> <span class="o">,</span><span class="nv">g</span> <span class="o">,</span><span class="nv">h</span><span class="p">))</span>
         <span class="o">,@</span><span class="nv">body</span><span class="p">))))</span>
</pre>
                                </div>
                              </div>
                              <p>终于，这是一个 <code class="docutils literal"><span class="pre">ntimes</span></code> 的正确定义。
                              </p>
                              <p>非预期的变量捕捉与多重求值是折磨宏的主要问题，但不只有这些问题而已。有经验后，要避免这样的错误与避免更熟悉的错误一样简单，比如除以零的错误。</p>
                              <p>你的 Common Lisp 实现是一个学习更多有关宏的好地方。借由调用展开至内置宏，你可以理解它们是怎么写的。下面是大多数实现对于一个 <code
                                  class="docutils literal"><span class="pre">cond</span></code> 表达式会产生的展开式:</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">pprint</span> <span class="p">(</span><span class="nb">macroexpand-1</span> <span class="o">&#39;</span><span class="p">(</span><span class="nb">cond</span> <span class="p">(</span><span class="nv">a</span> <span class="nv">b</span><span class="p">)</span>
                                <span class="p">(</span><span class="nv">c</span> <span class="nv">d</span> <span class="nv">e</span><span class="p">)</span>
                                <span class="p">(</span><span class="no">t</span> <span class="nv">f</span><span class="p">))))</span>
<span class="p">(</span><span class="nv">IF</span> <span class="nv">A</span>
    <span class="nv">B</span>
    <span class="p">(</span><span class="nv">IF</span> <span class="nv">C</span>
        <span class="p">(</span><span class="nv">PROGN</span> <span class="nv">D</span> <span class="nv">E</span><span class="p">)</span>
        <span class="nv">F</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p>函数 <code class="docutils literal"><span class="pre">pprint</span></code>
                                印出像代码一样缩排的表达式，这在检视宏展开式时特别有用。</p>
                            </div>
                            <div class="section" id="generalized-reference">
                              <h4>10.6 通用化引用 (Generalized Reference)<a class="headerlink" href="#generalized-reference"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>由于一个宏调用可以直接在它出现的地方展开成代码，任何展开为 <code
                                  class="docutils literal"><span class="pre">setf</span></code> 表达式的宏调用都可以作为 <code
                                  class="docutils literal"><span class="pre">setf</span></code> 表达式的第一个参数。 举例来说，如果我们定义一个
                                <code class="docutils literal"><span class="pre">car</span></code> 的同义词，
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defmacro</span> <span class="nv">cah</span> <span class="p">(</span><span class="nv">lst</span><span class="p">)</span> <span class="o">`</span><span class="p">(</span><span class="nb">car</span> <span class="o">,</span><span class="nv">lst</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p>然后因为一个 <code class="docutils literal"><span class="pre">car</span></code> 调用可以是 <code
                                  class="docutils literal"><span class="pre">setf</span></code> 的第一个参数，而 <code
                                  class="docutils literal"><span class="pre">cah</span></code> 一样可以:</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">x</span> <span class="p">(</span><span class="nb">list</span> <span class="ss">&#39;a</span> <span class="ss">&#39;b</span> <span class="ss">&#39;c</span><span class="p">)))</span>
    <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nv">cah</span> <span class="nv">x</span><span class="p">)</span> <span class="mi">44</span><span class="p">)</span>
    <span class="nv">x</span><span class="p">)</span>
<span class="p">(</span><span class="mi">44</span> <span class="nv">B</span> <span class="nv">C</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>撰写一个展开成一个 <code class="docutils literal"><span class="pre">setf</span></code>
                                表达式的宏是另一个问题，是一个比原先看起来更为困难的问题。看起来也许你可以这样实现 <code
                                  class="docutils literal"><span class="pre">incf</span></code> ，只要</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defmacro</span> <span class="nb">incf</span> <span class="p">(</span><span class="nv">x</span> <span class="k">&amp;optional</span> <span class="p">(</span><span class="nv">y</span> <span class="mi">1</span><span class="p">))</span> <span class="c1">; wrong</span>
  <span class="o">`</span><span class="p">(</span><span class="nb">setf</span> <span class="o">,</span><span class="nv">x</span> <span class="p">(</span><span class="nb">+</span> <span class="o">,</span><span class="nv">x</span> <span class="o">,</span><span class="nv">y</span><span class="p">)))</span>
</pre>
                                </div>
                              </div>
                              <p>但这是行不通的。这两个表达式不相等:</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nb">car</span> <span class="p">(</span><span class="nb">push</span> <span class="mi">1</span> <span class="nv">lst</span><span class="p">))</span> <span class="p">(</span><span class="nb">1+</span> <span class="p">(</span><span class="nb">car</span> <span class="p">(</span><span class="nb">push</span> <span class="mi">1</span> <span class="nv">lst</span><span class="p">))))</span>

<span class="p">(</span><span class="nb">incf</span> <span class="p">(</span><span class="nb">car</span> <span class="p">(</span><span class="nb">push</span> <span class="mi">1</span> <span class="nv">lst</span><span class="p">)))</span>
</pre>
                                </div>
                              </div>
                              <p>如果 <code class="docutils literal"><span class="pre">lst</span></code> 是 <code
                                  class="docutils literal"><span class="pre">nil</span></code> 的话，第二个表达式会设成 <code
                                  class="docutils literal"><span class="pre">(2)</span></code> ，但第一个表达式会设成 <code
                                  class="docutils literal"><span class="pre">(1</span> <span class="pre">2)</span></code>
                                。</p>
                              <p>Common Lisp 提供了 <code
                                  class="docutils literal"><span class="pre">define-modify-macro</span></code> 作为写出对于
                                <code class="docutils literal"><span class="pre">setf</span></code> 限制类别的宏的一种方法 它接受三个参数:
                                宏的名字，额外的参数 (隐含第一个参数 <code
                                  class="docutils literal"><span class="pre">place</span></code>)，以及产生出 <code
                                  class="docutils literal"><span class="pre">place</span></code> 新数值的函数名。所以我们可以将 <code
                                  class="docutils literal"><span class="pre">incf</span></code> 定义为
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">define-modify-macro</span> <span class="nv">our-incf</span> <span class="p">(</span><span class="k">&amp;optional</span> <span class="p">(</span><span class="nv">y</span> <span class="mi">1</span><span class="p">))</span> <span class="nb">+</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>另一版将元素推至列表尾端的 <code class="docutils literal"><span class="pre">push</span></code> 可写成：
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">define-modify-macro</span> <span class="nv">append1f</span> <span class="p">(</span><span class="nv">val</span><span class="p">)</span>
  <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">lst</span> <span class="nv">val</span><span class="p">)</span> <span class="p">(</span><span class="nb">append</span> <span class="nv">lst</span> <span class="p">(</span><span class="nb">list</span> <span class="nv">val</span><span class="p">))))</span>
</pre>
                                </div>
                              </div>
                              <p>后者会如下工作:</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">lst</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">)))</span>
    <span class="p">(</span><span class="nv">append1f</span> <span class="nv">lst</span> <span class="ss">&#39;d</span><span class="p">)</span>
    <span class="nv">lst</span><span class="p">)</span>
<span class="p">(</span><span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="nv">D</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>顺道一提， <code class="docutils literal"><span class="pre">push</span></code> 与 <code
                                  class="docutils literal"><span class="pre">pop</span></code> 都不能定义为 modify-macros，前者因为
                                <code class="docutils literal"><span class="pre">place</span></code>
                                不是其第一个参数，而后者因为其返回值不是更改后的对象。
                              </p>
                            </div>
                            <div class="section" id="example-macro-utilities">
                              <h4>10.7 示例：实用的宏函数 (Example: Macro Utilities)<a class="headerlink"
                                  href="#example-macro-utilities" title="Permalink to this headline">¶</a></h4>
                              <p>6.4 节介绍了实用函数 (utility)的概念，一种像是构造 Lisp 的通用操作符。我们可以使用宏来定义不能写作函数的实用函数。我们已经见过几个例子: <code
                                  class="docutils literal"><span class="pre">nil!</span></code> , <code
                                  class="docutils literal"><span class="pre">ntimes</span></code> 以及 <code
                                  class="docutils literal"><span class="pre">while</span></code>
                                ，全部都需要写成宏，因为它们全都需要某种控制参数求值的方法。本节给出更多你可以使用宏写出的多种实用函数。图 10.2 挑选了几个实践中证实值得写的实用函数。</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defmacro</span> <span class="nv">for</span> <span class="p">(</span><span class="nv">var</span> <span class="nv">start</span> <span class="nv">stop</span> <span class="k">&amp;body</span> <span class="nv">body</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">gstop</span> <span class="p">(</span><span class="nb">gensym</span><span class="p">)))</span>
    <span class="o">`</span><span class="p">(</span><span class="nb">do</span> <span class="p">((</span><span class="o">,</span><span class="nv">var</span> <span class="o">,</span><span class="nv">start</span> <span class="p">(</span><span class="nb">1+</span> <span class="o">,</span><span class="nv">var</span><span class="p">))</span>
          <span class="p">(</span><span class="o">,</span><span class="nv">gstop</span> <span class="o">,</span><span class="nv">stop</span><span class="p">))</span>
         <span class="p">((</span><span class="nb">&gt;</span> <span class="o">,</span><span class="nv">var</span> <span class="o">,</span><span class="nv">gstop</span><span class="p">))</span>
       <span class="o">,@</span><span class="nv">body</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defmacro</span> <span class="nv">in</span> <span class="p">(</span><span class="nv">obj</span> <span class="k">&amp;rest</span> <span class="nv">choices</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">insym</span> <span class="p">(</span><span class="nb">gensym</span><span class="p">)))</span>
    <span class="o">`</span><span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="o">,</span><span class="nv">insym</span> <span class="o">,</span><span class="nv">obj</span><span class="p">))</span>
       <span class="p">(</span><span class="nb">or</span> <span class="o">,@</span><span class="p">(</span><span class="nb">mapcar</span> <span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">c</span><span class="p">)</span> <span class="o">`</span><span class="p">(</span><span class="nb">eql</span> <span class="o">,</span><span class="nv">insym</span> <span class="o">,</span><span class="nv">c</span><span class="p">))</span>
                     <span class="nv">choices</span><span class="p">)))))</span>

<span class="p">(</span><span class="nb">defmacro</span> <span class="nv">random-choice</span> <span class="p">(</span><span class="k">&amp;rest</span> <span class="nv">exprs</span><span class="p">)</span>
  <span class="o">`</span><span class="p">(</span><span class="nb">case</span> <span class="p">(</span><span class="nb">random</span> <span class="o">,</span><span class="p">(</span><span class="nb">length</span> <span class="nv">exprs</span><span class="p">))</span>
     <span class="o">,@</span><span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">key</span> <span class="mi">-1</span><span class="p">))</span>
         <span class="p">(</span><span class="nb">mapcar</span> <span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">expr</span><span class="p">)</span>
                     <span class="o">`</span><span class="p">(</span><span class="o">,</span><span class="p">(</span><span class="nb">incf</span> <span class="nv">key</span><span class="p">)</span> <span class="o">,</span><span class="nv">expr</span><span class="p">))</span>
                 <span class="nv">exprs</span><span class="p">))))</span>

<span class="p">(</span><span class="nb">defmacro</span> <span class="nv">avg</span> <span class="p">(</span><span class="k">&amp;rest</span> <span class="nv">args</span><span class="p">)</span>
  <span class="o">`</span><span class="p">(</span><span class="nb">/</span> <span class="p">(</span><span class="nb">+</span> <span class="o">,@</span><span class="nv">args</span><span class="p">)</span> <span class="o">,</span><span class="p">(</span><span class="nb">length</span> <span class="nv">args</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defmacro</span> <span class="nv">with-gensyms</span> <span class="p">(</span><span class="nv">syms</span> <span class="k">&amp;body</span> <span class="nv">body</span><span class="p">)</span>
  <span class="o">`</span><span class="p">(</span><span class="k">let</span> <span class="o">,</span><span class="p">(</span><span class="nb">mapcar</span> <span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">s</span><span class="p">)</span>
                     <span class="o">`</span><span class="p">(</span><span class="o">,</span><span class="nv">s</span> <span class="p">(</span><span class="nb">gensym</span><span class="p">)))</span>
                 <span class="nv">syms</span><span class="p">)</span>
     <span class="o">,@</span><span class="nv">body</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defmacro</span> <span class="nv">aif</span> <span class="p">(</span><span class="nv">test</span> <span class="nv">then</span> <span class="k">&amp;optional</span> <span class="nv">else</span><span class="p">)</span>
  <span class="o">`</span><span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">it</span> <span class="o">,</span><span class="nv">test</span><span class="p">))</span>
     <span class="p">(</span><span class="k">if</span> <span class="nv">it</span> <span class="o">,</span><span class="nv">then</span> <span class="o">,</span><span class="nv">else</span><span class="p">)))</span>
</pre>
                                </div>
                              </div>
                              <p><strong>图 10.2: 实用宏函数</strong></p>
                              <p>第一个 <code class="docutils literal"><span class="pre">for</span></code> ，设计上与 <code
                                  class="docutils literal"><span class="pre">while</span></code> 相似 (164 页，译注: 10.3
                                节)。它是给需要使用一个绑定至一个值的范围的新变量来对主体求值的循环:</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">for</span> <span class="nv">x</span> <span class="mi">1</span> <span class="mi">8</span>
          <span class="p">(</span><span class="nb">princ</span> <span class="nv">x</span><span class="p">))</span>
<span class="mi">12345678</span>
<span class="no">NIL</span>
</pre>
                                </div>
                              </div>
                              <p>这比写出等效的 <code class="docutils literal"><span class="pre">do</span></code> 来得省事，</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">do</span> <span class="p">((</span><span class="nv">x</span> <span class="mi">1</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="mi">1</span><span class="p">)))</span>
    <span class="p">((</span><span class="nb">&gt;</span> <span class="nv">x</span> <span class="mi">8</span><span class="p">))</span>
  <span class="p">(</span><span class="nb">princ</span> <span class="nv">x</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p>这非常接近实际的展开式:</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">do</span> <span class="p">((</span><span class="nv">x</span> <span class="mi">1</span> <span class="p">(</span><span class="nb">1+</span> <span class="nv">x</span><span class="p">))</span>
     <span class="p">(</span><span class="ss">#:g1</span> <span class="mi">8</span><span class="p">))</span>
    <span class="p">((</span><span class="nb">&gt;</span> <span class="nv">x</span> <span class="ss">#:g1</span><span class="p">))</span>
  <span class="p">(</span><span class="nb">princ</span> <span class="nv">x</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p>宏需要引入一个额外的变量来持有标记范围 (range)结束的值。 上面在例子里的 <code
                                  class="docutils literal"><span class="pre">8</span></code>
                                也可是个函数调用，这样我们就不需要求值好几次。额外的变量需要是一个 gensym ，为了避免非预期的变量捕捉。</p>
                              <p>图 10.2 的第二个宏 <code class="docutils literal"><span class="pre">in</span></code> ，若其第一个参数
                                <code class="docutils literal"><span class="pre">eql</span></code>
                                任何自己其他的参数时，返回真。表达式我们可以写成:
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nv">in</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">expr</span><span class="p">)</span> <span class="ss">&#39;+</span> <span class="ss">&#39;-</span> <span class="ss">&#39;*</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>我们可以改写成:</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">op</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">expr</span><span class="p">)))</span>
  <span class="p">(</span><span class="nb">or</span> <span class="p">(</span><span class="nb">eql</span> <span class="nv">op</span> <span class="ss">&#39;+</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">eql</span> <span class="nv">op</span> <span class="ss">&#39;-</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">eql</span> <span class="nv">op</span> <span class="ss">&#39;*</span><span class="p">)))</span>
</pre>
                                </div>
                              </div>
                              <p>确实，第一个表达式展开后像是第二个，除了变量 <code
                                  class="docutils literal"><span class="pre">op</span></code> 被一个 gensym 取代了。</p>
                              <p>下一个例子 <code class="docutils literal"><span class="pre">random-choice</span></code>
                                ，随机选取一个参数求值。在 74 页 (译注: 第 4 章的图 4.6)我们需要随机在两者之间选择。 <code
                                  class="docutils literal"><span class="pre">random-choice</span></code>
                                宏实现了通用的解法。一个像是这样的调用:</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nv">random-choice</span> <span class="p">(</span><span class="nv">turn-left</span><span class="p">)</span> <span class="p">(</span><span class="nv">turn-right</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p>会被展开为:</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">case</span> <span class="p">(</span><span class="nb">random</span> <span class="mi">2</span><span class="p">)</span>
  <span class="p">(</span><span class="mi">0</span> <span class="p">(</span><span class="nv">turn-left</span><span class="p">))</span>
  <span class="p">(</span><span class="mi">1</span> <span class="p">(</span><span class="nv">turn-right</span><span class="p">)))</span>
</pre>
                                </div>
                              </div>
                              <p>下一个宏 <code class="docutils literal"><span class="pre">with-gensyms</span></code>
                                主要预期用在宏主体里。它不寻常，特别是在特定应用中的宏，需要 gensym 几个变量。有了这个宏，与其</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">x</span> <span class="p">(</span><span class="nb">gensym</span><span class="p">))</span> <span class="p">(</span><span class="nv">y</span> <span class="p">(</span><span class="nb">gensym</span><span class="p">))</span> <span class="p">(</span><span class="nv">z</span> <span class="p">(</span><span class="nb">gensym</span><span class="p">)))</span>
        <span class="o">...</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>我们可以写成</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nv">with-gensyms</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span><span class="p">)</span>
        <span class="o">...</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>到目前为止，图 10.2
                                定义的宏，没有一个可以定义成函数。作为一个规则，写成宏是因为你不能将它写成函数。但这个规则有几个例外。有时候你或许想要定义一个操作符来作为宏，好让它在编译期完成它的工作。宏
                                <code class="docutils literal"><span class="pre">avg</span></code> 返回其参数的平均值，
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">avg</span> <span class="mi">2</span> <span class="mi">4</span> <span class="mi">8</span><span class="p">)</span>
<span class="m">14/3</span>
</pre>
                                </div>
                              </div>
                              <p>是一个这种例子的宏。我们可以将 <code class="docutils literal"><span class="pre">avg</span></code>
                                写成函数，</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">avg</span> <span class="p">(</span><span class="k">&amp;rest</span> <span class="nv">args</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">/</span> <span class="p">(</span><span class="nb">apply</span> <span class="nf">#&#39;</span><span class="nb">+</span> <span class="nv">args</span><span class="p">)</span> <span class="p">(</span><span class="nb">length</span> <span class="nv">args</span><span class="p">)))</span>
</pre>
                                </div>
                              </div>
                              <p>但它会需要在执行期找出参数的数量。只要我们愿意放弃应用 <code
                                  class="docutils literal"><span class="pre">avg</span></code> ，为什么不在编译期调用 <code
                                  class="docutils literal"><span class="pre">length</span></code> 呢？</p>
                              <p>图 10.2 的最后一个宏是 <code class="docutils literal"><span class="pre">aif</span></code>
                                ，它在此作为一个故意变量捕捉的例子。它让我们可以使用变量 <code
                                  class="docutils literal"><span class="pre">it</span></code>
                                来引用到一个条件式里的测试参数所返回的值。也就是说，与其写成</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">val</span> <span class="p">(</span><span class="nv">calculate-something</span><span class="p">)))</span>
  <span class="p">(</span><span class="k">if</span> <span class="nv">val</span>
      <span class="p">(</span><span class="nb">1+</span> <span class="nv">val</span><span class="p">)</span>
      <span class="mi">0</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p>我们可以写成</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nv">aif</span> <span class="p">(</span><span class="nv">calculate-something</span><span class="p">)</span>
     <span class="p">(</span><span class="nb">1+</span> <span class="nv">it</span><span class="p">)</span>
     <span class="mi">0</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p><strong>小心使用</strong> ( <em>Use judiciously</em>)，预期的变量捕捉可以是一个无价的技巧。Common Lisp
                                本身在多处使用它: 举例来说 <code
                                  class="docutils literal"><span class="pre">next-method-p</span></code> 与 <code
                                  class="docutils literal"><span class="pre">call-next-method</span></code> 皆依赖于变量捕捉。
                              </p>
                              <p>像这些宏明确演示了为何要撰写替你写程序的程序。一旦你定义了 <code
                                  class="docutils literal"><span class="pre">for</span></code> ，你就不需要写整个 <code
                                  class="docutils literal"><span class="pre">do</span></code>
                                表达式。值得写一个宏只为了节省打字吗？非常值得。节省打字是程序设计的全部；一个编译器的目的便是替你省下使用机械语言输入程序的时间。而宏允许你将同样的优点带到特定的应用里，就像高阶语言带给程序语言一般。通过审慎的使用宏，你也许可以使你的程序比起原来大幅度地精简，并使程序更显着地容易阅读、撰写及维护。
                              </p>
                              <p>
                                如果仍对此怀疑，考虑看看如果你没有使用任何内置宏时，程序看起来会是怎么样。所有宏产生的展开式，你会需要用手产生。你也可以将这个问题用在另一方面。当你在撰写一个程序时，扪心自问，我需要撰写宏展开式吗？如果是的话，宏所产生的展开式就是你需要写的东西。
                              </p>
                            </div>
                            <div class="section" id="lisp-on-lisp">
                              <h4>10.8 源自 Lisp (On Lisp)<a class="headerlink" href="#lisp-on-lisp"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>现在宏已经介绍过了，我们看过更多的 Lisp 是由超乎我们想像的 Lisp 写成。许多不是函数的 Common Lisp 操作符是宏，而他们全部用 Lisp
                                写成的。只有二十五个 Common Lisp 内置的操作符是特殊操作符。</p>
                              <p><a class="reference external" href="http://www.franz.com/about/bios/jkf.lhtml">John
                                  Foderaro</a> 将 Lisp 称为“可程序的程序语言。” <a class="reference external"
                                  href="http://acl.readthedocs.org/en/latest/zhCN/notes-cn.html#notes-173">λ</a>
                                通过撰写你自己的函数与宏，你将 Lisp 变成任何你想要的语言。 (我们会在 17 章看到这个可能性的图形化示范)无论你的程序适合何种形式，你确信你可以将 Lisp
                                塑造成适合它的语言。</p>
                              <p>宏是这个灵活性的主要成分之一。它们允许你将 Lisp 变得完全认不出来，但仍然用一种有原则且高效的方法来实作。在 Lisp
                                社区里，宏是个越来越感兴趣的主题。可以使用宏办到惊人之事是很清楚的，但更确信的是宏背后还有更多需要被探索。如果你想的话，可以通过你来发现。Lisp
                                永远将进化放在程序员手里。这是它为什么存活的原因。</p>
                            </div>
                            <div class="section" id="chapter-10-summary">
                              <h4>Chapter 10 总结 (Summary)<a class="headerlink" href="#chapter-10-summary"
                                  title="Permalink to this headline">¶</a></h4>
                              <ol class="arabic simple">
                                <li>调用 <code class="docutils literal"><span class="pre">eval</span></code> 是让 Lisp
                                  将列表视为代码的一种方法，但这是不必要而且效率低落的。</li>
                                <li>你通过叙说一个调用会展开成什么来定义一个宏。台面底下，宏只是返回表达式的函数。</li>
                                <li>一个使用反引号定义的主体看起来像它会产生出的展开式 (expansion)。</li>
                                <li>宏设计者需要注意变量捕捉及多重求值。宏可以通过漂亮印出 (pretty-printing)来测试它们的展开式。</li>
                                <li>多重求值是大多数展开成 <code class="docutils literal"><span class="pre">setf</span></code>
                                  表达式的问题。</li>
                                <li>宏比函数来得灵活，可以用来定义许多实用函数。你甚至可以使用变量捕捉来获得好处。</li>
                                <li>Lisp 存活的原因是它将进化交给程序员的双手。宏是使其可能的部分原因之一。</li>
                              </ol>
                            </div>
                            <div class="section" id="chapter-10-exercises">
                              <h4>Chapter 10 练习 (Exercises)<a class="headerlink" href="#chapter-10-exercises"
                                  title="Permalink to this headline">¶</a></h4>
                              <ol class="arabic simple">
                                <li>如果 <code class="docutils literal"><span class="pre">x</span></code> 是 <code
                                    class="docutils literal"><span class="pre">a</span></code> ， <code
                                    class="docutils literal"><span class="pre">y</span></code> 是 <code
                                    class="docutils literal"><span class="pre">b</span></code> 以及 <code
                                    class="docutils literal"><span class="pre">z</span></code> 是 <code
                                    class="docutils literal"><span class="pre">(c</span> <span class="pre">d)</span></code>
                                  ，写出反引用表达式仅包含产生下列结果之一的变量:</li>
                              </ol>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nv">a</span><span class="p">)</span> <span class="p">((</span><span class="nv">C</span> <span class="nv">D</span><span class="p">)</span> <span class="nv">A</span> <span class="nv">Z</span><span class="p">)</span>

<span class="p">(</span><span class="nv">b</span><span class="p">)</span> <span class="p">(</span><span class="nv">X</span> <span class="nv">B</span> <span class="nv">C</span> <span class="nv">D</span><span class="p">)</span>

<span class="p">(</span><span class="nv">c</span><span class="p">)</span> <span class="p">((</span><span class="nv">C</span> <span class="nv">D</span> <span class="nv">A</span><span class="p">)</span> <span class="nv">Z</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <ol class="arabic simple" start="2">
                                <li>使用 <code class="docutils literal"><span class="pre">cond</span></code> 来定义 <code
                                    class="docutils literal"><span class="pre">if</span></code> 。</li>
                                <li>定义一个宏，接受一个数字 <em>n</em> ，伴随着一个或多个表达式，并返回第 <em>n</em> 个表达式的值:</li>
                              </ol>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">n</span> <span class="mi">2</span><span class="p">))</span>
    <span class="p">(</span><span class="nv">nth-expr</span> <span class="nv">n</span> <span class="p">(</span><span class="nb">/</span> <span class="mi">1</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="nb">/</span> <span class="mi">1</span> <span class="mi">0</span><span class="p">)))</span>
<span class="mi">3</span>
</pre>
                                </div>
                              </div>
                              <ol class="arabic simple" start="4">
                                <li>定义 <code class="docutils literal"><span class="pre">ntimes</span></code> (167 页，译注:
                                  10.5 节)使其展开成一个 (区域)递归函数，而不是一个 <code
                                    class="docutils literal"><span class="pre">do</span></code> 表达式。</li>
                                <li>定义一个宏 <code class="docutils literal"><span class="pre">n-of</span></code> ，接受一个数字
                                  <em>n</em> 与一个表达式，返回一个 <em>n</em> 个渐进值:
                                </li>
                              </ol>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">i</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nv">n</span> <span class="mi">4</span><span class="p">))</span>
    <span class="p">(</span><span class="nv">n-of</span> <span class="nv">n</span> <span class="p">(</span><span class="nb">incf</span> <span class="nv">i</span><span class="p">)))</span>
<span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <ol class="arabic simple" start="6">
                                <li>定义一个宏，接受一变量列表以及一个代码主体，并确保变量在代码主体被求值后恢复 (revert)到原本的数值。</li>
                                <li>下面这个 <code class="docutils literal"><span class="pre">push</span></code> 的定义哪里错误？
                                </li>
                              </ol>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre>(defmacro push (obj lst)
  `(setf ,lst (cons ,obj ,lst)))

举出一个不会与实际 push 做一样事情的函数调用例子。
</pre>
                                </div>
                              </div>
                              <ol class="arabic simple" start="8">
                                <li>定义一个将其参数翻倍的宏:</li>
                              </ol>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">x</span> <span class="mi">1</span><span class="p">))</span>
    <span class="p">(</span><span class="nv">double</span> <span class="nv">x</span><span class="p">)</span>
    <span class="nv">x</span><span class="p">)</span>
<span class="mi">2</span>
</pre>
                                </div>
                              </div>
                              <p class="rubric">脚注</p>
                              <table class="docutils footnote" frame="void" id="id5" rules="none">
                                <colgroup>
                                  <col class="label" />
                                  <col />
                                </colgroup>
                                <tbody valign="top">
                                  <tr>
                                    <td class="label"><a class="fn-backref" href="#id2">[1]</a></td>
                                    <td>要真的复制一个 Lisp 的话， <code
                                        class="docutils literal"><span class="pre">eval</span></code> 会需要接受第二个参数 (这里的
                                      <code class="docutils literal"><span class="pre">env</span></code>) 来表示词法环境
                                      (lexical enviroment)。这个模型的 <code
                                        class="docutils literal"><span class="pre">eval</span></code>
                                      是不正确的，因为它在对参数求值前就取出函数，然而 Common Lisp 故意没有特别指出这两个操作的顺序。
                                    </td>
                                  </tr>
                                </tbody>
                              </table>
                            </div>
                          </div>
                          <div class="section" id="common-lisp">
                            <h3 id="11">第十一章：Common Lisp 对象系统<a class="headerlink" href="#common-lisp"
                                title="Permalink to this headline">¶</a></h3>
                            <p>Common Lisp 对象系统，或称 CLOS，是一组用来实现面向对象编程的操作集。由于它们有着同样的历史，通常将这些操作视为一个群组。 <a
                                class="reference external"
                                href="http://acl.readthedocs.org/en/latest/zhCN/notes-cn.html#notes-176">λ</a>
                              技术上来说，它们与其他部分的 Common Lisp 没什么大不同： <code
                                class="docutils literal"><span class="pre">defmethod</span></code> 和 <code
                                class="docutils literal"><span class="pre">defun</span></code> 一样，都是整合在语言中的一个部分。</p>
                            <div class="section" id="object-oriented-programming">
                              <h4>11.1 面向对象编程 Object-Oriented Programming<a class="headerlink"
                                  href="#object-oriented-programming" title="Permalink to this headline">¶</a></h4>
                              <p>面向对象编程意味著程序组织方式的改变。这个改变跟已经发生过的处理器运算处理能力分配的变化雷同。在 1970
                                年代，一个多用户的计算机系统代表著，一个或两个大型机连接到大量的<a class="reference external"
                                  href="http://zh.wikipedia.org/wiki/%E5%93%91%E7%BB%88%E7%AB%AF">哑终端</a>(dumb
                                terminal)。现在更可能的是大量相互通过网络连接的工作站 (workstation)。系统的运算处理能力现在分布至个体用户上，而不是集中在一台大型的计算机上。</p>
                              <p>面向对象编程所带来的变革与上例非常类似，前者打破了传统程序的组织方式。不再让单一的程序去操作那些数据，而是告诉数据自己该做什么，程序隐含在这些新的数据“对象”的交互过程之中。
                              </p>
                              <p>举例来说，假设我们要算出一个二维图形的面积。一个办法是写一个单独的函数，让它检查其参数的类型，然后视类型做处理，如图 11.1 所示。</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defstruct</span> <span class="nv">rectangle</span>
  <span class="nv">height</span> <span class="nv">width</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defstruct</span> <span class="nv">circle</span>
  <span class="nv">radius</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">area</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nv">rectangle-p</span> <span class="nv">x</span><span class="p">)</span>
         <span class="p">(</span><span class="nb">*</span> <span class="p">(</span><span class="nv">rectangle-height</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nv">rectangle-width</span> <span class="nv">x</span><span class="p">)))</span>
        <span class="p">((</span><span class="nv">circle-p</span> <span class="nv">x</span><span class="p">)</span>
         <span class="p">(</span><span class="nb">*</span> <span class="nv">pi</span> <span class="p">(</span><span class="nb">expt</span> <span class="p">(</span><span class="nv">circle-radius</span> <span class="nv">x</span><span class="p">)</span> <span class="mi">2</span><span class="p">)))))</span>

<span class="nb">&gt;</span> <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">r</span> <span class="p">(</span><span class="nv">make-rectangle</span><span class="p">)))</span>
    <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nv">rectangle-height</span> <span class="nv">r</span><span class="p">)</span> <span class="mi">2</span>
          <span class="p">(</span><span class="nv">rectangle-width</span> <span class="nv">r</span><span class="p">)</span> <span class="mi">3</span><span class="p">)</span>
    <span class="p">(</span><span class="nv">area</span> <span class="nv">r</span><span class="p">))</span>
<span class="mi">6</span>
</pre>
                                </div>
                              </div>
                              <p><strong>图 11.1: 使用结构及函数来计算面积</strong></p>
                              <p>使用 CLOS 我们可以写出一个等效的程序，如图 11.2 所示。在面向对象模型里，我们的程序被拆成数个独一无二的方法，每个方法为某些特定类型的参数而生。图 11.2
                                中的两个方法，隐性地定义了一个与图 11.1 相似作用的 <code
                                  class="docutils literal"><span class="pre">area</span></code> 函数，当我们调用 <code
                                  class="docutils literal"><span class="pre">area</span></code> 时，Lisp
                                检查参数的类型，并调用相对应的方法。</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defclass</span> <span class="nv">rectangle</span> <span class="p">()</span>
  <span class="p">(</span><span class="nv">height</span> <span class="nv">width</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defclass</span> <span class="nv">circle</span> <span class="p">()</span>
  <span class="p">(</span><span class="nv">radius</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defmethod</span> <span class="nv">area</span> <span class="p">((</span><span class="nv">x</span> <span class="nv">rectangle</span><span class="p">))</span>
  <span class="p">(</span><span class="nb">*</span> <span class="p">(</span><span class="nb">slot-value</span> <span class="nv">x</span> <span class="ss">&#39;height</span><span class="p">)</span> <span class="p">(</span><span class="nb">slot-value</span> <span class="nv">x</span> <span class="ss">&#39;width</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defmethod</span> <span class="nv">area</span> <span class="p">((</span><span class="nv">x</span> <span class="nv">circle</span><span class="p">))</span>
  <span class="p">(</span><span class="nb">*</span> <span class="nv">pi</span> <span class="p">(</span><span class="nb">expt</span> <span class="p">(</span><span class="nb">slot-value</span> <span class="nv">x</span> <span class="ss">&#39;radius</span><span class="p">)</span> <span class="mi">2</span><span class="p">)))</span>

<span class="nb">&gt;</span> <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">r</span> <span class="p">(</span><span class="nb">make-instance</span> <span class="ss">&#39;rectangle</span><span class="p">)))</span>
    <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nb">slot-value</span> <span class="nv">r</span> <span class="ss">&#39;height</span><span class="p">)</span> <span class="mi">2</span>
          <span class="p">(</span><span class="nb">slot-value</span> <span class="nv">r</span> <span class="ss">&#39;width</span><span class="p">)</span> <span class="mi">3</span><span class="p">)</span>
    <span class="p">(</span><span class="nv">area</span> <span class="nv">r</span><span class="p">))</span>
<span class="mi">6</span>
</pre>
                                </div>
                              </div>
                              <p><strong>图 11.2: 使用类型与方法来计算面积</strong></p>
                              <p>通过这种方式，我们将函数拆成独一无二的方法，面向对象暗指<em>继承</em> (<em>inheritance</em>) ──
                                槽（slot）与方法（method）皆有继承。在图 11.2 中，作为第二个参数传给 <code
                                  class="docutils literal"><span class="pre">defclass</span></code>
                                的空列表列出了所有基类。假设我们要定义一个新类，上色的圆形 (colored-circle)，则上色的圆形有两个基类， <code
                                  class="docutils literal"><span class="pre">colored</span></code> 与 <code
                                  class="docutils literal"><span class="pre">circle</span></code> ：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defclass</span> <span class="nv">colored</span> <span class="p">()</span>
  <span class="p">(</span><span class="nv">color</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defclass</span> <span class="nv">colored-circle</span> <span class="p">(</span><span class="nv">circle</span> <span class="nv">colored</span><span class="p">)</span>
  <span class="p">())</span>
</pre>
                                </div>
                              </div>
                              <p>当我们创造 <code class="docutils literal"><span class="pre">colored-circle</span></code>
                                类的实例 (instance)时，我们会看到两个继承：</p>
                              <ol class="arabic simple">
                                <li><code class="docutils literal"><span class="pre">colored-circle</span></code>
                                  的实例会有两个槽：从 <code class="docutils literal"><span class="pre">circle</span></code>
                                  类继承而来的 <code class="docutils literal"><span class="pre">radius</span></code> 以及从 <code
                                    class="docutils literal"><span class="pre">colored</span></code> 类继承而来的 <code
                                    class="docutils literal"><span class="pre">color</span></code> 。</li>
                                <li>由于没有特别为 <code
                                    class="docutils literal"><span class="pre">colored-circle</span></code> 定义的 <code
                                    class="docutils literal"><span class="pre">area</span></code> 方法存在，若我们对 <code
                                    class="docutils literal"><span class="pre">colored-circle</span></code> 实例调用 <code
                                    class="docutils literal"><span class="pre">area</span></code> ，我们会获得替 <code
                                    class="docutils literal"><span class="pre">circle</span></code> 类所定义的 <code
                                    class="docutils literal"><span class="pre">area</span></code> 方法。</li>
                              </ol>
                              <p>从实践层面来看，面向对象编程代表著以方法、类、实例以及继承来组织程序。为什么你会想这么组织程序？面向对象方法的主张之一说这样使得程序更容易改动。如果我们想要改变 <code
                                  class="docutils literal"><span class="pre">ob</span></code> 类对象所显示的方式，我们只需要改动 <code
                                  class="docutils literal"><span class="pre">ob</span></code> 类的 <code
                                  class="docutils literal"><span class="pre">display</span></code> 方法。如果我们希望创建一个新的类，大致上与
                                <code class="docutils literal"><span class="pre">ob</span></code> 相同，只有某些方面不同，我们可以创建一个
                                <code class="docutils literal"><span class="pre">ob</span></code>
                                类的子类。在这个子类里，我们仅改动我们想要的属性，其他所有的属性会从 <code
                                  class="docutils literal"><span class="pre">ob</span></code> 类默认继承得到。要是我们只是想让某个 <code
                                  class="docutils literal"><span class="pre">ob</span></code> 对象和其他的 <code
                                  class="docutils literal"><span class="pre">ob</span></code> 对象不一样，我们可以新建一个 <code
                                  class="docutils literal"><span class="pre">ob</span></code>
                                对象，直接修改这个对象的属性即可。若是当时的程序写的很讲究，我们甚至不需要看程序中其他的代码一眼，就可以完成种种的改动。 <a
                                  class="reference external"
                                  href="http://acl.readthedocs.org/en/latest/zhCN/notes-cn.html#notes-178">λ</a>
                              </p>
                            </div>
                            <div class="section" id="class-and-instances">
                              <h4>11.2 类与实例 (Class and Instances)<a class="headerlink" href="#class-and-instances"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>在 4.6 节时，我们看过了创建结构的两个步骤：我们调用 <code
                                  class="docutils literal"><span class="pre">defstruct</span></code> 来设计一个结构的形式，接著通过一个像是
                                <code class="docutils literal"><span class="pre">make-point</span></code>
                                这样特定的函数来创建结构。创建实例 (instances)同样需要两个类似的步骤。首先我们使用 <code
                                  class="docutils literal"><span class="pre">defclass</span></code> 来定义一个类别 (Class):
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defclass</span> <span class="nv">circle</span> <span class="p">()</span>
  <span class="p">(</span><span class="nv">radius</span> <span class="nv">center</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p>这个定义说明了 <code class="docutils literal"><span class="pre">circle</span></code>
                                类别的实例会有两个槽 (<em>slot</em>)，分别名为 <code
                                  class="docutils literal"><span class="pre">radius</span></code> 与 <code
                                  class="docutils literal"><span class="pre">center</span></code> （槽类比于结构里的字段 「field」）。
                              </p>
                              <p>要创建这个类的实例，我们调用通用的 <code
                                  class="docutils literal"><span class="pre">make-instance</span></code>
                                函数，而不是调用一个特定的函数，传入的第一个参数为类别名称：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre>&gt; (setf c (make-instance &#39;circle))
#&lt;CIRCLE #XC27496&gt;
</pre>
                                </div>
                              </div>
                              <p>要给这个实例的槽赋值，我们可以使用 <code class="docutils literal"><span class="pre">setf</span></code>
                                搭配 <code class="docutils literal"><span class="pre">slot-value</span></code> ：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nb">slot-value</span> <span class="nv">c</span> <span class="ss">&#39;radius</span><span class="p">)</span> <span class="mi">1</span><span class="p">)</span>
<span class="mi">1</span>
</pre>
                                </div>
                              </div>
                              <p>与结构的字段类似，未初始化的槽的值是未定义的 (undefined)。</p>
                            </div>
                            <div class="section" id="slot-properties">
                              <h4>11.3 槽的属性 (Slot Properties)<a class="headerlink" href="#slot-properties"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>传给 <code class="docutils literal"><span class="pre">defclass</span></code>
                                的第三个参数必须是一个槽定义的列表。如上例所示，最简单的槽定义是一个表示其名称的符号。在一般情况下，一个槽定义可以是一个列表，第一个是槽的名称，伴随著一个或多个属性
                                (property)。属性像关键字参数那样指定。</p>
                              <p>通过替一个槽定义一个访问器 (accessor)，我们隐式地定义了一个可以引用到槽的函数，使我们不需要再调用 <code
                                  class="docutils literal"><span class="pre">slot-value</span></code> 函数。如果我们如下更新我们的
                                <code class="docutils literal"><span class="pre">circle</span></code> 类定义，
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defclass</span> <span class="nv">circle</span> <span class="p">()</span>
  <span class="p">((</span><span class="nv">radius</span> <span class="ss">:accessor</span> <span class="nv">circle-radius</span><span class="p">)</span>
   <span class="p">(</span><span class="nv">center</span> <span class="ss">:accessor</span> <span class="nv">circle-center</span><span class="p">)))</span>
</pre>
                                </div>
                              </div>
                              <p>那我们能够分别通过 <code class="docutils literal"><span class="pre">circle-radius</span></code>
                                及 <code class="docutils literal"><span class="pre">circle-center</span></code> 来引用槽：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre>&gt; (setf c (make-instance &#39;circle))
#&lt;CIRCLE #XC5C726&gt;

&gt; (setf (circle-radius c) 1)
1

&gt; (circle-radius c)
1
</pre>
                                </div>
                              </div>
                              <p>通过指定一个 <code class="docutils literal"><span class="pre">:writer</span></code> 或是一个
                                <code class="docutils literal"><span class="pre">:reader</span></code> ，而不是 <code
                                  class="docutils literal"><span class="pre">:accessor</span></code> ，我们可以获得访问器的写入或读取行为。
                              </p>
                              <p>要指定一个槽的缺省值，我们可以给入一个 <code
                                  class="docutils literal"><span class="pre">:initform</span></code> 参数。若我们想要在 <code
                                  class="docutils literal"><span class="pre">make-instance</span></code>
                                调用期间就将槽初始化，我们可以用 <code class="docutils literal"><span class="pre">:initarg</span></code>
                                定义一个参数名。 <a class="footnote-reference" href="#id8" id="id4">[1]</a>
                                加入刚刚所说的两件事，现在我们的类定义变成：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defclass</span> <span class="nv">circle</span> <span class="p">()</span>
  <span class="p">((</span><span class="nv">radius</span> <span class="ss">:accessor</span> <span class="nv">circle-radius</span>
           <span class="ss">:initarg</span> <span class="ss">:radius</span>
           <span class="ss">:initform</span> <span class="mi">1</span><span class="p">)</span>
   <span class="p">(</span><span class="nv">center</span> <span class="ss">:accessor</span> <span class="nv">circle-center</span>
           <span class="ss">:initarg</span> <span class="ss">:center</span>
           <span class="ss">:initform</span> <span class="p">(</span><span class="nb">cons</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">))))</span>
</pre>
                                </div>
                              </div>
                              <p>现在当我们创建一个 <code class="docutils literal"><span class="pre">circle</span></code>
                                类的实例时，我们可以使用关键字参数 <code
                                  class="docutils literal"><span class="pre">:initarg</span></code> 给槽赋值，或是將槽的值设为 <code
                                  class="docutils literal"><span class="pre">:initform</span></code> 所指定的缺省值。</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre>&gt; (setf c (make-instance &#39;circle :radius 3))
#&lt;CIRCLE #XC2DE0E&gt;
&gt; (circle-radius c)
3
&gt; (circle-center c)
(0 . 0)
</pre>
                                </div>
                              </div>
                              <p>注意 <code class="docutils literal"><span class="pre">initarg</span></code> 的优先级比 <code
                                  class="docutils literal"><span class="pre">initform</span></code> 要高。</p>
                              <p>我们可以指定某些槽是共享的 ── 也就是每个产生出来的实例，共享槽的值都会是一样的。我们通过声明槽拥有 <code
                                  class="docutils literal"><span class="pre">:allocation</span> <span class="pre">:class</span></code>
                                来办到此事。（另一个办法是让一个槽有 <code
                                  class="docutils literal"><span class="pre">:allocation</span> <span class="pre">:instance</span></code>
                                ，但由于这是缺省设置，不需要特别再声明一次。）当我们在一个实例中，改变了共享槽的值，则其它实例共享槽也会获得相同的值。所以我们会想要使用共享槽来保存所有实例都有的相同属性。
                              </p>
                              <p>举例来说，假设我们想要模拟一群成人小报 (a flock of tabloids)的行为。（<strong>译注</strong>：可以看看<a
                                  class="reference external" href="http://tinyurl.com/9n4dckk">什么是
                                  tabloids</a>。）在我们的模拟中，我们想要能够表示一个事实，也就是当一家小报采用一个头条时，其它小报也会跟进的这个行为。我们可以通过让所有的实例共享一个槽来实现。若
                                <code class="docutils literal"><span class="pre">tabloid</span></code> 类别像下面这样定义，
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defclass</span> <span class="nv">tabloid</span> <span class="p">()</span>
  <span class="p">((</span><span class="nv">top-story</span> <span class="ss">:accessor</span> <span class="nv">tabloid-story</span>
              <span class="ss">:allocation</span> <span class="ss">:class</span><span class="p">)))</span>
</pre>
                                </div>
                              </div>
                              <p>那么如果我们创立两家小报，无论一家的头条是什么，另一家的头条也会是一样的：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre>&gt; (setf daily-blab (make-instance &#39;tabloid)
        unsolicited-mail (make-instance &#39;tabloid))
#&lt;TABLOID #x302000EFE5BD&gt;
&gt; (setf (tabloid-story daily-blab) &#39;adultery-of-senator)
ADULTERY-OF-SENATOR
&gt; (tabloid-story unsolicited-mail)
ADULTERY-OF-SENATOR
</pre>
                                </div>
                              </div>
                              <p><strong>译注</strong>： ADULTERY-OF-SENATOR 参议员的性丑闻。</p>
                              <p>若有给入 <code class="docutils literal"><span class="pre">:documentation</span></code>
                                属性的话，用来作为 <code class="docutils literal"><span class="pre">slot</span></code>
                                的文档字符串。通过指定一个 <code class="docutils literal"><span class="pre">:type</span></code>
                                ，你保证一个槽里只会有这种类型的元素。类型声明会在 13.3 节讲解。</p>
                            </div>
                            <div class="section" id="superclasses">
                              <h4>11.4 基类 (Superclasses)<a class="headerlink" href="#superclasses"
                                  title="Permalink to this headline">¶</a></h4>
                              <p><code class="docutils literal"><span class="pre">defclass</span></code>
                                接受的第二个参数是一个列出其基类的列表。一个类别继承了所有基类槽的联集。所以要是我们将 <code
                                  class="docutils literal"><span class="pre">screen-circle</span></code> 定义成 <code
                                  class="docutils literal"><span class="pre">circle</span></code> 与 <code
                                  class="docutils literal"><span class="pre">graphic</span></code> 的子类，</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defclass</span> <span class="nv">graphic</span> <span class="p">()</span>
  <span class="p">((</span><span class="nv">color</span> <span class="ss">:accessor</span> <span class="nv">graphic-color</span> <span class="ss">:initarg</span> <span class="ss">:color</span><span class="p">)</span>
   <span class="p">(</span><span class="nv">visible</span> <span class="ss">:accessor</span> <span class="nv">graphic-visible</span> <span class="ss">:initarg</span> <span class="ss">:visible</span>
            <span class="ss">:initform</span> <span class="no">t</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defclass</span> <span class="nv">screen-circle</span> <span class="p">(</span><span class="nv">circle</span> <span class="nv">graphic</span><span class="p">)</span> <span class="p">())</span>
</pre>
                                </div>
                              </div>
                              <p>则 <code class="docutils literal"><span class="pre">screen-circle</span></code>
                                的实例会有四个槽，分别从两个基类继承而来。一个类别不需要自己创建任何新槽； <code
                                  class="docutils literal"><span class="pre">screen-circle</span></code>
                                的存在，只是为了提供一个可创建同时从 <code class="docutils literal"><span class="pre">circle</span></code>
                                及 <code class="docutils literal"><span class="pre">graphic</span></code> 继承的实例。</p>
                              <p>访问器及 <code class="docutils literal"><span class="pre">:initargs</span></code> 参数可以用在
                                <code class="docutils literal"><span class="pre">screen-circle</span></code>
                                的实例，就如同它们也可以用在 <code class="docutils literal"><span class="pre">circle</span></code> 或
                                <code class="docutils literal"><span class="pre">graphic</span></code> 类别那般：
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">graphic-color</span> <span class="p">(</span><span class="nb">make-instance</span> <span class="ss">&#39;screen-circle</span>
                                <span class="ss">:color</span> <span class="ss">&#39;red</span> <span class="ss">:radius</span> <span class="mi">3</span><span class="p">))</span>
<span class="nv">RED</span>
</pre>
                                </div>
                              </div>
                              <p>我们可以使每一个 <code class="docutils literal"><span class="pre">screen-circle</span></code>
                                有某种缺省的颜色，通过在 <code class="docutils literal"><span class="pre">defclass</span></code>
                                里替这个槽指定一个 <code class="docutils literal"><span class="pre">:initform</span></code> ：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defclass</span> <span class="nv">screen-circle</span> <span class="p">(</span><span class="nv">circle</span> <span class="nv">graphic</span><span class="p">)</span>
  <span class="p">((</span><span class="nv">color</span> <span class="ss">:initform</span> <span class="ss">&#39;purple</span><span class="p">)))</span>
</pre>
                                </div>
                              </div>
                              <p>现在 <code class="docutils literal"><span class="pre">screen-circle</span></code>
                                的实例缺省会是紫色的：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">graphic-color</span> <span class="p">(</span><span class="nb">make-instance</span> <span class="ss">&#39;screen-circle</span><span class="p">))</span>
<span class="nv">PURPLE</span>
</pre>
                                </div>
                              </div>
                            </div>
                            <div class="section" id="precedence">
                              <h4>11.5 优先级 (Precedence)<a class="headerlink" href="#precedence"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>我们已经看过类别是怎样能有多个基类了。当一个实例的方法同时属于这个实例所属的几个类时，Lisp
                                需要某种方式来决定要使用哪个方法。优先级的重点在于确保这一切是以一种直观的方式发生的。</p>
                              <p>
                                每一个类别，都有一个优先级列表：一个将自身及自身的基类从最具体到最不具体所排序的列表。在目前看过的例子中，优先级还不是需要讨论的议题，但在更大的程序里，它会是一个需要考虑的议题。
                              </p>
                              <p>以下是一个更复杂的类别层级：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defclass</span> <span class="nv">sculpture</span> <span class="p">()</span> <span class="p">(</span><span class="nv">height</span> <span class="nv">width</span> <span class="nv">depth</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defclass</span> <span class="nv">statue</span> <span class="p">(</span><span class="nv">sclpture</span><span class="p">)</span> <span class="p">(</span><span class="nv">subject</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defclass</span> <span class="nv">metalwork</span> <span class="p">()</span> <span class="p">(</span><span class="nv">metal-type</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defclass</span> <span class="nv">casting</span> <span class="p">(</span><span class="nv">metalwork</span><span class="p">)</span> <span class="p">())</span>

<span class="p">(</span><span class="nb">defclass</span> <span class="nv">cast-statue</span> <span class="p">(</span><span class="nv">statue</span> <span class="nv">casting</span><span class="p">)</span> <span class="p">())</span>
</pre>
                                </div>
                              </div>
                              <p>图 11.3 包含了一个表示 <code
                                  class="docutils literal"><span class="pre">cast-statue</span></code> 类别及其基类的网络。</p>
                              <div class="figure">
                                <img alt="_images/Figure-11.3.png" src="_images/Figure-11.3.png" />
                              </div>
                              <p><strong>图 11.3: 类别层级</strong></p>
                              <p>要替一个类别建构一个这样的网络，从最底层用一个节点表示该类别开始。接著替类别最近的基类画上节点，其顺序根据 <code
                                  class="docutils literal"><span class="pre">defclass</span></code>
                                调用里的顺序由左至右画，再来给每个节点重复这个过程，直到你抵达一个类别，这个类别最近的基类是 <code
                                  class="docutils literal"><span class="pre">standard-object</span></code> ── 即传给 <code
                                  class="docutils literal"><span class="pre">defclass</span></code> 的第二个参数为 <code
                                  class="docutils literal"><span class="pre">()</span></code> 的类别。最后从这些类别往上建立链接，到表示
                                <code class="docutils literal"><span class="pre">standard-object</span></code>
                                节点为止，接著往上加一个表示类别 <code class="docutils literal"><span class="pre">t</span></code>
                                的节点与一个链接。结果会是一个网络，最顶与最下层各为一个点，如图 11.3 所示。
                              </p>
                              <p>一个类别的优先级列表可以通过如下步骤，遍历对应的网络计算出来：</p>
                              <ol class="arabic simple">
                                <li>从网络的底部开始。</li>
                                <li>往上走，遇到未探索的分支永远选最左边。</li>
                                <li>如果你将进入一个节点，你发现此节点右边也有一条路同样进入该节点时，则从该节点退后，重走刚刚的老路，直到回到一个节点，这个节点上有尚未探索的路径。接著返回步骤 2。
                                </li>
                                <li>当你抵达表示 <code class="docutils literal"><span class="pre">t</span></code>
                                  的节点时，遍历就结束了。你第一次进入每个节点的顺序就决定了节点在优先级列表的顺序。</li>
                              </ol>
                              <p>这个定义的结果之一（实际上讲的是规则 3）在优先级列表里，类别不会在其子类别出现前出现。</p>
                              <p>图 11.3 的箭头演示了一个网络是如何遍历的。由这个图所决定出的优先级列表为： <code
                                  class="docutils literal"><span class="pre">cast-statue</span></code> , <code
                                  class="docutils literal"><span class="pre">statue</span></code> , <code
                                  class="docutils literal"><span class="pre">sculpture</span></code> , <code
                                  class="docutils literal"><span class="pre">casting</span></code> , <code
                                  class="docutils literal"><span class="pre">metalwork</span></code> , <code
                                  class="docutils literal"><span class="pre">standard-object</span></code> , <code
                                  class="docutils literal"><span class="pre">t</span></code> 。有时候会用 <em>specific</em>
                                这个词，作为在一个给定的优先级列表中来引用类别的位置的速记法。优先级列表从最高优先级排序至最低优先级。</p>
                              <p>优先级的主要目的是，当一个通用函数 (generic
                                function)被调用时，决定要用哪个方法。这个过程在下一节讲述。另一个优先级重要的地方是，当一个槽从多个基类继承时。408 页的备注解释了当这情况发生时的应用规则。 <a
                                  class="reference external"
                                  href="http://acl.readthedocs.org/en/latest/zhCN/notes-cn.html#notes-183">λ</a></p>
                            </div>
                            <div class="section" id="generic-functions">
                              <h4>11.6 通用函数 (Generic Functions)<a class="headerlink" href="#generic-functions"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>一个通用函数 (generic function) 是由一个或多个方法组成的一个函数。方法可用 <code
                                  class="docutils literal"><span class="pre">defmethod</span></code> 来定义，与 <code
                                  class="docutils literal"><span class="pre">defun</span></code> 的定义形式类似：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defmethod</span> <span class="nv">combine</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">list</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p>现在 <code class="docutils literal"><span class="pre">combine</span></code>
                                有一个方法。若我们在此时调用 <code class="docutils literal"><span class="pre">combine</span></code>
                                ，我们会获得由传入的两个参数所组成的一个列表：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">combine</span> <span class="ss">&#39;a</span> <span class="ss">&#39;b</span><span class="p">)</span>
<span class="p">(</span><span class="nv">A</span> <span class="nv">B</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>到现在我们还没有做任何一般函数做不到的事情。一个通用函数不寻常的地方是，我们可以继续替它加入新的方法。</p>
                              <p>首先，我们定义一些可以让新的方法引用的类别：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defclass</span> <span class="nv">stuff</span> <span class="p">()</span> <span class="p">((</span><span class="nv">name</span> <span class="ss">:accessor</span> <span class="nv">name</span> <span class="ss">:initarg</span> <span class="ss">:name</span><span class="p">)))</span>
<span class="p">(</span><span class="nb">defclass</span> <span class="nv">ice-cream</span> <span class="p">(</span><span class="nv">stuff</span><span class="p">)</span> <span class="p">())</span>
<span class="p">(</span><span class="nb">defclass</span> <span class="nv">topping</span> <span class="p">(</span><span class="nv">stuff</span><span class="p">)</span> <span class="p">())</span>
</pre>
                                </div>
                              </div>
                              <p>这里定义了三个类别： <code class="docutils literal"><span class="pre">stuff</span></code>
                                ，只是一个有名字的东西，而 <code class="docutils literal"><span class="pre">ice-cream</span></code> 与
                                <code class="docutils literal"><span class="pre">topping</span></code> 是 <code
                                  class="docutils literal"><span class="pre">stuff</span></code> 的子类。
                              </p>
                              <p>现在下面是替 <code class="docutils literal"><span class="pre">combine</span></code> 定义的第二个方法：
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defmethod</span> <span class="nv">combine</span> <span class="p">((</span><span class="nv">ic</span> <span class="nv">ice-cream</span><span class="p">)</span> <span class="p">(</span><span class="nv">top</span> <span class="nv">topping</span><span class="p">))</span>
  <span class="p">(</span><span class="nb">format</span> <span class="no">nil</span> <span class="s">&quot;~A ice-cream with ~A topping.&quot;</span>
          <span class="p">(</span><span class="nv">name</span> <span class="nv">ic</span><span class="p">)</span>
          <span class="p">(</span><span class="nv">name</span> <span class="nv">top</span><span class="p">)))</span>
</pre>
                                </div>
                              </div>
                              <p>在这次 <code class="docutils literal"><span class="pre">defmethod</span></code>
                                的调用中，参数被特化了
                                (<em>specialized</em>)：每个出现在列表里的参数都有一个类别的名字。一个方法的特化指出它是应用至何种类别的参数。我们刚定义的方法仅能在传给 <code
                                  class="docutils literal"><span class="pre">combine</span></code> 的参数分别是 <code
                                  class="docutils literal"><span class="pre">ice-cream</span></code> 与 <code
                                  class="docutils literal"><span class="pre">topping</span></code> 的实例时。</p>
                              <p>而当一个通用函数被调用时， Lisp 是怎么决定要用哪个方法的？Lisp 会使用参数的类别与参数的特化匹配且优先级最高的方法。这表示若我们用 <code
                                  class="docutils literal"><span class="pre">ice-cream</span></code> 实例与 <code
                                  class="docutils literal"><span class="pre">topping</span></code> 实例去调用 <code
                                  class="docutils literal"><span class="pre">combine</span></code> 方法，我们会得到我们刚刚定义的方法：
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">combine</span> <span class="p">(</span><span class="nb">make-instance</span> <span class="ss">&#39;ice-cream</span> <span class="ss">:name</span> <span class="ss">&#39;fig</span><span class="p">)</span>
           <span class="p">(</span><span class="nb">make-instance</span> <span class="ss">&#39;topping</span> <span class="ss">:name</span> <span class="ss">&#39;treacle</span><span class="p">))</span>
<span class="s">&quot;FIG ice-cream with TREACLE topping&quot;</span>
</pre>
                                </div>
                              </div>
                              <p>但使用其他参数时，我们会得到我们第一次定义的方法：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">combine</span> <span class="mi">23</span> <span class="ss">&#39;skiddoo</span><span class="p">)</span>
<span class="p">(</span><span class="mi">23</span> <span class="nv">SKIDDOO</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>因为第一个方法的两个参数皆没有特化，它永远只有最低优先权，并永远是最后一个调用的方法。一个未特化的方法是一个安全手段，就像 <code
                                  class="docutils literal"><span class="pre">case</span></code> 表达式中的 <code
                                  class="docutils literal"><span class="pre">otherwise</span></code> 子句。</p>
                              <p>一个方法中，任何参数的组合都可以特化。在这个方法里，只有第一个参数被特化了：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defmethod</span> <span class="nv">combine</span> <span class="p">((</span><span class="nv">ic</span> <span class="nv">ice-cream</span><span class="p">)</span> <span class="nv">x</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">format</span> <span class="no">nil</span> <span class="s">&quot;~A ice-cream with ~A.&quot;</span>
          <span class="p">(</span><span class="nv">name</span> <span class="nv">ic</span><span class="p">)</span>
          <span class="nv">x</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p>若我们用一个 <code class="docutils literal"><span class="pre">ice-cream</span></code> 的实例以及一个
                                <code class="docutils literal"><span class="pre">topping</span></code> 的实例来调用 <code
                                  class="docutils literal"><span class="pre">combine</span></code>
                                ，我们仍然得到特化两个参数的方法，因为它是最具体的那个：
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">combine</span> <span class="p">(</span><span class="nb">make-instance</span> <span class="ss">&#39;ice-cream</span> <span class="ss">:name</span> <span class="ss">&#39;grape</span><span class="p">)</span>
           <span class="p">(</span><span class="nb">make-instance</span> <span class="ss">&#39;topping</span> <span class="ss">:name</span> <span class="ss">&#39;marshmallow</span><span class="p">))</span>
<span class="s">&quot;GRAPE ice-cream with MARSHMALLOW topping&quot;</span>
</pre>
                                </div>
                              </div>
                              <p>然而若第一个参数是 <code class="docutils literal"><span class="pre">ice-cream</span></code>
                                而第二个参数不是 <code class="docutils literal"><span class="pre">topping</span></code>
                                的实例的话，我们会得到刚刚上面所定义的那个方法：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">combine</span> <span class="p">(</span><span class="nb">make-instance</span> <span class="ss">&#39;ice-cream</span> <span class="ss">:name</span> <span class="ss">&#39;clam</span><span class="p">)</span>
           <span class="ss">&#39;reluctance</span><span class="p">)</span>
<span class="s">&quot;CLAM ice-cream with RELUCTANCE&quot;</span>
</pre>
                                </div>
                              </div>
                              <p>当一个通用函数被调用时，参数决定了一个或多个可用的方法 (<em>applicable</em>
                                methods)。如果在调用中的参数在参数的特化约定内，我们说一个方法是可用的。</p>
                              <p>
                                如果没有可用的方法，我们会得到一个错误。如果只有一个，它会被调用。如果多于一个，最具体的会被调用。最具体可用的方法是由调用传入参数所属类别的优先级所决定的。由左往右审视参数。如果有一个可用方法的第一个参数，此参数特化给某个类，其类的优先级高于其它可用方法的第一个参数，则此方法就是最具体的可用方法。平手时比较第二个参数，以此类推。
                                <a class="footnote-reference" href="#id9" id="id6">[2]</a>
                              </p>
                              <p>在前面的例子里，很容易看出哪个是最具体的可用方法，因为所有的对象都是单继承的。一个 <code
                                  class="docutils literal"><span class="pre">ice-cream</span></code> 的实例是，按顺序来， <code
                                  class="docutils literal"><span class="pre">ice-cream</span></code> ， <code
                                  class="docutils literal"><span class="pre">stuff</span></code> ， <code
                                  class="docutils literal"><span class="pre">standard-object</span></code> ， 以及 <code
                                  class="docutils literal"><span class="pre">t</span></code> 类别的成员。</p>
                              <p>方法不需要在由 <code class="docutils literal"><span class="pre">defclass</span></code>
                                定义的类别层级来做特化。他们也可以替类型做特化（更精准的说，可以反映出类型的类别）。以下是一个给 <code
                                  class="docutils literal"><span class="pre">combine</span></code> 用的方法，对数字做了特化：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defmethod</span> <span class="nv">combine</span> <span class="p">((</span><span class="nv">x</span> <span class="nc">number</span><span class="p">)</span> <span class="p">(</span><span class="nv">y</span> <span class="nc">number</span><span class="p">))</span>
  <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p>方法甚至可以对单一的对象做特化，用 <code class="docutils literal"><span class="pre">eql</span></code>
                                来决定：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defmethod</span> <span class="nv">combine</span> <span class="p">((</span><span class="nv">x</span> <span class="p">(</span><span class="nb">eql</span> <span class="ss">&#39;powder</span><span class="p">))</span> <span class="p">(</span><span class="nv">y</span> <span class="p">(</span><span class="nb">eql</span> <span class="ss">&#39;spark</span><span class="p">)))</span>
  <span class="ss">&#39;boom</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>单一对象特化的优先级比类别特化来得高。</p>
                              <p>方法可以像一般 Common Lisp 函数一样有复杂的参数列表，但所有组成通用函数方法的参数列表必须是一致的
                                (<em>congruent</em>)。参数的数量必须一致，同样数量的选择性参数（如果有的话），要嘛一起使用 <code
                                  class="docutils literal"><span class="pre">&amp;rest</span></code> 或是 <code
                                  class="docutils literal"><span class="pre">&amp;key</span></code>
                                参数，或者一起不要用。下面的参数列表对是全部一致的，</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nv">x</span><span class="p">)</span>             <span class="p">(</span><span class="nv">a</span><span class="p">)</span>
<span class="p">(</span><span class="nv">x</span> <span class="k">&amp;optional</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="nv">a</span> <span class="k">&amp;optional</span> <span class="nv">b</span><span class="p">)</span>
<span class="p">(</span><span class="nv">x</span> <span class="nv">y</span> <span class="k">&amp;rest</span> <span class="nv">z</span><span class="p">)</span>   <span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="k">&amp;key</span> <span class="nv">c</span><span class="p">)</span>
<span class="p">(</span><span class="nv">x</span> <span class="nv">y</span> <span class="k">&amp;key</span> <span class="nv">z</span><span class="p">)</span>    <span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="k">&amp;key</span> <span class="nv">c</span> <span class="nv">d</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>而下列的参数列表对不是一致的：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nv">x</span><span class="p">)</span>             <span class="p">(</span><span class="nv">a</span> <span class="nv">b</span><span class="p">)</span>
<span class="p">(</span><span class="nv">x</span> <span class="k">&amp;optional</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="nv">a</span> <span class="k">&amp;optional</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">)</span>
<span class="p">(</span><span class="nv">x</span> <span class="k">&amp;optional</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="nv">a</span> <span class="k">&amp;rest</span> <span class="nv">b</span><span class="p">)</span>
<span class="p">(</span><span class="nv">x</span> <span class="k">&amp;key</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>    <span class="p">(</span><span class="nv">a</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>只有必要参数可以被特化。所以每个方法都可以通过名字及必要参数的特化独一无二地识别出来。如果我们定义另一个方法，有着同样的修饰符及特化，它会覆写掉原先的。所以通过说明</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defmethod</span> <span class="nv">combine</span> <span class="p">((</span><span class="nv">x</span> <span class="p">(</span><span class="nb">eql</span> <span class="ss">&#39;powder</span><span class="p">))</span> <span class="p">(</span><span class="nv">y</span> <span class="p">(</span><span class="nb">eql</span> <span class="ss">&#39;spark</span><span class="p">)))</span>
  <span class="ss">&#39;kaboom</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>我们重定义了当 <code class="docutils literal"><span class="pre">combine</span></code> 方法的参数是
                                <code class="docutils literal"><span class="pre">powder</span></code> 与 <code
                                  class="docutils literal"><span class="pre">spark</span></code> 时， <code
                                  class="docutils literal"><span class="pre">combine</span></code> 方法干了什么事儿。
                              </p>
                            </div>
                            <div class="section" id="auxiliary-methods">
                              <h4>11.7 辅助方法 (Auxiliary Methods)<a class="headerlink" href="#auxiliary-methods"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>方法可以通过如 <code class="docutils literal"><span class="pre">:before</span></code> ， <code
                                  class="docutils literal"><span class="pre">:after</span></code> 以及 <code
                                  class="docutils literal"><span class="pre">:around</span></code> 等辅助方法来增强。 <code
                                  class="docutils literal"><span class="pre">:before</span></code> 方法允许我们说：“嘿首先，先做这个。”
                                最具体的 <code class="docutils literal"><span class="pre">:before</span></code>
                                方法<strong>优先</strong>被调用，作为其它方法调用的序幕 (prelude)。 <code
                                  class="docutils literal"><span class="pre">:after</span></code> 方法允许我们说 “P.S. 也做这个。”
                                最具体的 <code class="docutils literal"><span class="pre">:after</span></code>
                                方法<strong>最后</strong>被调用，作为其它方法调用的闭幕 (epilogue)。在这之间，我们运行的是在这之前仅视为方法的方法，而准确地说应该叫做主方法
                                (<em>primary method</em>)。这个主方法调用所返回的值为方法的返回值，甚至 <code
                                  class="docutils literal"><span class="pre">:after</span></code> 方法在之后被调用也不例外。</p>
                              <p><code class="docutils literal"><span class="pre">:before</span></code> 与 <code
                                  class="docutils literal"><span class="pre">:after</span></code> 方法允许我们将新的行为包在调用主方法的周围。
                                <code class="docutils literal"><span class="pre">:around</span></code>
                                方法提供了一个更戏剧的方式来办到这件事。如果 <code
                                  class="docutils literal"><span class="pre">:around</span></code> 方法存在的话，会调用的是 <code
                                  class="docutils literal"><span class="pre">:around</span></code> 方法而不是主方法。则根据它自己的判断，
                                <code class="docutils literal"><span class="pre">:around</span></code> 方法自己可能会调用主方法（通过函数
                                <code class="docutils literal"><span class="pre">call-next-method</span></code>
                                ，这也是这个函数存在的目的）。
                              </p>
                              <p>这称为标准方法组合机制 (<em>standard method combination</em>)。在标准方法组合机制里，调用一个通用函数会调用</p>
                              <ol class="arabic">
                                <li>
                                  <p class="first">最具体的 <code
                                      class="docutils literal"><span class="pre">:around</span></code> 方法，如果有的话。</p>
                                </li>
                                <li>
                                  <p class="first">否则，依序，</p>
                                  <blockquote>
                                    <div>
                                      <ol class="loweralpha simple">
                                        <li>所有的 <code class="docutils literal"><span class="pre">:before</span></code>
                                          方法，从最具体到最不具体。</li>
                                        <li>最具体的主方法</li>
                                        <li>所有的 <code class="docutils literal"><span class="pre">:after</span></code>
                                          方法，从最不具体到最具体</li>
                                      </ol>
                                    </div>
                                  </blockquote>
                                </li>
                              </ol>
                              <p>返回值为 <code class="docutils literal"><span class="pre">:around</span></code> 方法的返回值（情况
                                1）或是最具体的主方法的返回值（情况 2）。</p>
                              <p>辅助方法通过在 <code class="docutils literal"><span class="pre">defmethod</span></code>
                                调用中，在方法名后加上一个修饰关键字 (qualifying keyword)来定义。如果我们替 <code
                                  class="docutils literal"><span class="pre">speaker</span></code> 类别定义一个主要的 <code
                                  class="docutils literal"><span class="pre">speak</span></code> 方法如下：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defclass</span> <span class="nv">speaker</span> <span class="p">()</span> <span class="p">())</span>

<span class="p">(</span><span class="nb">defmethod</span> <span class="nv">speak</span> <span class="p">((</span><span class="nv">s</span> <span class="nv">speaker</span><span class="p">)</span> <span class="nb">string</span><span class="p">)</span>
        <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;~A&quot;</span> <span class="nb">string</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p>则使用 <code class="docutils literal"><span class="pre">speaker</span></code> 实例来调用 <code
                                  class="docutils literal"><span class="pre">speak</span></code> 仅印出第二个参数：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">speak</span> <span class="p">(</span><span class="nb">make-instance</span> <span class="ss">&#39;speaker</span><span class="p">)</span>
         <span class="s">&quot;I&#39;m hungry&quot;</span><span class="p">)</span>
<span class="nv">I</span><span class="ss">&#39;m</span> <span class="nv">hungry</span>
<span class="no">NIL</span>
</pre>
                                </div>
                              </div>
                              <p>通过定义一个 <code class="docutils literal"><span class="pre">intellectual</span></code>
                                子类，将主要的 <code class="docutils literal"><span class="pre">speak</span></code> 方法用 <code
                                  class="docutils literal"><span class="pre">:before</span></code> 与 <code
                                  class="docutils literal"><span class="pre">:after</span></code> 方法包起来，</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defclass</span> <span class="nv">intellectual</span> <span class="p">(</span><span class="nv">speaker</span><span class="p">)</span> <span class="p">())</span>

<span class="p">(</span><span class="nb">defmethod</span> <span class="nv">speak</span> <span class="ss">:before</span> <span class="p">((</span><span class="nv">i</span> <span class="nv">intellectual</span><span class="p">)</span> <span class="nb">string</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">princ</span> <span class="s">&quot;Perhaps &quot;</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defmethod</span> <span class="nv">speak</span> <span class="ss">:after</span> <span class="p">((</span><span class="nv">i</span> <span class="nv">intellectual</span><span class="p">)</span> <span class="nb">string</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">princ</span> <span class="s">&quot; in some sense&quot;</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p>我们可以创建一个说话前后带有惯用语的演讲者：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">speak</span> <span class="p">(</span><span class="nb">make-instance</span> <span class="ss">&#39;intellectual</span><span class="p">)</span>
         <span class="s">&quot;I am hungry&quot;</span><span class="p">)</span>
<span class="nv">Perhaps</span> <span class="nv">I</span> <span class="nv">am</span> <span class="nv">hungry</span> <span class="nv">in</span> <span class="nb">some</span> <span class="nv">sense</span>
<span class="no">NIL</span>
</pre>
                                </div>
                              </div>
                              <p>如同先前标准方法组合机制所述，所有的 <code
                                  class="docutils literal"><span class="pre">:before</span></code> 及 <code
                                  class="docutils literal"><span class="pre">:after</span></code> 方法都被调用了。所以如果我们替 <code
                                  class="docutils literal"><span class="pre">speaker</span></code> 基类定义 <code
                                  class="docutils literal"><span class="pre">:before</span></code> 或 <code
                                  class="docutils literal"><span class="pre">:after</span></code> 方法，</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defmethod</span> <span class="nv">speak</span> <span class="ss">:before</span> <span class="p">((</span><span class="nv">s</span> <span class="nv">speaker</span><span class="p">)</span> <span class="nb">string</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">princ</span> <span class="s">&quot;I think &quot;</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p>无论是哪个 <code class="docutils literal"><span class="pre">:before</span></code> 或 <code
                                  class="docutils literal"><span class="pre">:after</span></code>
                                方法被调用，整个通用函数所返回的值，是最具体主方法的返回值 ── 在这个情况下，为 <code
                                  class="docutils literal"><span class="pre">format</span></code> 函数所返回的 <code
                                  class="docutils literal"><span class="pre">nil</span></code> 。</p>
                              <p>而在有 <code class="docutils literal"><span class="pre">:around</span></code>
                                方法时，情况就不一样了。如果有一个替传入通用函数特别定义的 <code
                                  class="docutils literal"><span class="pre">:around</span></code> 方法，则优先调用 <code
                                  class="docutils literal"><span class="pre">:around</span></code> 方法，而其它的方法要看 <code
                                  class="docutils literal"><span class="pre">:around</span></code> 方法让不让它们被运行。一个 <code
                                  class="docutils literal"><span class="pre">:around</span></code> 或主方法，可以通过调用 <code
                                  class="docutils literal"><span class="pre">call-next-method</span></code>
                                来调用下一个方法。在调用下一个方法前，它使用 <code
                                  class="docutils literal"><span class="pre">next-method-p</span></code> 来检查是否有下个方法可调用。
                              </p>
                              <p>有了 <code class="docutils literal"><span class="pre">:around</span></code>
                                方法，我们可以定义另一个，更谨慎的， <code
                                  class="docutils literal"><span class="pre">speaker</span></code> 的子类别：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defclass</span> <span class="nv">courtier</span> <span class="p">(</span><span class="nv">speaker</span><span class="p">)</span> <span class="p">())</span>

<span class="p">(</span><span class="nb">defmethod</span> <span class="nv">speak</span> <span class="ss">:around</span> <span class="p">((</span><span class="nv">c</span> <span class="nv">courtier</span><span class="p">)</span> <span class="nb">string</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;Does the King believe that ~A?&quot;</span> <span class="nb">string</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">eql</span> <span class="p">(</span><span class="nb">read</span><span class="p">)</span> <span class="ss">&#39;yes</span><span class="p">)</span>
      <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">next-method-p</span><span class="p">)</span> <span class="p">(</span><span class="nb">call-next-method</span><span class="p">))</span>
      <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;Indeed, it is a preposterous idea. ~%&quot;</span><span class="p">))</span>
  <span class="ss">&#39;bow</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>当传给 <code class="docutils literal"><span class="pre">speak</span></code> 的第一个参数是 <code
                                  class="docutils literal"><span class="pre">courtier</span></code> 类的实例时，朝臣
                                (courtier)的舌头有了 <code class="docutils literal"><span class="pre">:around</span></code>
                                方法保护，就不会被割掉了：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">speak</span> <span class="p">(</span><span class="nb">make-instance</span> <span class="ss">&#39;courtier</span><span class="p">)</span> <span class="s">&quot;kings will last&quot;</span><span class="p">)</span>
<span class="nv">Does</span> <span class="k">the</span> <span class="nv">King</span> <span class="nv">believe</span> <span class="nv">that</span> <span class="nv">kings</span> <span class="nv">will</span> <span class="nv">last?</span> <span class="nv">yes</span>
<span class="nv">I</span> <span class="nv">think</span> <span class="nv">kings</span> <span class="nv">will</span> <span class="nb">last</span>
<span class="nv">BOW</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="nv">speak</span> <span class="p">(</span><span class="nb">make-instance</span> <span class="ss">&#39;courtier</span><span class="p">)</span> <span class="s">&quot;kings will last&quot;</span><span class="p">)</span>
<span class="nv">Does</span> <span class="k">the</span> <span class="nv">King</span> <span class="nv">believe</span> <span class="nv">that</span> <span class="nv">kings</span> <span class="nv">will</span> <span class="nv">last?</span> <span class="nv">no</span>
<span class="nv">Indeed,</span> <span class="nv">it</span> <span class="nv">is</span> <span class="nv">a</span> <span class="nv">preposterous</span> <span class="nv">idea.</span>
<span class="nv">BOW</span>
</pre>
                                </div>
                              </div>
                              <p>记得由 <code class="docutils literal"><span class="pre">:around</span></code>
                                方法所返回的值即通用函数的返回值，这与 <code
                                  class="docutils literal"><span class="pre">:before</span></code> 与 <code
                                  class="docutils literal"><span class="pre">:after</span></code> 方法的返回值不一样。</p>
                            </div>
                            <div class="section" id="method-combination">
                              <h4>11.8 方法组合机制 (Method Combination)<a class="headerlink" href="#method-combination"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>在标准方法组合中，只有最具体的主方法会被调用（虽然它可以通过 <code
                                  class="docutils literal"><span class="pre">call-next-method</span></code>
                                来调用其它方法）。但我们可能会想要把所有可用的主方法的结果汇总起来。</p>
                              <p>用其它组合手段来定义方法也是有可能的 ── 举例来说，一个返回所有可用主方法的和的通用函数。<em>操作符</em>
                                (<em>Operator</em>)方法组合可以这么理解，想像它是 Lisp 表达式的求值后的结果，其中 Lisp
                                表达式的第一个元素是某个操作符，而参数是按照具体性调用可用主方法的结果。如果我们定义 <code
                                  class="docutils literal"><span class="pre">price</span></code> 使用 <code
                                  class="docutils literal"><span class="pre">+</span></code> 来组合数值的通用函数，并且没有可用的 <code
                                  class="docutils literal"><span class="pre">:around</span></code> 方法，它会如它所定义的方式动作：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre>(defun price (&amp;rest args)
  (+ (apply 〈most specific primary method〉 args)
     .
     .
     .
     (apply 〈least specific primary method〉 args)))
</pre>
                                </div>
                              </div>
                              <p>如果有可用的 <code class="docutils literal"><span class="pre">:around</span></code>
                                方法的话，它们根据优先级决定，就像是标准方法组合那样。在操作符方法组合里，一个 <code
                                  class="docutils literal"><span class="pre">around</span></code> 方法仍可以通过 <code
                                  class="docutils literal"><span class="pre">call-next-method</span></code>
                                调用下个方法。然而主方法就不可以使用 <code
                                  class="docutils literal"><span class="pre">call-next-method</span></code> 了。</p>
                              <p>我们可以指定一个通用函数的方法组合所要使用的类型，借由在 <code
                                  class="docutils literal"><span class="pre">defgeneric</span></code> 调用里加入一个 <code
                                  class="docutils literal"><span class="pre">method-combination</span></code> 子句：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defgeneric</span> <span class="nv">price</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span>
  <span class="p">(</span><span class="ss">:method-combination</span> <span class="nb">+</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p>现在 <code class="docutils literal"><span class="pre">price</span></code> 方法会使用 <code
                                  class="docutils literal"><span class="pre">+</span></code> 方法组合；任何替 <code
                                  class="docutils literal"><span class="pre">price</span></code> 定义的 <code
                                  class="docutils literal"><span class="pre">defmethod</span></code> 必须有 <code
                                  class="docutils literal"><span class="pre">+</span></code> 来作为第二个参数。如果我们使用 <code
                                  class="docutils literal"><span class="pre">price</span></code> 来定义某些类型，</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defclass</span> <span class="nv">jacket</span> <span class="p">()</span> <span class="p">())</span>
<span class="p">(</span><span class="nb">defclass</span> <span class="nv">trousers</span> <span class="p">()</span> <span class="p">())</span>
<span class="p">(</span><span class="nb">defclass</span> <span class="nv">suit</span> <span class="p">(</span><span class="nv">jacket</span> <span class="nv">trousers</span><span class="p">)</span> <span class="p">())</span>

<span class="p">(</span><span class="nb">defmethod</span> <span class="nv">price</span> <span class="nb">+</span> <span class="p">((</span><span class="nv">jk</span> <span class="nv">jacket</span><span class="p">))</span> <span class="mi">350</span><span class="p">)</span>
<span class="p">(</span><span class="nb">defmethod</span> <span class="nv">price</span> <span class="nb">+</span> <span class="p">((</span><span class="nv">tr</span> <span class="nv">trousers</span><span class="p">))</span> <span class="mi">200</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>则可获得一件正装的价钱，也就是所有可用方法的总和：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">price</span> <span class="p">(</span><span class="nb">make-instance</span> <span class="ss">&#39;suit</span><span class="p">))</span>
<span class="mi">550</span>
</pre>
                                </div>
                              </div>
                              <p>下列符号可以用来作为 <code class="docutils literal"><span class="pre">defmethod</span></code>
                                的第二个参数或是作为 <code class="docutils literal"><span class="pre">defgeneric</span></code>
                                调用中，<code class="docutils literal"><span class="pre">method-combination</span></code>
                                的选项：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">+</span>    <span class="nb">and</span>    <span class="nb">append</span>    <span class="nb">list</span>    <span class="nb">max</span>    <span class="nb">min</span>    <span class="nb">nconc</span>    <span class="nb">or</span>    <span class="k">progn</span>
</pre>
                                </div>
                              </div>
                              <p>你也可以使用 <code class="docutils literal"><span class="pre">standard</span></code> ，yields
                                标准方法组合。</p>
                              <p>一旦你指定了通用函数要用何种方法组合，所有替该函数定义的方法必须用同样的机制。而现在如果我们试著使用另个操作符（ <code
                                  class="docutils literal"><span class="pre">:before</span></code> 或 <code
                                  class="docutils literal"><span class="pre">after</span></code> ）作为 <code
                                  class="docutils literal"><span class="pre">defmethod</span></code> 给 <code
                                  class="docutils literal"><span class="pre">price</span></code>
                                的第二个参数，则会抛出一个错误。如果我们想要改变 <code
                                  class="docutils literal"><span class="pre">price</span></code> 的方法组合机制，我们需要通过调用 <code
                                  class="docutils literal"><span class="pre">fmakunbound</span></code> 来移除整个通用函数。</p>
                            </div>
                            <div class="section" id="encapsulation">
                              <h4>11.9 封装 (Encapsulation)<a class="headerlink" href="#encapsulation"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>
                                面向对象的语言通常会提供某些手段，来区别对象的表示法以及它们给外在世界存取的介面。隐藏实现细节带来两个优点：你可以改变实现方式，而不影响对象对外的样子，而你可以保护对象在可能的危险方面被改动。隐藏细节有时候被称为封装
                                (<em>encapsulated</em>)。</p>
                              <p>虽然封装通常与面向对象编程相关联，但这两个概念其实是没相干的。你可以只拥有其一，而不需要另一个。我们已经在 108 页 (<strong>译注：</strong> 6.5
                                小节。)看过一个小规模的封装例子。函数 <code class="docutils literal"><span class="pre">stamp</span></code>
                                及 <code class="docutils literal"><span class="pre">reset</span></code>
                                通过共享一个计数器工作，但调用时我们不需要知道这个计数器，也保护我们不可直接修改它。</p>
                              <p>在 Common Lisp 里，包是标准的手段来区分公开及私有的信息。要限制某个东西的存取，我们将它放在另一个包里，并且针对外部介面，仅输出需要用的名字。</p>
                              <p>我们可以通过输出可被改动的名字，来封装一个槽，但不是槽的名字。举例来说，我们可以定义一个 <code
                                  class="docutils literal"><span class="pre">counter</span></code> 类别，以及相关的 <code
                                  class="docutils literal"><span class="pre">increment</span></code> 及 <code
                                  class="docutils literal"><span class="pre">clear</span></code> 方法如下：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defpackage</span> <span class="s">&quot;CTR&quot;</span>
  <span class="p">(</span><span class="ss">:use</span> <span class="s">&quot;COMMON-LISP&quot;</span><span class="p">)</span>
  <span class="p">(</span><span class="ss">:export</span> <span class="s">&quot;COUNTER&quot;</span> <span class="s">&quot;INCREMENT&quot;</span> <span class="s">&quot;CLEAR&quot;</span><span class="p">))</span>

<span class="p">(</span><span class="nb">in-package</span> <span class="nv">ctr</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defclass</span> <span class="nv">counter</span> <span class="p">()</span> <span class="p">((</span><span class="nv">state</span> <span class="ss">:initform</span> <span class="mi">0</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defmethod</span> <span class="nv">increment</span> <span class="p">((</span><span class="nv">c</span> <span class="nv">counter</span><span class="p">))</span>
  <span class="p">(</span><span class="nb">incf</span> <span class="p">(</span><span class="nb">slot-value</span> <span class="nv">c</span> <span class="ss">&#39;state</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defmethod</span> <span class="nv">clear</span> <span class="p">((</span><span class="nv">c</span> <span class="nv">counter</span><span class="p">))</span>
  <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nb">slot-value</span> <span class="nv">c</span> <span class="ss">&#39;state</span><span class="p">)</span> <span class="mi">0</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p>在这个定义下，在包外部的代码只能够创造 <code
                                  class="docutils literal"><span class="pre">counter</span></code> 的实例，并调用 <code
                                  class="docutils literal"><span class="pre">increment</span></code> 及 <code
                                  class="docutils literal"><span class="pre">clear</span></code> 方法，但不能够存取 <code
                                  class="docutils literal"><span class="pre">state</span></code> 。</p>
                              <p>如果你想要更进一步区别类的内部及外部介面，并使其不可能存取一个槽所存的值，你也可以这么做。只要在你将所有需要引用它的代码定义完，将槽的名字 unintern：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">unintern</span> <span class="ss">&#39;state</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>则没有任何合法的、其它的办法，从任何包来引用到这个槽。 <a class="reference external"
                                  href="http://acl.readthedocs.org/en/latest/zhCN/notes-cn.html#notes-191">λ</a></p>
                            </div>
                            <div class="section" id="two-models">
                              <h4>11.10 两种模型 (Two Models)<a class="headerlink" href="#two-models"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>面向对象编程是一个令人疑惑的话题，部分的原因是因为有两种实现方式：消息传递模型 (message-passing model)与通用函数模型 (generic
                                function model)。一开始先有的消息传递。通用函数是广义的消息传递。</p>
                              <p>在消息传递模型里，方法属于对象，且方法的继承与槽的继承概念一样。要找到一个物体的面积，我们传给它一个 <code
                                  class="docutils literal"><span class="pre">area</span></code> 消息：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nv">tell</span> <span class="nv">obj</span> <span class="nv">area</span>
</pre>
                                </div>
                              </div>
                              <p>而这调用了任何对象 <code class="docutils literal"><span class="pre">obj</span></code> 所拥有或继承来的
                                area 方法。</p>
                              <p>有时候我们需要传入额外的参数。举例来说，一个 <code
                                  class="docutils literal"><span class="pre">move</span></code>
                                方法接受一个说明要移动多远的参数。如我我们想要告诉 <code
                                  class="docutils literal"><span class="pre">obj</span></code> 移动 10 个单位，我们可以传下面的消息：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nv">move</span> <span class="nv">obj</span> <span class="mi">10</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>消息传递模型的局限性变得清晰。在消息传递模型里，我们仅特化 (specialize) 第一个参数。
                                牵扯到多对象时，没有规则告诉方法该如何处理 ── 而对象回应消息的这个模型使得这更加难处理了。</p>
                              <p>在消息传递模型里，方法是对象所有的，而在通用函数模型里，方法是特别为对象打造的 (specialized)。
                                如果我们仅特化第一个参数，那么通用函数模型和消息传递模型就是一样的。但在通用函数模型里，我们可以更进一步，要特化几个参数就几个。这也表示了，功能上来说，消息传递模型是通用函数模型的子集。如果你有通用函数模型，你可以仅特化第一个参数来模拟出消息传递模型。
                              </p>
                            </div>
                            <div class="section" id="chapter-11-summary">
                              <h4>Chapter 11 总结 (Summary)<a class="headerlink" href="#chapter-11-summary"
                                  title="Permalink to this headline">¶</a></h4>
                              <ol class="arabic simple">
                                <li>在面向对象编程中，函数 <code class="docutils literal"><span class="pre">f</span></code> 通过定义拥有
                                  <code class="docutils literal"><span class="pre">f</span></code>
                                  方法的对象来隐式地定义。对象从它们的父母继承方法。
                                </li>
                                <li>定义一个类别就像是定义一个结构，但更加啰嗦。一个共享的槽属于一整个类别。</li>
                                <li>一个类别从基类中继承槽。</li>
                                <li>一个类别的祖先被排序成一个优先级列表。理解优先级算法最好的方式就是通过视觉。</li>
                                <li>一个通用函数由一个给定名称的所有方法所组成。一个方法通过名称及特化参数来识别。参数的优先级决定了当调用一个通用函数时会使用哪个方法。</li>
                                <li>方法可以通过辅助方法来增强。标准方法组合机制意味著如果有 <code
                                    class="docutils literal"><span class="pre">:around</span></code> 方法的话就调用它；否则依序调用
                                  <code class="docutils literal"><span class="pre">:before</span></code> ，最具体的主方法以及
                                  <code class="docutils literal"><span class="pre">:after</span></code> 方法。
                                </li>
                                <li>在操作符方法组合机制中，所有的主方法都被视为某个操作符的参数。</li>
                                <li>封装可以通过包来实现。</li>
                              </ol>
                              <ol class="arabic simple" start="10">
                                <li>面向对象编程有两个模型。通用函数模型是广义的消息传递模型。</li>
                              </ol>
                            </div>
                            <div class="section" id="chapter-11-exercises">
                              <h4>Chapter 11 练习 (Exercises)<a class="headerlink" href="#chapter-11-exercises"
                                  title="Permalink to this headline">¶</a></h4>
                              <ol class="arabic simple">
                                <li>替图 11.2 所定义的类定义访问器、 initforms 以及 initargs 。重写相关的代码使其再也不用调用 <code
                                    class="docutils literal"><span class="pre">slot-value</span></code> 。</li>
                                <li>重写图 9.5 的代码，使得球体与点为类别，而 <code
                                    class="docutils literal"><span class="pre">intersect</span></code> 及 <code
                                    class="docutils literal"><span class="pre">normal</span></code> 为通用函数。</li>
                                <li>假设有若干类别定义如下：</li>
                              </ol>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defclass</span> <span class="nv">a</span> <span class="p">(</span><span class="nv">c</span> <span class="nv">d</span><span class="p">)</span>   <span class="o">...</span><span class="p">)</span>  <span class="p">(</span><span class="nb">defclass</span> <span class="nv">e</span> <span class="p">()</span>  <span class="o">...</span><span class="p">)</span>
<span class="p">(</span><span class="nb">defclass</span> <span class="nv">b</span> <span class="p">(</span><span class="nv">d</span> <span class="nv">c</span><span class="p">)</span>   <span class="o">...</span><span class="p">)</span>  <span class="p">(</span><span class="nb">defclass</span> <span class="nv">f</span> <span class="p">(</span><span class="nv">h</span><span class="p">)</span> <span class="o">...</span><span class="p">)</span>
<span class="p">(</span><span class="nb">defclass</span> <span class="nv">c</span> <span class="p">()</span>      <span class="o">...</span><span class="p">)</span>  <span class="p">(</span><span class="nb">defclass</span> <span class="nv">g</span> <span class="p">(</span><span class="nv">h</span><span class="p">)</span> <span class="o">...</span><span class="p">)</span>
<span class="p">(</span><span class="nb">defclass</span> <span class="nv">d</span> <span class="p">(</span><span class="nv">e</span> <span class="nv">f</span> <span class="nv">g</span><span class="p">)</span> <span class="o">...</span><span class="p">)</span>  <span class="p">(</span><span class="nb">defclass</span> <span class="nv">h</span> <span class="p">()</span>  <span class="o">...</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <ol class="loweralpha simple">
                                <li>画出表示类别 <code class="docutils literal"><span class="pre">a</span></code> 祖先的网络以及列出
                                  <code class="docutils literal"><span class="pre">a</span></code> 的实例归属的类别，从最相关至最不相关排列。
                                </li>
                                <li>替类别 <code class="docutils literal"><span class="pre">b</span></code> 也做 (a) 小题的要求。
                                </li>
                              </ol>
                              <ol class="arabic simple" start="4">
                                <li>假定你已经有了下列函数：</li>
                              </ol>
                              <p><code class="docutils literal"><span class="pre">precedence</span></code>
                                ：接受一个对象并返回其优先级列表，列表由最具体至最不具体的类组成。</p>
                              <p><code class="docutils literal"><span class="pre">methods</span></code>
                                ：接受一个通用函数并返回一个列出所有方法的列表。</p>
                              <p><code class="docutils literal"><span class="pre">specializations</span></code>
                                ：接受一个方法并返回一个列出所有特化参数的列表。返回列表中的每个元素是类别或是这种形式的列表 <code
                                  class="docutils literal"><span class="pre">(eql</span> <span class="pre">x)</span></code>
                                ，或是 <code class="docutils literal"><span class="pre">t</span></code> （表示该参数没有被特化）。</p>
                              <p>使用这些函数（不要使用 <code
                                  class="docutils literal"><span class="pre">compute-applicable-methods</span></code> 及
                                <code class="docutils literal"><span class="pre">find-method</span></code> ），定义一个函数
                                <code class="docutils literal"><span class="pre">most-spec-app-meth</span></code>
                                ，该函数接受一个通用函数及一个列出此函数被调用过的参数，如果有最相关可用的方法的话，返回它。
                              </p>
                              <ol class="arabic simple" start="5">
                                <li>不要改变通用函数 <code class="docutils literal"><span class="pre">area</span></code> 的行为（图
                                  11.2），</li>
                                <li>举一个只有通用函数的第一个参数被特化会很难解决的问题的例子。</li>
                              </ol>
                              <p class="rubric">脚注</p>
                              <table class="docutils footnote" frame="void" id="id8" rules="none">
                                <colgroup>
                                  <col class="label" />
                                  <col />
                                </colgroup>
                                <tbody valign="top">
                                  <tr>
                                    <td class="label"><a class="fn-backref" href="#id4">[1]</a></td>
                                    <td>Initarg 的名称通常是关键字，但不需要是。</td>
                                  </tr>
                                </tbody>
                              </table>
                              <table class="docutils footnote" frame="void" id="id9" rules="none">
                                <colgroup>
                                  <col class="label" />
                                  <col />
                                </colgroup>
                                <tbody valign="top">
                                  <tr>
                                    <td class="label"><a class="fn-backref" href="#id6">[2]</a></td>
                                    <td>我们不可能比较完所有的参数而仍有平手情形存在，因为这样我们会有两个有着同样特化的方法。这是不可能的，因为第二个的定义会覆写掉第一个。</td>
                                  </tr>
                                </tbody>
                              </table>
                            </div>
                          </div>
                          <div class="section">
                            <h3 id="12">第十二章：结构</h3>
                            <p>3.3 节中介绍了 Lisp 如何使用指针允许我们将任何值放到任何地方。这种说法是完全有可能的，但这并不一定都是好事。</p>
                            <p>例如，一个对象可以是它自已的一个元素。这是好事还是坏事，取决于程序员是不是有意这样设计的。</p>
                            <div class="section" id="shared-structure">
                              <h4>12.1 共享结构 (Shared Structure)<a class="headerlink" href="#shared-structure"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>多个列表可以共享 <code class="docutils literal"><span class="pre">cons</span></code>
                                。在最简单的情况下，一个列表可以是另一个列表的一部分。</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">setf</span> <span class="nv">part</span> <span class="p">(</span><span class="nb">list</span> <span class="ss">&#39;b</span> <span class="ss">&#39;c</span><span class="p">))</span>
<span class="p">(</span><span class="nv">B</span> <span class="nv">C</span><span class="p">)</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="nb">setf</span> <span class="nv">whole</span> <span class="p">(</span><span class="nb">cons</span> <span class="ss">&#39;a</span> <span class="nv">part</span><span class="p">))</span>
<span class="p">(</span><span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <div class="figure">
                                <img alt="_images/Figure-12.1.png" src="_images/Figure-12.1.png" />
                              </div>
                              <p><strong>图 12.1 共享结构</strong></p>
                              <p>执行上述操作后，第一个 <code class="docutils literal"><span class="pre">cons</span></code> 是第二个
                                <code class="docutils literal"><span class="pre">cons</span></code> 的一部分 (事实上，是第二个 <code
                                  class="docutils literal"><span class="pre">cons</span></code> 的 <code
                                  class="docutils literal"><span class="pre">cdr</span></code> )。在这样的情况下，我们说，这两个列表是共享结构
                                (Share Structure)。这两个列表的基本结构如图 12.1 所示。
                              </p>
                              <p>其中，第一个 <code class="docutils literal"><span class="pre">cons</span></code> 是第二个 <code
                                  class="docutils literal"><span class="pre">cons</span></code> 的一部分 (事实上，是第二个 <code
                                  class="docutils literal"><span class="pre">cons</span></code> 的 <code
                                  class="docutils literal"><span class="pre">cdr</span></code> )。在这样的情况下，我们称这两个列表为共享结构
                                (Share Structure)。这两个列表的基本结构如图 12.1 所示。</p>
                              <p>使用 <code class="docutils literal"><span class="pre">tailp</span></code>
                                判断式来检测一下。将两个列表作为它的输入参数，如果第一个列表是第二个列表的一部分时，则返回 <code
                                  class="docutils literal"><span class="pre">T</span></code> ：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">tailp</span> <span class="nv">part</span> <span class="nv">whole</span><span class="p">)</span>
<span class="no">T</span>
</pre>
                                </div>
                              </div>
                              <p>我们可以把它想像成：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">our-tailp</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">or</span> <span class="p">(</span><span class="nb">eql</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nb">consp</span> <span class="nv">y</span><span class="p">)</span>
                         <span class="p">(</span><span class="nv">our-tailp</span> <span class="nv">x</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">y</span><span class="p">)))))</span>
</pre>
                                </div>
                              </div>
                              <p>如定义所表明的，每个列表都是它自己的尾端， <code
                                  class="docutils literal"><span class="pre">nil</span></code> 是每一个正规列表的尾端。</p>
                              <p>在更复杂的情况下，两个列表可以是共享结构，但彼此都不是对方的尾端。在这种情况下，他们都有一个共同的尾端，如图 12.2 所示。我们像这样构建这种情况：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">setf</span> <span class="nv">part</span> <span class="p">(</span><span class="nb">list</span> <span class="ss">&#39;b</span> <span class="ss">&#39;c</span><span class="p">)</span>
                        <span class="nv">whole1</span> <span class="p">(</span><span class="nb">cons</span> <span class="mi">1</span> <span class="nv">part</span><span class="p">)</span>
                        <span class="nv">whole2</span> <span class="p">(</span><span class="nb">cons</span> <span class="mi">2</span> <span class="nv">part</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <div class="figure">
                                <img alt="_images/Figure-12.2.png" src="_images/Figure-12.2.png" />
                              </div>
                              <p><strong>图 12.2 被共享的尾端</strong></p>
                              <p>现在 <code class="docutils literal"><span class="pre">whole1</span></code> 和 <code
                                  class="docutils literal"><span class="pre">whole2</span></code> 共享结构，但是它们彼此都不是对方的一部分。
                              </p>
                              <p>当存在嵌套列表时，重要的是要区分是列表共享了结构，还是列表的元素共享了结构。顶层列表结构指的是，直接构成列表的那些 <code
                                  class="docutils literal"><span class="pre">cons</span></code> ，而不包含那些用于构造列表元素的 <code
                                  class="docutils literal"><span class="pre">cons</span></code> 。图 12.3 是一个嵌套列表的顶层列表结构
                                (<strong>译者注：</strong>图 12.3 中上面那三个有黑色阴影的 <code
                                  class="docutils literal"><span class="pre">cons</span></code> 即构成顶层列表结构的 <code
                                  class="docutils literal"><span class="pre">cons</span></code> )。</p>
                              <div class="figure">
                                <img alt="_images/Figure-12.3.png" src="_images/Figure-12.3.png" />
                              </div>
                              <p><strong>图 12.3 顶层列表结构</strong></p>
                              <p>两个 <code class="docutils literal"><span class="pre">cons</span></code>
                                是否共享结构，取决于我们把它们看作是列表还是<a class="reference external"
                                  href="http://zh.wikipedia.org/wiki/%E6%A0%91_(%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)">树</a>。可能存在两个嵌套列表，当把它们看作树时，它们共享结构，而看作列表时，它们不共享结构。图
                                12.4 构建了这种情况，两个列表以一个元素的形式包含了同一个列表，代码如下：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">setf</span> <span class="nv">element</span> <span class="p">(</span><span class="nb">list</span> <span class="ss">&#39;a</span> <span class="ss">&#39;b</span><span class="p">)</span>
      <span class="nv">holds1</span> <span class="p">(</span><span class="nb">list</span> <span class="mi">1</span> <span class="nv">element</span> <span class="mi">2</span><span class="p">)</span>
      <span class="nv">holds2</span> <span class="p">(</span><span class="nb">list</span> <span class="nv">element</span> <span class="mi">3</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <div class="figure">
                                <img alt="_images/Figure-12.4.png" src="_images/Figure-12.4.png" />
                              </div>
                              <p><strong>图 12.4 共享子树</strong></p>
                              <p>虽然 <code class="docutils literal"><span class="pre">holds1</span></code> 的第二个元素和 <code
                                  class="docutils literal"><span class="pre">holds2</span></code> 的第一个元素共享结构
                                (其实是相同的)，但如果把 <code class="docutils literal"><span class="pre">holds1</span></code> 和
                                <code class="docutils literal"><span class="pre">holds2</span></code>
                                看成是列表时，它们不共享结构。仅当两个列表共享顶层列表结构时，才能说这两个列表共享结构，而 <code
                                  class="docutils literal"><span class="pre">holds1</span></code> 和 <code
                                  class="docutils literal"><span class="pre">holds2</span></code> 没有共享顶层列表结构。
                              </p>
                              <p>如果我们想避免共享结构，可以使用复制。函数 <code
                                  class="docutils literal"><span class="pre">copy-list</span></code> 可以这样定义：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">our-copy-list</span> <span class="p">(</span><span class="nv">lst</span><span class="p">)</span>
   <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">null</span> <span class="nv">lst</span><span class="p">)</span>
       <span class="no">nil</span>
       <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">lst</span><span class="p">)</span> <span class="p">(</span><span class="nv">our-copy-list</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">lst</span><span class="p">)))))</span>
</pre>
                                </div>
                              </div>
                              <p>它返回一个不与原始列表共享顶层列表结构的新列表。函数 <code
                                  class="docutils literal"><span class="pre">copy-tree</span></code> 可以这样定义：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">our-copy-tree</span> <span class="p">(</span><span class="nv">tr</span><span class="p">)</span>
   <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">atom</span> <span class="nv">tr</span><span class="p">)</span>
        <span class="nv">tr</span>
        <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nv">our-copy-tree</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">tr</span><span class="p">))</span>
              <span class="p">(</span><span class="nv">our-copy-tree</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">tr</span><span class="p">)))))</span>
</pre>
                                </div>
                              </div>
                              <p>它返回一个连原始列表的树型结构也不共享的新列表。图 12.5 显示了对一个嵌套列表使用 <code
                                  class="docutils literal"><span class="pre">copy-list</span></code> 和 <code
                                  class="docutils literal"><span class="pre">copy-tree</span></code> 的区别。</p>
                              <div class="figure">
                                <img alt="_images/Figure-12.5.png" src="_images/Figure-12.5.png" />
                              </div>
                              <p><strong>图 12.5 两种复制</strong></p>
                            </div>
                            <div class="section" id="modification">
                              <h4>12.2 修改 (Modification)<a class="headerlink" href="#modification"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>
                                为什么要避免共享结构呢？之前讨论的共享结构问题仅仅是个智力练习，到目前为止，并没使我们在实际写程序的时候有什么不同。当修改一个被共享的结构时，问题出现了。如果两个列表共享结构，当我们修改了其中一个，另外一个也会无意中被修改。
                              </p>
                              <p>上一节中，我们介绍了怎样构建一个是其它列表的尾端的列表：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">setf</span> <span class="nv">whole</span> <span class="p">(</span><span class="nb">list</span> <span class="ss">&#39;a</span> <span class="ss">&#39;b</span> <span class="ss">&#39;c</span><span class="p">)</span>
      <span class="nv">tail</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">whole</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p>因为 <code class="docutils literal"><span class="pre">whole</span></code> 的 <code
                                  class="docutils literal"><span class="pre">cdr</span></code> 与 <code
                                  class="docutils literal"><span class="pre">tail</span></code> 是相等的，无论是修改 <code
                                  class="docutils literal"><span class="pre">tail</span></code> 还是 <code
                                  class="docutils literal"><span class="pre">whole</span></code> 的 <code
                                  class="docutils literal"><span class="pre">cdr</span></code> ，我们修改的都是同一个 <code
                                  class="docutils literal"><span class="pre">cons</span></code> ：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nb">second</span> <span class="nv">tail</span> <span class="p">)</span> <span class="ss">&#39;e</span><span class="p">)</span>
<span class="nv">E</span>
<span class="nb">&gt;</span> <span class="nv">tail</span>
<span class="p">(</span><span class="nv">B</span> <span class="nv">E</span><span class="p">)</span>
<span class="nb">&gt;</span> <span class="nv">whole</span>
<span class="p">(</span><span class="nv">A</span> <span class="nv">B</span> <span class="nv">E</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>同样的，如果两个列表共享同一个尾端，这种情况也会发生。</p>
                              <p>一次修改两个对象并不总是错误的。有时候这可能正是你想要的。但如果无意的修改了共享结构，将会引入一些非常微妙的 bug。Lisp
                                程序员要培养对共享结构的意识，并且在这类错误发生时能够立刻反应过来。当一个列表神秘的改变了的时候，很有可能是因为改变了其它与之共享结构的对象。</p>
                              <p>真正危险的不是共享结构，而是改变被共享的结构。为了安全起见，干脆避免对结构使用 <code
                                  class="docutils literal"><span class="pre">setf</span></code> (以及相关的运算，比如： <code
                                  class="docutils literal"><span class="pre">pop</span></code> ， <code
                                  class="docutils literal"><span class="pre">rplaca</span></code>
                                等)，这样就不会遇到问题了。如果某些时候不得不修改列表结构时，要搞清楚要修改的列表的来源，确保它不要和其它不需要改变的对象共享结构。如果它和其它不需要改变的对象共享了结构，或者不能预测它的来源，那么复制一个副本来进行改变。
                              </p>
                              <p>当你调用别人写的函数的时候要加倍小心。除非你知道它内部的操作，否则，你传入的参数时要考虑到以下的情况：</p>
                              <p>1.它对你传入的参数可能会有破坏性的操作</p>
                              <p>2.你传入的参数可能被保存起来，如果你调用了一个函数，然后又修改了之前作为参数传入该函数的对象，那么你也就改变了函数已保存起来作为它用的对象[1]。</p>
                              <p>在这两种情况下，解决的方法是传入一个拷贝。</p>
                              <p>在 Common Lisp 中，一个函数调用在遍历列表结构 (比如， <code
                                  class="docutils literal"><span class="pre">mapcar</span></code> 或 <code
                                  class="docutils literal"><span class="pre">remove-if</span></code>
                                的参数)的过程中不允许修改被遍历的结构。关于评估这样的代码的重要性并没有明确的规定。</p>
                            </div>
                            <div class="section" id="example-queues">
                              <h4>12.3 示例：队列 (Example: Queues)<a class="headerlink" href="#example-queues"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>共享结构并不是一个总让人担心的特性。我们也可以对其加以利用的。这一节展示了怎样用共享结构来表示<a class="reference external"
                                  href="http://zh.wikipedia.org/wiki/%E9%98%9F%E5%88%97">队列</a>。队列对象是我们可以按照数据的插入顺序逐个检出数据的仓库，这个规则叫做<a
                                  class="reference external"
                                  href="http://zh.wikipedia.org/zh-cn/%E5%85%88%E9%80%B2%E5%85%88%E5%87%BA">先进先出 (FIFO,
                                  first in, first out)</a>。</p>
                              <p>用列表表示<a class="reference external" href="http://zh.wikipedia.org/wiki/%E6%A0%88">栈
                                  (stack)</a>比较容易，因为栈是从同一端插入和检出。而表示队列要困难些，因为队列的插入和检出是在不同端。为了有效的实现队列，我们需要找到一种办法来指向列表的两个端。
                              </p>
                              <p>图 12.6 给出了一种可行的策略。它展示怎样表示一个含有 a，b，c 三个元素的队列。一个队列就是一对列表，最后那个 <code
                                  class="docutils literal"><span class="pre">cons</span></code> 在相同的列表中。这个列表对由被称作头端
                                (front)和尾端 (back)的两部分组成。如果要从队列中检出一个元素，只需在其头端 <code
                                  class="docutils literal"><span class="pre">pop</span></code>，要插入一个元素，则创建一个新的 <code
                                  class="docutils literal"><span class="pre">cons</span></code> ，把尾端的 <code
                                  class="docutils literal"><span class="pre">cdr</span></code> 设置成指向这个 <code
                                  class="docutils literal"><span class="pre">cons</span></code> ，然后将尾端指向这个新的 <code
                                  class="docutils literal"><span class="pre">cons</span></code> 。</p>
                              <div class="figure">
                                <img alt="_images/Figure-12.6.png" src="_images/Figure-12.6.png" />
                              </div>
                              <p><strong>图 12.6 一个队列的结构</strong></p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">make-queue</span> <span class="p">()</span> <span class="p">(</span><span class="nb">cons</span> <span class="no">nil</span> <span class="no">nil</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">enqueue</span> <span class="p">(</span><span class="nv">obj</span> <span class="nv">q</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">null</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">q</span><span class="p">))</span>
      <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">q</span><span class="p">)</span> <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">q</span><span class="p">)</span> <span class="p">(</span><span class="nb">list</span> <span class="nv">obj</span><span class="p">)))</span>
      <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nb">cdr</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">q</span><span class="p">))</span> <span class="p">(</span><span class="nb">list</span> <span class="nv">obj</span><span class="p">)</span>
            <span class="p">(</span><span class="nb">cdr</span> <span class="nv">q</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">q</span><span class="p">))))</span>
  <span class="p">(</span><span class="nb">car</span> <span class="nv">q</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">dequeue</span> <span class="p">(</span><span class="nv">q</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">pop</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">q</span><span class="p">)))</span>
</pre>
                                </div>
                              </div>
                              <p><strong>图 12.7 队列实现</strong></p>
                              <p>图 12.7 中的代码实现了这一策略。其用法如下：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">setf</span> <span class="nv">q1</span> <span class="p">(</span><span class="nv">make-queue</span><span class="p">))</span>
<span class="p">(</span><span class="no">NIL</span><span class="p">)</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="k">progn</span> <span class="p">(</span><span class="nv">enqueue</span> <span class="ss">&#39;a</span> <span class="nv">q1</span><span class="p">)</span>
         <span class="p">(</span><span class="nv">enqueue</span> <span class="ss">&#39;b</span> <span class="nv">q1</span><span class="p">)</span>
         <span class="p">(</span><span class="nv">enqueue</span> <span class="ss">&#39;c</span> <span class="nv">q1</span><span class="p">))</span>
<span class="p">(</span><span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>现在， <code class="docutils literal"><span class="pre">q1</span></code> 的结构就如图 12.6 那样：
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="nv">q1</span>
<span class="p">((</span><span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span><span class="p">)</span> <span class="nv">C</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>从队列中检出一些元素：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">dequeue</span> <span class="nv">q1</span><span class="p">)</span>
<span class="nv">A</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="nv">dequeue</span> <span class="nv">q1</span><span class="p">)</span>
<span class="nv">B</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="nv">enqueue</span> <span class="ss">&#39;d</span> <span class="nv">q1</span><span class="p">)</span>
<span class="p">(</span><span class="nv">C</span> <span class="nv">D</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                            </div>
                            <div class="section" id="destructive-functions">
                              <h4>12.4 破坏性函数 (Destructive Functions)<a class="headerlink" href="#destructive-functions"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>Common Lisp 包含一些允许修改列表结构的函数。为了提高效率，这些函数是具有破坏性的。虽然它们可以回收利用作为参数传给它们的 <code
                                  class="docutils literal"><span class="pre">cons</span></code> ，但并不是因为想要它们的副作用而调用它们
                                (<strong>译者注：</strong>因为这些函数的副作用并没有任何保证，下面的例子将说明问题)。</p>
                              <p>比如， <code class="docutils literal"><span class="pre">delete</span></code> 是 <code
                                  class="docutils literal"><span class="pre">remove</span></code>
                                的一个具有破坏性的版本。虽然它可以破坏作为参数传给它的列表，但它并不保证什么。在大多数的 Common Lisp 的实现中，会出现下面的情况：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">setf</span> <span class="nv">lst</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">r</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">i</span> <span class="nv">a</span><span class="p">)</span> <span class="p">)</span>
<span class="p">(</span><span class="nv">A</span> <span class="nv">R</span> <span class="nv">A</span> <span class="nv">B</span> <span class="nv">I</span> <span class="nv">A</span><span class="p">)</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="nb">delete</span> <span class="ss">&#39;a</span> <span class="nv">lst</span> <span class="p">)</span>
<span class="p">(</span><span class="nv">R</span> <span class="nv">B</span> <span class="nv">I</span><span class="p">)</span>
<span class="nb">&gt;</span> <span class="nv">lst</span>
<span class="p">(</span><span class="nv">A</span> <span class="nv">R</span> <span class="nv">B</span> <span class="nv">I</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>正如 <code class="docutils literal"><span class="pre">remove</span></code>
                                一样，如果你想要副作用，应该对返回值使用 <code class="docutils literal"><span class="pre">setf</span></code>
                                ：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">setf</span> <span class="nv">lst</span> <span class="p">(</span><span class="nb">delete</span> <span class="ss">&#39;a</span> <span class="nv">lst</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p>破坏性函数是怎样回收利用传给它们的列表的呢？比如，可以考虑 <code
                                  class="docutils literal"><span class="pre">nconc</span></code> —— <code
                                  class="docutils literal"><span class="pre">append</span></code>
                                的破坏性版本。[2]下面是两个参数版本的实现，其清楚地展示了两个已知列表是怎样被缝在一起的：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">nconc2</span> <span class="p">(</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">consp</span> <span class="nv">x</span><span class="p">)</span>
        <span class="p">(</span><span class="k">progn</span>
           <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nb">cdr</span> <span class="p">(</span><span class="nb">last</span> <span class="nv">x</span><span class="p">))</span> <span class="nv">y</span><span class="p">)</span>
            <span class="nv">x</span><span class="p">)</span>
         <span class="nv">y</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p>我们找到第一个列表的最后一个 <em>Cons</em> 核 (cons cells)，把它的 <code
                                  class="docutils literal"><span class="pre">cdr</span></code> 设置成指向第二个列表。一个正规的多参数的
                                <code class="docutils literal"><span class="pre">nconc</span></code> 可以被定义成像附录 B 中的那样。
                              </p>
                              <p>函数 <code class="docutils literal"><span class="pre">mapcan</span></code> 类似 <code
                                  class="docutils literal"><span class="pre">mapcar</span></code> ，但它是用 <code
                                  class="docutils literal"><span class="pre">nconc</span></code> 把函数的返回值 (必须是列表) 拼接在一起的：
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">mapcan</span> <span class="nf">#&#39;</span><span class="nb">list</span>
          <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">)</span>
          <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">))</span>
<span class="p">(</span> <span class="nv">A</span> <span class="mi">1</span> <span class="nv">B</span> <span class="mi">2</span> <span class="nv">C</span> <span class="mi">3</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>这个函数可以定义如下：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">our-mapcan</span> <span class="p">(</span><span class="nv">fn</span> <span class="k">&amp;rest</span> <span class="nv">lsts</span> <span class="p">)</span>
       <span class="p">(</span><span class="nb">apply</span> <span class="nf">#&#39;</span><span class="nb">nconc</span> <span class="p">(</span><span class="nb">apply</span> <span class="nf">#&#39;</span><span class="nb">mapcar</span> <span class="nv">fn</span> <span class="nv">lsts</span><span class="p">)))</span>
</pre>
                                </div>
                              </div>
                              <p>使用 <code class="docutils literal"><span class="pre">mapcan</span></code>
                                时要谨慎，因为它具有破坏性。它用 <code class="docutils literal"><span class="pre">nconc</span></code>
                                拼接返回的列表，所以这些列表最好不要再在其它地方使用。</p>
                              <p>这类函数在处理某些问题的时候特别有用，比如，收集树在某层上的所有子结点。如果 <code
                                  class="docutils literal"><span class="pre">children</span></code>
                                函数返回一个节点的孩子节点的列表，那么我们可以定义一个函数返回某节点的孙子节点的列表如下：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">grandchildren</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span>
   <span class="p">(</span><span class="nb">mapcan</span> <span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">c</span><span class="p">)</span>
                <span class="p">(</span><span class="nb">copy-list</span> <span class="p">(</span><span class="nv">children</span> <span class="nv">c</span><span class="p">)))</span>
           <span class="p">(</span><span class="nv">children</span> <span class="nv">x</span><span class="p">)))</span>
</pre>
                                </div>
                              </div>
                              <p>这个函数调用 <code class="docutils literal"><span class="pre">copy-list</span></code> 时存在一个假设
                                —— <code class="docutils literal"><span class="pre">chlidren</span></code>
                                函数返回的是一个已经保存在某个地方的列表，而不是构建了一个新的列表。</p>
                              <p>一个 <code class="docutils literal"><span class="pre">mapcan</span></code> 的无损变体可以这样定义：
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">mappend</span> <span class="p">(</span><span class="nv">fn</span> <span class="k">&amp;rest</span> <span class="nv">lsts</span> <span class="p">)</span>
    <span class="p">(</span><span class="nb">apply</span> <span class="nf">#&#39;</span><span class="nb">append</span> <span class="p">(</span><span class="nb">apply</span> <span class="nf">#&#39;</span><span class="nb">mapcar</span> <span class="nv">fn</span> <span class="nv">lsts</span><span class="p">)))</span>
</pre>
                                </div>
                              </div>
                              <p>如果使用 <code class="docutils literal"><span class="pre">mappend</span></code> 函数，那么 <code
                                  class="docutils literal"><span class="pre">grandchildren</span></code> 的定义就可以省去 <code
                                  class="docutils literal"><span class="pre">copy-list</span></code> ：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">grandchildren</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span>
   <span class="p">(</span><span class="nv">mappend</span> <span class="nf">#&#39;</span><span class="nv">children</span> <span class="p">(</span><span class="nv">children</span> <span class="nv">x</span><span class="p">)))</span>
</pre>
                                </div>
                              </div>
                            </div>
                            <div class="section" id="example-binary-search-trees">
                              <h4>12.5 示例：二叉搜索树 (Example: Binary Search Trees)<a class="headerlink"
                                  href="#example-binary-search-trees" title="Permalink to this headline">¶</a></h4>
                              <p>在某些情况下，使用破坏性操作比使用非破坏性的显得更自然。第 4.7 节中展示了如何维护一个具有二分搜索格式的有序对象集 (或者说维护一个<a
                                  class="reference external"
                                  href="http://zh.wikipedia.org/zh-cn/%E4%BA%8C%E5%85%83%E6%90%9C%E5%B0%8B%E6%A8%B9">二叉搜索树
                                  (BST)</a>)。第 4.7
                                节中给出的函数都是非破坏性的，但在我们真正使用BST的时候，这是一个不必要的保护措施。本节将展示如何定义更符合实际应用的具有破坏性的插入函数和删除函数。</p>
                              <p>图 12.8 展示了如何定义一个具有破坏性的 <code
                                  class="docutils literal"><span class="pre">bst-insert</span></code> (第 72
                                页「<strong>译者注：</strong>第 4.7 节」)。相同的输入参数，能够得到相同返回值。唯一的区别是，它将修改作为第二个参数输入的 BST。 在第 2.12
                                节中说过，具有破坏性并不意味着一个函数调用具有副作用。的确如此，如果你想使用 <code
                                  class="docutils literal"><span class="pre">bst-insert!</span></code> 构造一个 BST，你必须像调用
                                <code class="docutils literal"><span class="pre">bst-insert</span></code> 那样调用它：
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">setf</span> <span class="vg">*bst*</span> <span class="no">nil</span><span class="p">)</span>
<span class="no">NIL</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="nb">dolist</span> <span class="p">(</span><span class="nv">x</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">7</span> <span class="mi">2</span> <span class="mi">9</span> <span class="mi">8</span> <span class="mi">4</span> <span class="mi">1</span> <span class="mi">5</span> <span class="mi">12</span><span class="p">))</span>
<span class="p">(</span><span class="nb">setf</span> <span class="vg">*bst*</span> <span class="p">(</span><span class="nv">bst-insert!</span> <span class="nv">x</span> <span class="vg">*bst*</span> <span class="nf">#&#39;</span><span class="nb">&lt;</span><span class="p">)))</span>
<span class="no">NIL</span>
</pre>
                                </div>
                              </div>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">bst-insert!</span> <span class="p">(</span><span class="nv">obj</span> <span class="nv">bst</span> <span class="nb">&lt;</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">null</span> <span class="nv">bst</span><span class="p">)</span>
      <span class="p">(</span><span class="nv">make-node</span> <span class="ss">:elt</span> <span class="nv">obj</span><span class="p">)</span>
      <span class="p">(</span><span class="k">progn</span> <span class="p">(</span><span class="nv">bsti</span> <span class="nv">obj</span> <span class="nv">bst</span> <span class="nb">&lt;</span><span class="p">)</span>
             <span class="nv">bst</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">bsti</span> <span class="p">(</span><span class="nv">obj</span> <span class="nv">bst</span> <span class="nb">&lt;</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nb">elt</span> <span class="p">(</span><span class="nv">node-elt</span> <span class="nv">bst</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">eql</span> <span class="nv">obj</span> <span class="nb">elt</span><span class="p">)</span>
        <span class="nv">bst</span>
        <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">funcall</span> <span class="nb">&lt;</span> <span class="nv">obj</span> <span class="nb">elt</span><span class="p">)</span>
            <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">l</span> <span class="p">(</span><span class="nv">node-l</span> <span class="nv">bst</span><span class="p">)))</span>
              <span class="p">(</span><span class="k">if</span> <span class="nv">l</span>
                  <span class="p">(</span><span class="nv">bsti</span> <span class="nv">obj</span> <span class="nv">l</span> <span class="nb">&lt;</span><span class="p">)</span>
                  <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nv">node-l</span> <span class="nv">bst</span><span class="p">)</span>
                        <span class="p">(</span><span class="nv">make-node</span> <span class="ss">:elt</span> <span class="nv">obj</span><span class="p">))))</span>
            <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">r</span> <span class="p">(</span><span class="nv">node-r</span> <span class="nv">bst</span><span class="p">)))</span>
              <span class="p">(</span><span class="k">if</span> <span class="nv">r</span>
                  <span class="p">(</span><span class="nv">bsti</span> <span class="nv">obj</span> <span class="nv">r</span> <span class="nb">&lt;</span><span class="p">)</span>
                  <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nv">node-r</span> <span class="nv">bst</span><span class="p">)</span>
                        <span class="p">(</span><span class="nv">make-node</span> <span class="ss">:elt</span> <span class="nv">obj</span><span class="p">))))))))</span>
</pre>
                                </div>
                              </div>
                              <p><strong>图 12.8: 二叉搜索树：破坏性插入</strong></p>
                              <p>你也可以为 BST 定义一个类似 push 的功能，但这超出了本书的范围。(好奇的话，可以参考第 409 页 「<strong>译者注：</strong>即备注 204 」
                                的宏定义。)</p>
                              <p>与 <code class="docutils literal"><span class="pre">bst-remove</span></code> (第 74
                                页「<strong>译者注：</strong>第 4.7 节」) 对应，图 12.9 展示了一个破坏性版本的 <code
                                  class="docutils literal"><span class="pre">bst-delete</span></code> 。同 <code
                                  class="docutils literal"><span class="pre">delete</span></code>
                                一样，我们调用它并不是因为它的副作用。你应该像调用 <code
                                  class="docutils literal"><span class="pre">bst-remove</span></code> 那样调用 <code
                                  class="docutils literal"><span class="pre">bst-delete</span></code> ：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre>&gt; (setf *bst* (bst-delete 2 *bst* #&#39;&lt;) )
#&lt;7&gt;
&gt; (bst-find 2 *bst* #&#39;&lt;)
NIL
</pre>
                                </div>
                              </div>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">bst-delete</span> <span class="p">(</span><span class="nv">obj</span> <span class="nv">bst</span> <span class="nb">&lt;</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="nv">bst</span> <span class="p">(</span><span class="nv">bstd</span> <span class="nv">obj</span> <span class="nv">bst</span> <span class="no">nil</span> <span class="no">nil</span> <span class="nb">&lt;</span><span class="p">))</span>
  <span class="nv">bst</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">bstd</span> <span class="p">(</span><span class="nv">obj</span> <span class="nv">bst</span> <span class="nv">prev</span> <span class="nv">dir</span> <span class="nb">&lt;</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nb">elt</span> <span class="p">(</span><span class="nv">node-elt</span> <span class="nv">bst</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">eql</span> <span class="nb">elt</span> <span class="nv">obj</span><span class="p">)</span>
        <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nb">rest</span> <span class="p">(</span><span class="nv">percolate!</span> <span class="nv">bst</span><span class="p">)))</span>
          <span class="p">(</span><span class="nb">case</span> <span class="nv">dir</span>
            <span class="p">(</span><span class="ss">:l</span> <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nv">node-l</span> <span class="nv">prev</span><span class="p">)</span> <span class="nb">rest</span><span class="p">))</span>
            <span class="p">(</span><span class="ss">:r</span> <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nv">node-r</span> <span class="nv">prev</span><span class="p">)</span> <span class="nb">rest</span><span class="p">))))</span>
      <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">funcall</span> <span class="nb">&lt;</span> <span class="nv">obj</span> <span class="nb">elt</span><span class="p">)</span>
          <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nv">node-l</span> <span class="nv">bst</span><span class="p">)</span>
              <span class="p">(</span><span class="nv">bstd</span> <span class="nv">obj</span> <span class="p">(</span><span class="nv">node-l</span> <span class="nv">bst</span><span class="p">)</span> <span class="nv">bst</span> <span class="ss">:l</span> <span class="nb">&lt;</span><span class="p">))</span>
          <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nv">node-r</span> <span class="nv">bst</span><span class="p">)</span>
              <span class="p">(</span><span class="nv">bstd</span> <span class="nv">obj</span> <span class="p">(</span><span class="nv">node-r</span> <span class="nv">bst</span><span class="p">)</span> <span class="nv">bst</span> <span class="ss">:r</span> <span class="nb">&lt;</span><span class="p">))))))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">percolate!</span> <span class="p">(</span><span class="nv">bst</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nb">null</span> <span class="p">(</span><span class="nv">node-l</span> <span class="nv">bst</span><span class="p">))</span>
         <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">null</span> <span class="p">(</span><span class="nv">node-r</span> <span class="nv">bst</span><span class="p">))</span>
             <span class="no">nil</span>
             <span class="p">(</span><span class="nv">rperc!</span> <span class="nv">bst</span><span class="p">)))</span>
        <span class="p">((</span><span class="nb">null</span> <span class="p">(</span><span class="nv">node-r</span> <span class="nv">bst</span><span class="p">))</span> <span class="p">(</span><span class="nv">lperc!</span> <span class="nv">bst</span><span class="p">))</span>
        <span class="p">(</span><span class="no">t</span> <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">zerop</span> <span class="p">(</span><span class="nb">random</span> <span class="mi">2</span><span class="p">))</span>
               <span class="p">(</span><span class="nv">lperc!</span> <span class="nv">bst</span><span class="p">)</span>
               <span class="p">(</span><span class="nv">rperc!</span> <span class="nv">bst</span><span class="p">)))))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">lperc!</span> <span class="p">(</span><span class="nv">bst</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nv">node-elt</span> <span class="nv">bst</span><span class="p">)</span> <span class="p">(</span><span class="nv">node-elt</span> <span class="p">(</span><span class="nv">node-l</span> <span class="nv">bst</span><span class="p">)))</span>
  <span class="p">(</span><span class="nv">percolate!</span> <span class="p">(</span><span class="nv">node-l</span> <span class="nv">bst</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">rperc!</span> <span class="p">(</span><span class="nv">bst</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nv">node-elt</span> <span class="nv">bst</span><span class="p">)</span> <span class="p">(</span><span class="nv">node-elt</span> <span class="p">(</span><span class="nv">node-r</span> <span class="nv">bst</span><span class="p">)))</span>
  <span class="p">(</span><span class="nv">percolate!</span> <span class="p">(</span><span class="nv">node-r</span> <span class="nv">bst</span><span class="p">)))</span>
</pre>
                                </div>
                              </div>
                              <p><strong>图 12.9: 二叉搜索树：破坏性删除</strong></p>
                              <p><strong>译注:</strong> 此范例已被回报为错误的，一个修复的版本请造访<a class="reference external"
                                  href="https://gist.github.com/2868339">这里</a>。</p>
                            </div>
                            <div class="section" id="example-doubly-linked-lists">
                              <h4>12.6 示例：双向链表 (Example: Doubly-Linked Lists)<a class="headerlink"
                                  href="#example-doubly-linked-lists" title="Permalink to this headline">¶</a></h4>
                              <p>普通的 Lisp 列表是单向链表，这意味着其指针指向一个方向：我们可以获取下一个元素，但不能获取前一个。在<a class="reference external"
                                  href="http://zh.wikipedia.org/wiki/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8">双向链表</a>中，指针指向两个方向，我们获取前一个元素和下一个元素都很容易。这一节将介绍如何创建和操作双向链表。
                              </p>
                              <p>图 12.10 展示了如何用结构来实现双向链表。将 <code
                                  class="docutils literal"><span class="pre">cons</span></code> 看成一种结构，它有两个字段：指向数据的
                                <code class="docutils literal"><span class="pre">car</span></code> 和指向下一个元素的 <code
                                  class="docutils literal"><span class="pre">cdr</span></code>
                                。要实现一个双向链表，我们需要第三个字段，用来指向前一个元素。图 12.10 中的 <code
                                  class="docutils literal"><span class="pre">defstruct</span></code> 定义了一个含有三个字段的对象
                                <code class="docutils literal"><span class="pre">dl</span></code>
                                (用于“双向链接”)，我们将用它来构造双向链表。<code
                                  class="docutils literal"><span class="pre">dl</span></code> 的 <code
                                  class="docutils literal"><span class="pre">data</span></code> 字段对应一个 <code
                                  class="docutils literal"><span class="pre">cons</span></code> 的 <code
                                  class="docutils literal"><span class="pre">car</span></code>，<code
                                  class="docutils literal"><span class="pre">next</span></code> 字段对应 <code
                                  class="docutils literal"><span class="pre">cdr</span></code> 。 <code
                                  class="docutils literal"><span class="pre">prev</span></code> 字段就类似一个 <code
                                  class="docutils literal"><span class="pre">cdr</span></code> ，指向另外一个方向。(图 12.11
                                是一个含有三个元素的双向链表。) 空的双向链表为 <code
                                  class="docutils literal"><span class="pre">nil</span></code> ，就像空的列表一样。
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defstruct</span> <span class="p">(</span><span class="nv">dl</span> <span class="p">(</span><span class="ss">:print-function</span> <span class="nv">print-dl</span><span class="p">))</span>
  <span class="nv">prev</span> <span class="nv">data</span> <span class="nv">next</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">print-dl</span> <span class="p">(</span><span class="nv">dl</span> <span class="nc">stream</span> <span class="nv">depth</span><span class="p">)</span>
  <span class="p">(</span><span class="k">declare</span> <span class="p">(</span><span class="k">ignore</span> <span class="nv">depth</span><span class="p">))</span>
  <span class="p">(</span><span class="nb">format</span> <span class="nc">stream</span> <span class="s">&quot;#&lt;DL ~A&gt;&quot;</span> <span class="p">(</span><span class="nv">dl-&gt;list</span> <span class="nv">dl</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">dl-&gt;list</span> <span class="p">(</span><span class="nv">lst</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nv">dl-p</span> <span class="nv">lst</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nv">dl-data</span> <span class="nv">lst</span><span class="p">)</span> <span class="p">(</span><span class="nv">dl-&gt;list</span> <span class="p">(</span><span class="nv">dl-next</span> <span class="nv">lst</span><span class="p">)))</span>
      <span class="nv">lst</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">dl-insert</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">lst</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nb">elt</span> <span class="p">(</span><span class="nv">make-dl</span> <span class="ss">:data</span> <span class="nv">x</span> <span class="ss">:next</span> <span class="nv">lst</span><span class="p">)))</span>
    <span class="p">(</span><span class="nb">when</span> <span class="p">(</span><span class="nv">dl-p</span> <span class="nv">lst</span><span class="p">)</span>
      <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nv">dl-prev</span> <span class="nv">lst</span><span class="p">)</span>
          <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nv">dl-next</span> <span class="p">(</span><span class="nv">dl-prev</span> <span class="nv">lst</span><span class="p">))</span> <span class="nb">elt</span>
                <span class="p">(</span><span class="nv">dl-prev</span> <span class="nb">elt</span><span class="p">)</span> <span class="p">(</span><span class="nv">dl-prev</span> <span class="nv">lst</span><span class="p">)))</span>
      <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nv">dl-prev</span> <span class="nv">lst</span><span class="p">)</span> <span class="nb">elt</span><span class="p">))</span>
    <span class="nb">elt</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">dl-list</span> <span class="p">(</span><span class="k">&amp;rest</span> <span class="nv">args</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">reduce</span> <span class="nf">#&#39;</span><span class="nv">dl-insert</span> <span class="nv">args</span>
          <span class="ss">:from-end</span> <span class="no">t</span> <span class="ss">:initial-value</span> <span class="no">nil</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">dl-remove</span> <span class="p">(</span><span class="nv">lst</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nv">dl-prev</span> <span class="nv">lst</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nv">dl-next</span> <span class="p">(</span><span class="nv">dl-prev</span> <span class="nv">lst</span><span class="p">))</span> <span class="p">(</span><span class="nv">dl-next</span> <span class="nv">lst</span><span class="p">)))</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nv">dl-next</span> <span class="nv">lst</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nv">dl-prev</span> <span class="p">(</span><span class="nv">dl-next</span> <span class="nv">lst</span><span class="p">))</span> <span class="p">(</span><span class="nv">dl-prev</span> <span class="nv">lst</span><span class="p">)))</span>
  <span class="p">(</span><span class="nv">dl-next</span> <span class="nv">lst</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p><strong>图 12.10: 构造双向链表</strong></p>
                              <div class="figure">
                                <img alt="_images/Figure-12.11.png" src="_images/Figure-12.11.png" />
                              </div>
                              <p><strong>图 12.11: 一个双向链表。</strong></p>
                              <p>为了便于操作，我们为双向链表定义了一些实现类似 <code
                                  class="docutils literal"><span class="pre">car</span></code> ， <code
                                  class="docutils literal"><span class="pre">cdr</span></code> ， <code
                                  class="docutils literal"><span class="pre">consp</span></code> 功能的函数：<code
                                  class="docutils literal"><span class="pre">dl-data</span></code> ， <code
                                  class="docutils literal"><span class="pre">dl-next</span></code> 和 <code
                                  class="docutils literal"><span class="pre">dl-p</span></code> 。 <code
                                  class="docutils literal"><span class="pre">dl-&gt;list</span></code> 是 <code
                                  class="docutils literal"><span class="pre">dl</span></code> 的打印函数(<code
                                  class="docutils literal"><span class="pre">print-function</span></code>)，其返回一个包含 <code
                                  class="docutils literal"><span class="pre">dl</span></code> 所有元素的普通列表。</p>
                              <p>函数 <code class="docutils literal"><span class="pre">dl-insert</span></code> 就像针对双向链表的
                                <code class="docutils literal"><span class="pre">cons</span></code> 操作。至少，它就像 <code
                                  class="docutils literal"><span class="pre">cons</span></code> 一样，是一个基本构建函数。与 <code
                                  class="docutils literal"><span class="pre">cons</span></code>
                                不同的是，它实际上要修改作为第二个参数传递给它的双向链表。在这种情况下，这是自然而然的。我们 <code
                                  class="docutils literal"><span class="pre">cons</span></code> 内容到普通列表前面，不需要对普通列表的
                                <code class="docutils literal"><span class="pre">rest</span></code>
                                (<strong>译者注：</strong> <code
                                  class="docutils literal"><span class="pre">rest</span></code> 即 <code
                                  class="docutils literal"><span class="pre">cdr</span></code> 的另一种表示方法，这里的 <code
                                  class="docutils literal"><span class="pre">rest</span></code> 是对通过 <code
                                  class="docutils literal"><span class="pre">cons</span></code> 构建后列表来说的，即修改之前的列表)
                                做任何修改。但是要在双向链表的前面插入元素，我们不得不修改列表的 <code
                                  class="docutils literal"><span class="pre">rest</span></code> (这里的 <code
                                  class="docutils literal"><span class="pre">rest</span></code> 即指没修改之前的双向链表) 的 <code
                                  class="docutils literal"><span class="pre">prev</span></code> 字段来指向这个新元素。
                              </p>
                              <p>几个普通列表可以共享同一个尾端。因为双向链表的尾端不得不指向它的前一个元素，所以不可能存在两个双向链表共享同一个尾端。如果 <code
                                  class="docutils literal"><span class="pre">dl-insert</span></code>
                                不具有破坏性，那么它不得不复制其第二个参数。</p>
                              <p>单向链表(普通列表)和双向链表另一个有趣的区别是，如何持有它们。我们使用普通列表的首端，来表示单向链表，如果将列表赋值给一个变量，变量可以通过保存指向列表第一个 <code
                                  class="docutils literal"><span class="pre">cons</span></code>
                                的指针来持有列表。但是双向链表是双向指向的，我们可以用任何一个点来持有双向链表。 <code
                                  class="docutils literal"><span class="pre">dl-insert</span></code> 另一个不同于 <code
                                  class="docutils literal"><span class="pre">cons</span></code> 的地方在于 <code
                                  class="docutils literal"><span class="pre">dl-insert</span></code> 可以在双向链表的任何位置插入新元素，而
                                <code class="docutils literal"><span class="pre">cons</span></code> 只能在列表的首端插入。
                              </p>
                              <p>函数 <code class="docutils literal"><span class="pre">dl-list</span></code> 是对于 <code
                                  class="docutils literal"><span class="pre">dl</span></code> 的类似 <code
                                  class="docutils literal"><span class="pre">list</span></code>
                                的功能。它接受任意多个参数，它会返回一个包含以这些参数作为元素的 <code
                                  class="docutils literal"><span class="pre">dl</span></code> ：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre>&gt; (dl-list &#39;a &#39;b &#39;c)
#&lt;DL (A B C)&gt;
</pre>
                                </div>
                              </div>
                              <p>它使用了 <code class="docutils literal"><span class="pre">reduce</span></code> 函数 (并设置其
                                <code class="docutils literal"><span class="pre">from-end</span></code> 参数为 <code
                                  class="docutils literal"><span class="pre">true</span></code>，<code
                                  class="docutils literal"><span class="pre">initial-value</span></code> 为 <code
                                  class="docutils literal"><span class="pre">nil</span></code>)，其功能等价于
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nv">dl-insert</span> <span class="ss">&#39;a</span> <span class="p">(</span><span class="nv">dl-insert</span> <span class="ss">&#39;b</span> <span class="p">(</span><span class="nv">dl-insert</span> <span class="ss">&#39;c</span> <span class="no">nil</span><span class="p">))</span> <span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>如果将 <code class="docutils literal"><span class="pre">dl-list</span></code> 定义中的 <code
                                  class="docutils literal"><span class="pre">#'dl-insert</span></code> 换成 <code
                                  class="docutils literal"><span class="pre">#'cons</span></code>，它就相当于 <code
                                  class="docutils literal"><span class="pre">list</span></code> 函数了。下面是 <code
                                  class="docutils literal"><span class="pre">dl-list</span></code> 的一些常见用法：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre>&gt; (setf dl (dl-list &#39;a &#39;b))
#&lt;DL (A B)&gt;
&gt; (setf dl (dl-insert &#39;c dl))
#&lt;DL (C A B)&gt;
&gt; (dl-insert &#39;r (dl-next dl))
#&lt;DL (R A B)&gt;
&gt; dl
#&lt;DL (C R A B)&gt;
</pre>
                                </div>
                              </div>
                              <p>最后，<code class="docutils literal"><span class="pre">dl-remove</span></code>
                                的作用是从双向链表中移除一个元素。同 <code
                                  class="docutils literal"><span class="pre">dl-insert</span></code> 一样，它也是具有破坏性的。</p>
                            </div>
                            <div class="section" id="circular-structure">
                              <h4>12.7 环状结构 (Circular Structure)<a class="headerlink" href="#circular-structure"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>将列表结构稍微修改一下，就可以得到一个环形列表。存在两种环形列表。最常用的一种是其顶层列表结构是一个环的，我们把它叫做 <code
                                  class="docutils literal"><span class="pre">cdr-circular</span></code> ，因为环是由一个 <code
                                  class="docutils literal"><span class="pre">cons</span></code> 的 <code
                                  class="docutils literal"><span class="pre">cdr</span></code> 构成的。</p>
                              <p>构造一个单元素的 <code class="docutils literal"><span class="pre">cdr-circular</span></code>
                                列表，可以将一个列表的 <code class="docutils literal"><span class="pre">cdr</span></code> 设置成列表自身：
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">setf</span> <span class="nv">x</span> <span class="p">(</span><span class="nb">list</span> <span class="ss">&#39;a</span><span class="p">))</span>
<span class="p">(</span><span class="nv">A</span><span class="p">)</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="k">progn</span> <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">x</span><span class="p">)</span> <span class="nv">x</span><span class="p">)</span> <span class="no">nil</span><span class="p">)</span>
<span class="no">NIL</span>
</pre>
                                </div>
                              </div>
                              <p>这样 <code class="docutils literal"><span class="pre">x</span></code> 就是一个环形列表，其结构如图
                                12.12 (左) 所示。</p>
                              <div class="figure">
                                <img alt="_images/Figure-12.12.png" src="_images/Figure-12.12.png" />
                              </div>
                              <p><strong>图 12.12 环状列表。</strong></p>
                              <p>如果 Lisp 试着打印我们刚刚构造的结构，将会显示 (a a a a a …… —— 无限个 <code
                                  class="docutils literal"><span class="pre">a</span></code>)。但如果设置全局变量 <code
                                  class="docutils literal"><span class="pre">*print-circle*</span></code> 为 <code
                                  class="docutils literal"><span class="pre">t</span></code> 的话，Lisp
                                就会采用一种方式打印出一个能代表环形结构的对象：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">setf</span> <span class="vg">*print-circle*</span> <span class="no">t</span> <span class="p">)</span>
<span class="no">T</span>
<span class="nb">&gt;</span> <span class="nv">x</span>
<span class="o">#1=</span><span class="p">(</span><span class="nv">A</span> <span class="o">.</span> <span class="o">#1#</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>如果你需要，你也可以使用 <code class="docutils literal"><span class="pre">#n=</span></code> 和 <code
                                  class="docutils literal"><span class="pre">#n#</span></code> 这两个读取宏，来自己表示共享结构。</p>
                              <p><code class="docutils literal"><span class="pre">cdr-cicular</span></code>
                                列表十分有用，比如，可以用来表示缓冲区、池。下面这个函数，可以将一个普通的非空列表，转换成一个对应的 <code
                                  class="docutils literal"><span class="pre">cdr-cicular</span></code> 列表：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">circular</span> <span class="p">(</span><span class="nv">lst</span><span class="p">)</span>
        <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nb">cdr</span> <span class="p">(</span><span class="nb">last</span> <span class="nv">lst</span><span class="p">))</span> <span class="nv">lst</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p>另外一种环状列表叫做 <code class="docutils literal"><span class="pre">car-circular</span></code>
                                列表。<code class="docutils literal"><span class="pre">car-circular</span></code>
                                列表是一个树，并将其自身当作自己的子树的结构。因为环是通过一个 <code
                                  class="docutils literal"><span class="pre">cons</span></code> 的 <code
                                  class="docutils literal"><span class="pre">car</span></code> 形成的，所以叫做 <code
                                  class="docutils literal"><span class="pre">car-circular</span></code>。这里构造了一个 <code
                                  class="docutils literal"><span class="pre">car-circular</span></code> ，它的第二个元素是它自身：
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre>&gt; (let ((y (list &#39;a )))
(setf (car y) y)
     y)
#i=(#i#)
</pre>
                                </div>
                              </div>
                              <p>图 12.12 (右) 展示了其结构。这个 <code
                                  class="docutils literal"><span class="pre">car-circular</span></code> 是一个正规列表。 <code
                                  class="docutils literal"><span class="pre">cdr-circular</span></code>
                                列表都不是正规列表，除开一些特殊情况 <code
                                  class="docutils literal"><span class="pre">car-circular</span></code> 列表是正规列表。</p>
                              <p>一个列表也可以既是 <code class="docutils literal"><span class="pre">car-circular</span></code>
                                ，又是 <code class="docutils literal"><span class="pre">cdr-circular</span></code> 。 一个
                                <code class="docutils literal"><span class="pre">cons</span></code> 的 <code
                                  class="docutils literal"><span class="pre">car</span></code> 和 <code
                                  class="docutils literal"><span class="pre">cdr</span></code> 均是其自身：
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">c</span> <span class="p">(</span><span class="nb">cons</span> <span class="mi">11</span><span class="p">))</span> <span class="p">)</span>
     <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">c</span><span class="p">)</span> <span class="nv">c</span>
            <span class="p">(</span><span class="nb">cdr</span> <span class="nv">c</span><span class="p">)</span> <span class="nv">c</span><span class="p">)</span>
     <span class="nv">c</span><span class="p">)</span>
<span class="o">#1=</span><span class="p">(</span><span class="o">#1#</span> <span class="o">.</span> <span class="o">#1#</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>
                                很难想像这样的一个列表有什么用。实际上，了解环形列表的主要目的就是为了避免因为偶然因素构造出了环形列表，因为，将一个环形列表传给一个函数，如果该函数遍历这个环形列表，它将进入死循环。
                              </p>
                              <p>环形结构的这种问题在列表以外的其他对象中也存在。比如，一个数组可以将数组自身当作其元素：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">setf</span> <span class="vg">*print-array*</span> <span class="no">t</span> <span class="p">)</span>
<span class="no">T</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">a</span> <span class="p">(</span><span class="nb">make-array</span> <span class="mi">1</span><span class="p">))</span> <span class="p">)</span>
          <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nb">aref</span> <span class="nv">a</span> <span class="mi">0</span><span class="p">)</span> <span class="nv">a</span><span class="p">)</span>
          <span class="nv">a</span><span class="p">)</span>
<span class="o">#1=#(#1#</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>实际上，任何可以包含元素的对象都可能包含其自身作为元素。</p>
                              <p>用 <code class="docutils literal"><span class="pre">defstruct</span></code>
                                构造出环形结构是相当常见的。比如，一个结构 <code class="docutils literal"><span class="pre">c</span></code>
                                是一颗树的元素，它的 <code class="docutils literal"><span class="pre">parent</span></code>
                                字段所指向的结构 <code class="docutils literal"><span class="pre">p</span></code> 的 <code
                                  class="docutils literal"><span class="pre">child</span></code> 字段也恰好指向 <code
                                  class="docutils literal"><span class="pre">c</span></code> 。</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="k">progn</span> <span class="p">(</span><span class="nb">defstruct</span> <span class="nb">elt</span>
          <span class="p">(</span><span class="nv">parent</span> <span class="no">nil</span> <span class="p">)</span> <span class="p">(</span><span class="nv">child</span> <span class="no">nil</span><span class="p">)</span> <span class="p">)</span>
     <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">c</span> <span class="p">(</span><span class="nv">make-elt</span><span class="p">)</span> <span class="p">)</span>
               <span class="p">(</span><span class="nv">p</span> <span class="p">(</span><span class="nv">make-elt</span><span class="p">))</span> <span class="p">)</span>
          <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nv">elt-parent</span> <span class="nv">c</span><span class="p">)</span> <span class="nv">p</span>
                    <span class="p">(</span><span class="nv">elt-child</span> <span class="nv">p</span><span class="p">)</span> <span class="nv">c</span><span class="p">)</span>
          <span class="nv">c</span><span class="p">)</span> <span class="p">)</span>
<span class="o">#1=</span><span class="l-Other">#S</span><span class="p">(</span><span class="nv">ELT</span> <span class="nv">PARENT</span> <span class="l-Other">#S</span><span class="p">(</span><span class="nv">ELT</span> <span class="nv">PARENT</span> <span class="no">NIL</span> <span class="nv">CHILD</span> <span class="o">#1#</span><span class="p">)</span> <span class="nv">CHILD</span> <span class="no">NIL</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>要实现像这样一个结构的打印函数 (<code
                                  class="docutils literal"><span class="pre">print-function</span></code>)，我们需要将全局变量
                                <code class="docutils literal"><span class="pre">*print-circle*</span></code> 绑定为 <code
                                  class="docutils literal"><span class="pre">t</span></code> ，或者避免打印可能构成环的字段。
                              </p>
                            </div>
                            <div class="section" id="constant-structure">
                              <h4>12.8 常量结构 (Constant Structure)<a class="headerlink" href="#constant-structure"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>因为常量实际上是程序代码的一部分，所以我们也不应该修改他们，或者是不经意地写了自重写的代码。一个通过 <code
                                  class="docutils literal"><span class="pre">quote</span></code>
                                引用的列表是一个常量，所以一定要小心，不要修改被引用的列表的任何 <code
                                  class="docutils literal"><span class="pre">cons</span></code>。比如，如果我们用下面的代码，来测试一个符号是不是算术运算符：
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">arith-op</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span>
<span class="p">(</span><span class="nb">member</span> <span class="nv">x</span> <span class="o">&#39;</span><span class="p">(</span><span class="nb">+</span> <span class="nb">-</span> <span class="nb">*</span> <span class="nb">/</span><span class="p">)))</span>
</pre>
                                </div>
                              </div>
                              <p>如果被测试的符号是算术运算符，它的返回值将至少一个被引用列表的一部分。如果我们修改了其返回值，</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">nconc</span> <span class="p">(</span><span class="nv">arith-op</span> <span class="ss">&#39;*</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">as</span> <span class="nv">i</span> <span class="no">t</span> <span class="nv">were</span><span class="p">))</span>
<span class="p">(</span><span class="nb">*</span> <span class="nb">/</span> <span class="nv">AS</span> <span class="nv">IT</span> <span class="nv">WERE</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>那么我就会修改 <code class="docutils literal"><span class="pre">arith-op</span></code>
                                函数中的一个列表，从而改变了这个函数的功能：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">arith-op</span> <span class="ss">&#39;as</span> <span class="p">)</span>
<span class="p">(</span><span class="nv">AS</span> <span class="nv">IT</span> <span class="nv">WERE</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>写一个返回常量结构的函数，并不一定是错误的。但当你考虑使用一个破坏性的操作是否安全的时候，你必须考虑到这一点。</p>
                              <p>有几个其它方法来实现 <code
                                  class="docutils literal"><span class="pre">arith-op</span></code>，使其不返回被引用列表的部分。一般地，我们可以通过将其中的所有引用(
                                <code class="docutils literal"><span class="pre">quote</span></code> ) 替换成 <code
                                  class="docutils literal"><span class="pre">list</span></code>
                                来确保安全，这使得它每次被调用都将返回一个新的列表：
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">arith-op</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span>
        <span class="p">(</span><span class="nb">member</span> <span class="nv">x</span> <span class="p">(</span><span class="nb">list</span> <span class="ss">&#39;+</span> <span class="ss">&#39;-</span> <span class="ss">&#39;*</span> <span class="ss">&#39;/</span><span class="p">)))</span>
</pre>
                                </div>
                              </div>
                              <p>这里，使用 <code class="docutils literal"><span class="pre">list</span></code>
                                是一种低效的解决方案，我们应该使用 <code class="docutils literal"><span class="pre">find</span></code>
                                来替代 <code class="docutils literal"><span class="pre">member</span></code>：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">arith-op</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span>
        <span class="p">(</span><span class="nb">find</span> <span class="nv">x</span> <span class="o">&#39;</span><span class="p">(</span><span class="nb">+</span> <span class="nb">-</span> <span class="nb">*</span> <span class="nb">/</span><span class="p">)))</span>
</pre>
                                </div>
                              </div>
                              <p>这一节讨论的问题似乎只与列表有关，但实际上，这个问题存在于任何复杂的对象中：数组，字符串，结构，实例等。你不应该逐字地去修改程序的代码段。</p>
                              <p>
                                即使你想写自修改程序，通过修改常量来实现并不是个好办法。编译器将常量编译成了代码，破坏性的操作可能修改它们的参数，但这些都是没有任何保证的事情。如果你想写自修改程序，正确的方法是使用闭包
                                (见 6.5 节)。</p>
                            </div>
                            <div class="section" id="chapter-12-summary">
                              <h4>Chapter 12 总结 (Summary)<a class="headerlink" href="#chapter-12-summary"
                                  title="Permalink to this headline">¶</a></h4>
                              <ol class="arabic simple">
                                <li>两个列表可以共享一个尾端。多个列表可以以树的形式共享结构，而不是共享顶层列表结构。可通过拷贝方式来避免共用结构。</li>
                                <li>共享结构通常可以被忽略，但如果你要修改列表，则需要特别注意。因为修改一个含共享结构的列表可能修改所有共享该结构的列表。</li>
                                <li>队列可以被表示成一个 <code class="docutils literal"><span class="pre">cons</span></code> ，其的
                                  <code class="docutils literal"><span class="pre">car</span></code> 指向队列的第一个元素， <code
                                    class="docutils literal"><span class="pre">cdr</span></code> 指向队列的最后一个元素。
                                </li>
                                <li>为了提高效率，破坏性函数允许修改其输入参数。</li>
                                <li>在某些应用中，破坏性的实现更适用。</li>
                                <li>列表可以是 <code class="docutils literal"><span class="pre">car-circular</span></code> 或
                                  <code class="docutils literal"><span class="pre">cdr-circular</span></code> 。 Lisp
                                  可以表示圆形结构和共享结构。
                                </li>
                                <li>不应该去修改的程序代码段中的常量形式。</li>
                              </ol>
                            </div>
                            <div class="section" id="chapter-12-exercises">
                              <h4>Chapter 12 练习 (Exercises)<a class="headerlink" href="#chapter-12-exercises"
                                  title="Permalink to this headline">¶</a></h4>
                              <ol class="arabic simple">
                                <li>画三个不同的树，能够被打印成 <code
                                    class="docutils literal"><span class="pre">((A)</span> <span class="pre">(A)</span> <span class="pre">(A))</span></code>
                                  。写一个表达式来生成它们。</li>
                                <li>假设 <code class="docutils literal"><span class="pre">make-queue</span></code> ， <code
                                    class="docutils literal"><span class="pre">enqueue</span></code> 和 <code
                                    class="docutils literal"><span class="pre">dequeue</span></code> 是按照图 12.7
                                  中的定义，用箱子表式法画出下面每一步所得到的队列的结构图：</li>
                              </ol>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">setf</span> <span class="nv">q</span> <span class="p">(</span><span class="nv">make-queue</span><span class="p">))</span>
<span class="p">(</span><span class="no">NIL</span><span class="p">)</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="nv">enqueue</span> <span class="ss">&#39;a</span> <span class="nv">q</span><span class="p">)</span>
<span class="p">(</span><span class="nv">A</span><span class="p">)</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="nv">enqueue</span> <span class="ss">&#39;b</span> <span class="nv">q</span><span class="p">)</span>
<span class="p">(</span><span class="nv">A</span> <span class="nv">B</span><span class="p">)</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="nv">dequeue</span> <span class="nv">q</span><span class="p">)</span>
<span class="nv">A</span>
</pre>
                                </div>
                              </div>
                              <ol class="arabic simple" start="3">
                                <li>定义一个函数 <code class="docutils literal"><span class="pre">copy-queue</span></code>
                                  ，可以返回一个 queue 的拷贝。</li>
                                <li>定义一个函数，接受两个输入参数 <code
                                    class="docutils literal"><span class="pre">object</span></code> 和 <code
                                    class="docutils literal"><span class="pre">queue</span></code> ，能将 <code
                                    class="docutils literal"><span class="pre">object</span></code> 插入到 <code
                                    class="docutils literal"><span class="pre">queue</span></code> 的首端。</li>
                                <li>定义一个函数，接受两个输入参数 <code
                                    class="docutils literal"><span class="pre">object</span></code> 和 <code
                                    class="docutils literal"><span class="pre">queue</span></code>，能具有破坏性地将 <code
                                    class="docutils literal"><span class="pre">object</span></code> 的第一个实例 ( <code
                                    class="docutils literal"><span class="pre">eql</span></code> 等价地) 移到 <code
                                    class="docutils literal"><span class="pre">queue</span></code> 的首端。</li>
                                <li>定义一个函数，接受两个输入参数 <code
                                    class="docutils literal"><span class="pre">object</span></code> 和 <code
                                    class="docutils literal"><span class="pre">lst</span></code> ( <code
                                    class="docutils literal"><span class="pre">lst</span></code> 可能是 <code
                                    class="docutils literal"><span class="pre">cdr-circular</span></code> 列表)，如果 <code
                                    class="docutils literal"><span class="pre">object</span></code> 是 <code
                                    class="docutils literal"><span class="pre">lst</span></code> 的成员时返回真。</li>
                                <li>定义一个函数，如果它的参数是一个 <code
                                    class="docutils literal"><span class="pre">cdr-circular</span></code> 则返回真。</li>
                                <li>定义一个函数，如果它的参数是一个 <code
                                    class="docutils literal"><span class="pre">car-circular</span></code> 则返回真。</li>
                              </ol>
                              <p class="rubric">脚注</p>
                              <table class="docutils footnote" frame="void" id="id6" rules="none">
                                <colgroup>
                                  <col class="label" />
                                  <col />
                                </colgroup>
                                <tbody valign="top">
                                  <tr>
                                    <td class="label">[1]</td>
                                    <td>比如，在 Common Lisp
                                      中，修改一个被用作符号名的字符串被认为是一种错误，因为内部的定义并没声明它是从参数复制来的，所以必须假定修改传入内部的任何参数中的字符串来创建新的符号是错误的。
                                    </td>
                                  </tr>
                                </tbody>
                              </table>
                              <table class="docutils footnote" frame="void" id="id7" rules="none">
                                <colgroup>
                                  <col class="label" />
                                  <col />
                                </colgroup>
                                <tbody valign="top">
                                  <tr>
                                    <td class="label">[2]</td>
                                    <td>函数名称中 n 的含义是 “non-consing”。一些具有破坏性的函数以 n 开头。</td>
                                  </tr>
                                </tbody>
                              </table>
                            </div>
                          </div>
                          <div class="section">
                            <h3 id="13">第十三章：速度</h3>
                            <p>Lisp 实际上是两种语言：一种能写出快速执行的程序，一种则能让你快速的写出程序。
                              在程序开发的早期阶段，你可以为了开发上的便捷舍弃程序的执行速度。一旦程序的结构开始固化，你就可以精炼其中的关键部分以使得它们执行的更快。</p>
                            <p>由于各个 Common Lisp
                              实现间的差异，很难针对优化给出通用的建议。在一个实现上使程序变快的修改也许在另一个实现上会使得程序变慢。这是难免的事儿。越强大的语言，离机器底层就越远，离机器底层越远，语言的不同实现沿着不同路径趋向它的可能性就越大。因此，即便有一些技巧几乎一定能够让程序运行的更快，本章的目的也只是建议而不是规定。
                            </p>
                            <div class="section" id="the-bottleneck-rule">
                              <h4>13.1 瓶颈规则 (The Bottleneck Rule)<a class="headerlink" href="#the-bottleneck-rule"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>不管是什么实现，关于优化都可以整理出三点规则：它应该关注瓶颈，它不应该开始的太早，它应该始于算法。</p>
                              <p>也许关于优化最重要的事情就是要意识到，程序中的大部分执行时间都是被少数瓶颈所消耗掉的。
                                正如<a class="reference external"
                                  href="http://en.wikipedia.org/wiki/Donald_Knuth">高德纳</a>所说，“在一个与 I/O 无关 (Non-I/O
                                bound) 的程序中，大部分的运行时间集中在大概 3% 的源代码中。” <a class="reference external"
                                  href="http://acl.readthedocs.org/en/latest/zhCN/notes-cn.html#notes-213">λ</a>
                                优化程序的这一部分将会使得它的运行速度明显的提升；相反，优化程序的其他部分则是在浪费时间。</p>
                              <p>因此，优化程序时关键的第一步就是找到瓶颈。许多 Lisp 实现都提供性能分析器 (profiler) 来监视程序的运行并报告每一部分所花费的时间量。
                                为了写出最为高效的代码，性能分析器非常重要，甚至是必不可少的。
                                如果你所使用的 Lisp 实现带有性能分析器，那么请在进行优化时使用它。另一方面，如果实现没有提供性能分析器的话，那么你就不得不通过猜测来寻找瓶颈，而且这种猜测往往都是错的！
                              </p>
                              <p>瓶颈规则的一个推论是，不应该在程序的初期花费太多的精力在优化上。<a class="reference external"
                                  href="http://en.wikipedia.org/wiki/Donald_Knuth">高德纳</a>对此深信不疑：“过早的优化是一切 (至少是大多数)
                                问题的源头。” <a class="reference external"
                                  href="http://acl.readthedocs.org/en/latest/zhCN/notes-cn.html#notes-214">λ</a>
                                在刚开始写程序的时候，通常很难看清真正的瓶颈在哪，如果这个时候进行优化，你很可能是在浪费时间。优化也会使程序的修改变得更加困难，边写程序边优化就像是在用风干非常快的颜料来画画一样。
                              </p>
                              <p>在适当的时候做适当的事情，可以让你写出更优秀的程序。
                                Lisp 的一个优点就是能让你用两种不同的工作方式来进行开发：很快地写出运行较慢的代码，或者，放慢写程序的速度，精雕细琢，从而得出运行得较快的代码。</p>
                              <p>在程序开发的初期阶段，工作通常在第一种模式下进行，只有当性能成为问题的时候，才切换到第二种模式。
                                对于非常底层的语言，比如汇编，你必须优化程序的每一行。但这么做会浪费你大部分的精力，因为瓶颈仅仅是其中很小的那部分代码。一个更加抽象的语言能够让你把主要精力集中在瓶颈上，
                                达到事半功倍的效果。</p>
                              <p>当真正开始优化的时候，还必须从最顶端入手。
                                在使用各种低层次的编码技巧 (low-level coding tricks) 之前，请先确保你已经使用了最为高效的算法。
                                这么做的潜在好处相当大 ── 甚至可能大到你都不再需要玩那些奇淫技巧。
                                当然本规则还是要和前一个规则保持平衡。
                                有些时候，关于算法的决策必须尽早进行。</p>
                            </div>
                            <div class="section" id="compilation">
                              <h4>13.2 编译 (Compilation)<a class="headerlink" href="#compilation"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>有五个参数可以控制代码的编译方式： <em>speed</em> (速度)代表编译器产生代码的速度； <em>compilation-speed</em>
                                (编译速度)代表程序被编译的速度； <em>safety</em> (安全) 代表要对目标代码进行错误检查的数量； <em>space</em>
                                (空间)代表目标代码的大小和内存需求量；最后， <em>debug</em> (调试)代表为了调试而保留的信息量。</p>
                              <div class="admonition note">
                                <p class="first admonition-title">Note</p>
                                <p>交互与解释 (INTERACTIVE VS. INTERPRETED)</p>
                                <p>Lisp 是一种交互式语言 (Interactive Language)，但是交互式的语言不必都是解释型的。早期的 Lisp 都通过解释器实现，因此认为 Lisp
                                  的特质都依赖于它是被解释的想法就这么产生了。但这种想法是错误的：Common Lisp 既是编译型语言，又是解释型语言。</p>
                                <p class="last">至少有两种 Common Lisp
                                  实现甚至都不包含解释器。在这些实现中，输入到顶层的表达式在求值前会被编译。因此，把顶层叫做解释器的这种说法，不仅是落伍的，甚至还是错误的。</p>
                              </div>
                              <p>编译参数不是真正的变量。它们在声明中被分配从 <code class="docutils literal"><span class="pre">0</span></code>
                                (最不重要) 到 <code class="docutils literal"><span class="pre">3</span></code> (最重要)
                                的权值。如果一个主要的瓶颈发生在某个函数的内层循环中，我们或许可以添加如下的声明：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">bottleneck</span> <span class="p">(</span><span class="o">...</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">do</span> <span class="p">(</span><span class="o">...</span><span class="p">)</span>
      <span class="p">(</span><span class="o">...</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">do</span> <span class="p">(</span><span class="o">...</span><span class="p">)</span>
        <span class="p">(</span><span class="o">...</span><span class="p">)</span>
      <span class="p">(</span><span class="k">declare</span> <span class="p">(</span><span class="k">optimize</span> <span class="p">(</span><span class="nv">speed</span> <span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="nv">safety</span> <span class="mi">0</span><span class="p">)))</span>
      <span class="o">...</span><span class="p">)))</span>
</pre>
                                </div>
                              </div>
                              <p>一般情况下，应该在代码写完并且经过完善测试之后，才考虑加上那么一句声明。</p>
                              <p>要让代码在任何情况下都尽可能地快，可以使用如下声明：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">declaim</span> <span class="p">(</span><span class="k">optimize</span> <span class="p">(</span><span class="nv">speed</span> <span class="mi">3</span><span class="p">)</span>
                   <span class="p">(</span><span class="nv">compilation-speed</span> <span class="mi">0</span><span class="p">)</span>
                   <span class="p">(</span><span class="nv">safety</span> <span class="mi">0</span><span class="p">)</span>
                   <span class="p">(</span><span class="nv">debug</span> <span class="mi">0</span><span class="p">)))</span>
</pre>
                                </div>
                              </div>
                              <p>考虑到前面提到的瓶颈规则 <a class="footnote-reference" href="#id9" id="id4">[1]</a>
                                ，这种苛刻的做法可能并没有什么必要。</p>
                              <p>另一类特别重要的优化就是由 Lisp 编译器完成的尾递归优化。当 <em>speed</em> (速度)的权值最大时，所有支持尾递归优化的编译器都将保证对代码进行这种优化。
                              </p>
                              <p>如果在一个调用返回时调用者中没有残余的计算，该调用就被称为尾递归。下面的代码返回列表的长度：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">length/r</span> <span class="p">(</span><span class="nv">lst</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">null</span> <span class="nv">lst</span><span class="p">)</span>
      <span class="mi">0</span>
      <span class="p">(</span><span class="nb">1+</span> <span class="p">(</span><span class="nv">length/r</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">lst</span><span class="p">)))))</span>
</pre>
                                </div>
                              </div>
                              <p>这个递归调用不是尾递归，因为当它返回以后，它的值必须传给 <code
                                  class="docutils literal"><span class="pre">1+</span></code> 。相反，这是一个尾递归的版本，</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">length/rt</span> <span class="p">(</span><span class="nv">lst</span><span class="p">)</span>
  <span class="p">(</span><span class="k">labels</span> <span class="p">((</span><span class="nv">len</span> <span class="p">(</span><span class="nv">lst</span> <span class="nv">acc</span><span class="p">)</span>
             <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">null</span> <span class="nv">lst</span><span class="p">)</span>
                 <span class="nv">acc</span>
                 <span class="p">(</span><span class="nv">len</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">lst</span><span class="p">)</span> <span class="p">(</span><span class="nb">1+</span> <span class="nv">acc</span><span class="p">)))))</span>
    <span class="p">(</span><span class="nv">len</span> <span class="nv">lst</span> <span class="mi">0</span><span class="p">)))</span>
</pre>
                                </div>
                              </div>
                              <p>更准确地说，局部函数 <code class="docutils literal"><span class="pre">len</span></code>
                                是尾递归调用，因为当它返回时，调用函数已经没什么事情可做了。
                                和 <code class="docutils literal"><span class="pre">length/r</span></code>
                                不同的是，它不是在递归回溯的时候构建返回值，而是在递归调用的过程中积累返回值。
                                在函数的最后一次递归调用结束之后， <code class="docutils literal"><span class="pre">acc</span></code>
                                参数就可以作为函数的结果值被返回。</p>
                              <p>出色的编译器能够将一个尾递归编译成一个跳转 (goto)，因此也能将一个尾递归函数编译成一个循环。在典型的机器语言代码中，当第一次执行到表示 <code
                                  class="docutils literal"><span class="pre">len</span></code>
                                的指令片段时，栈上会有信息指示在返回时要做些什么。由于在递归调用后没有残余的计算，该信息对第二层调用仍然有效：第二层调用返回后我们要做的仅仅就是从第一层调用返回。
                                因此，当进行第二层调用时，我们只需给参数设置新的值，然后跳转到函数的起始处继续执行就可以了，没有必要进行真正的函数调用。</p>
                              <p>
                                另一个利用函数调用抽象，却没有开销的方法是使函数内联编译。对于那些调用开销比函数体的执行代价还高的小型函数来说，这种技术非常有价值。例如，以下代码用于判断列表是否仅有一个元素：
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">declaim</span> <span class="p">(</span><span class="k">inline</span> <span class="nv">single?</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">single?</span> <span class="p">(</span><span class="nv">lst</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nb">consp</span> <span class="nv">lst</span><span class="p">)</span> <span class="p">(</span><span class="nb">null</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">lst</span><span class="p">))))</span>
</pre>
                                </div>
                              </div>
                              <p>因为这个函数是在全局被声明为内联的，引用了 <code
                                  class="docutils literal"><span class="pre">single?</span></code> 的函数在编译后将不需要真正的函数调用。
                                <a class="footnote-reference" href="#id10" id="id5">[2]</a> 如果我们定义一个调用它的函数，
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">foo</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">single?</span> <span class="p">(</span><span class="nv">bar</span> <span class="nv">x</span><span class="p">)))</span>
</pre>
                                </div>
                              </div>
                              <p>当 <code class="docutils literal"><span class="pre">foo</span></code> 被编译后， <code
                                  class="docutils literal"><span class="pre">single?</span></code> 函数体中的代码将会被编译进 <code
                                  class="docutils literal"><span class="pre">foo</span></code> 的函数体，就好像我们直接写以下代码一样：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">foo</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">lst</span> <span class="p">(</span><span class="nv">bar</span> <span class="nv">x</span><span class="p">)))</span>
    <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nb">consp</span> <span class="nv">lst</span><span class="p">)</span> <span class="p">(</span><span class="nb">null</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">lst</span><span class="p">)))))</span>
</pre>
                                </div>
                              </div>
                              <p>内联编译有两个限制：
                                首先，递归函数不能内联。
                                其次，如果一个内联函数被重新定义，我们就必须重新编译调用它的任何函数，否则调用仍然使用原来的定义。</p>
                              <p>在一些早期的 Lisp 方言中，有时候会使用宏（ 10.2 节）来避免函数调用。这种做法在 Common Lisp 中通常是没有必要的。</p>
                              <p>不同 Lisp 编译器的优化方式千差万别。
                                如果你想了解你的编译器为某个函数生成的代码，试着调用 <code
                                  class="docutils literal"><span class="pre">disassemble</span></code>
                                函数：它接受一个函数或者函数名，并显示该函数编译后的形式。
                                即便你看到的东西是完全无法理解的，你仍然可以使用 <code
                                  class="docutils literal"><span class="pre">disassemble</span></code>
                                来判断声明是否起效果：编译函数的两个版本，一个使用优化声明，另一个不使用优化声明，然后观察由 <code
                                  class="docutils literal"><span class="pre">disassemble</span></code> 显示的两组代码之间是否有差异。
                                同样的技巧也可以用于检验函数是否被内联编译。
                                不论情况如何，都请优先考虑使用编译参数，而不是手动调优的方式来优化代码。</p>
                            </div>
                            <div class="section" id="type-declarations">
                              <h4>13.3 类型声明 (Type Declarations)<a class="headerlink" href="#type-declarations"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>如果 Lisp 不是你所学的第一门编程语言，那么你也许会感到困惑，为什么这本书还没说到类型声明这件事来？毕竟，在很多流行的编程语言中，类型声明是必须要做的。</p>
                              <p>在不少编程语言里，你必须为每个变量声明类型，并且变量也只可以持有与该类型相一致的值。
                                这种语言被称为<em>强类型</em>(<em>strongly typed</em>) 语言。
                                除了给程序员们徒增了许多负担外，这种方式还限制了你能做的事情。
                                使用这种语言，很难写出那些需要多种类型的参数一起工作的函数，也很难定义出可以包含不同种类元素的数据结构。
                                当然，这种方式也有它的优势，比如无论何时当编译器碰到一个加法运算，它都能够事先知道这是一个什么类型的加法运算。如果两个参数都是整数类型，编译器可以直接在目标代码中生成一个固定
                                (hard-wire) 的整数加法运算。</p>
                              <p>正如 2.15 节所讲，Common Lisp 使用一种更加灵活的方式：显式类型 (manifest typing) <a
                                  class="footnote-reference" href="#id11" id="id6">[3]</a> 。有类型的是值而不是变量。变量可以用于任何类型的对象。
                              </p>
                              <p>当然，这种灵活性需要付出一定的速度作为代价。
                                由于 <code class="docutils literal"><span class="pre">+</span></code>
                                可以接受好几种不同类型的数，它不得不在运行时查看每个参数的类型来决定采用哪种加法运算。</p>
                              <p>在某些时候，如果我们要执行的全都是整数的加法，那么每次查看参数类型的这种做法就说不上高效了。
                                Common Lisp 处理这种问题的方法是：让程序员尽可能地提示编译器。
                                比如说，如果我们提前就能知道某个加法运算的两个参数是定长数 (fixnums) ，那么就可以对此进行声明，这样编译器就会像 C 语言的那样为我们生成一个固定的整数加法运算。
                              </p>
                              <p>因为显式类型也可以通过声明类型来生成高效的代码，所以强类型和显式类型两种方式之间的差别并不在于运行速度。
                                真正的区别是，在强类型语言中，类型声明是强制性的，而显式类型则不强加这样的要求。
                                在 Common Lisp 中，类型声明完全是可选的。它们可以让程序运行的更快，但(除非错误)不会改变程序的行为。</p>
                              <p>全局声明以 <code class="docutils literal"><span class="pre">declaim</span></code>
                                伴随一个或多个声明的形式来实现。一个类型声明是一个列表，包含了符号 <code
                                  class="docutils literal"><span class="pre">type</span></code>
                                ，后跟一个类型名，以及一个或多个变量组成。举个例子，要为一个全局变量声明类型，可以这么写：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">declaim</span> <span class="p">(</span><span class="k">type</span> <span class="kt">fixnum</span> <span class="vg">*count*</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p>在 ANSI Common Lisp 中，可以省略 <code
                                  class="docutils literal"><span class="pre">type</span></code> 符号，将声明简写为：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">declaim</span> <span class="p">(</span><span class="kt">fixnum</span> <span class="vg">*count*</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p>局部声明通过 <code class="docutils literal"><span class="pre">declare</span></code>
                                完成，它接受的参数和 <code class="docutils literal"><span class="pre">declaim</span></code> 的一样。
                                声明可以放在那些创建变量的代码体之前：如 <code
                                  class="docutils literal"><span class="pre">defun</span></code> 、 <code
                                  class="docutils literal"><span class="pre">lambda</span></code> 、 <code
                                  class="docutils literal"><span class="pre">let</span></code> 、 <code
                                  class="docutils literal"><span class="pre">do</span></code> ，诸如此类。
                                比如说，要把一个函数的参数声明为定长数，可以这么写：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">poly</span> <span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">x</span><span class="p">)</span>
  <span class="p">(</span><span class="k">declare</span> <span class="p">(</span><span class="kt">fixnum</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">x</span><span class="p">))</span>
  <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">a</span> <span class="p">(</span><span class="nb">expt</span> <span class="nv">x</span> <span class="mi">2</span><span class="p">))</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">b</span> <span class="nv">x</span><span class="p">)))</span>
</pre>
                                </div>
                              </div>
                              <p>在类型声明中的变量名指的就是该声明所在的上下文中的那个变量 ── 那个通过赋值可以改变它的值的变量。</p>
                              <p>你也可以通过 <code class="docutils literal"><span class="pre">the</span></code> 为某个表达式的值声明类型。
                                如果我们提前就知道 <code class="docutils literal"><span class="pre">a</span></code> 、 <code
                                  class="docutils literal"><span class="pre">b</span></code> 和 <code
                                  class="docutils literal"><span class="pre">x</span></code>
                                是足够小的定长数，并且它们的和也是定长数的话，那么可以进行以下声明：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">poly</span> <span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">x</span><span class="p">)</span>
  <span class="p">(</span><span class="k">declare</span> <span class="p">(</span><span class="kt">fixnum</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">x</span><span class="p">))</span>
  <span class="p">(</span><span class="k">the</span> <span class="kt">fixnum</span> <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="k">the</span> <span class="kt">fixnum</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">a</span> <span class="p">(</span><span class="k">the</span> <span class="kt">fixnum</span> <span class="p">(</span><span class="nb">expt</span> <span class="nv">x</span> <span class="mi">2</span><span class="p">))))</span>
                 <span class="p">(</span><span class="k">the</span> <span class="kt">fixnum</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">b</span> <span class="nv">x</span><span class="p">)))))</span>
</pre>
                                </div>
                              </div>
                              <p>看起来是不是很笨拙啊？幸运的是有两个原因让你很少会这样使用 <code
                                  class="docutils literal"><span class="pre">the</span></code>
                                把你的数值运算代码变得散乱不堪。其一是很容易通过宏，来帮你插入这些声明。其二是某些实现使用了特殊的技巧，即便没有类型声明的定长数运算也能足够快。</p>
                              <p>Common Lisp 中有相当多的类型 ── 恐怕有无数种类型那么多，如果考虑到你可以自己定义新的类型的话。
                                类型声明只在少数情况下至关重要，可以遵照以下两条规则来进行：</p>
                              <ol class="arabic simple">
                                <li>当函数可以接受若干不同类型的参数(但不是所有类型)时，可以对参数的类型进行声明。如果你知道一个对 <code
                                    class="docutils literal"><span class="pre">+</span></code> 的调用总是接受定长数类型的参数，或者一个对
                                  <code class="docutils literal"><span class="pre">aref</span></code>
                                  的调用第一个参数总是某种特定种类的数组，那么进行类型声明是值得的。
                                </li>
                                <li>通常来说，只有对类型层级中接近底层的类型进行声明，才是值得的：将某个东西的类型声明为 <code
                                    class="docutils literal"><span class="pre">fixnum</span></code> 或者 <code
                                    class="docutils literal"><span class="pre">simple-array</span></code>
                                  也许有用，但将某个东西的类型声明为 <code
                                    class="docutils literal"><span class="pre">integer</span></code> 或者 <code
                                    class="docutils literal"><span class="pre">sequence</span></code> 或许就没用了。</li>
                              </ol>
                              <p>
                                类型声明对内容复杂的对象特别重要，这包括数组、结构和对象实例。这些声明可以在两个方面提升效率：除了可以让编译器来决定函数参数的类型以外，它们也使得这些对象可以在内存中更高效地表示。
                              </p>
                              <p>如果对数组元素的类型一无所知的话，这些元素在内存中就不得不用一块指针来表示。但假如预先就知道数组包含的元素仅仅是 ── 比方说 ── 双精度浮点数
                                (double-floats)，那么这个数组就可以用一组实际的双精度浮点数来表示。这样数组将占用更少的空间，因为我们不再需要额外的指针指向每一个双精度浮点数；同时，对数组元素的访问也将更快，因为我们不必沿着指针去读取和写元素。
                              </p>
                              <img alt="_images/Figure-13.1.png" src="_images/Figure-13.1.png" />
                              <p><strong>图 13.1：指定元素类型的效果</strong></p>
                              <p>你可以通过 <code class="docutils literal"><span class="pre">make-array</span></code> 的 <code
                                  class="docutils literal"><span class="pre">:element-type</span></code>
                                参数指定数组包含值的种类。这样的数组被称为<em>特化数组</em>(specialized array)。
                                图 13.1 为我们展示了如下代码在多数实现上求值后发生的事情：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre>(setf x (vector 1.234d0 2.345d0 3.456d0)
      y (make-array 3 :element-type &#39;double-float)
      (aref y 0) 1.234d0
      (aref y 1) 2.345d0
      (aref y 2）3.456d0))
</pre>
                                </div>
                              </div>
                              <p>图 13.1 中的每一个矩形方格代表内存中的一个字 (a word of memory)。这两个数组都由未特别指明长度的头部 (header) 以及后续
                                三个元素的某种表示构成。对于 <code class="docutils literal"><span class="pre">x</span></code>
                                来说，每个元素都由一个指针表示。此时每个指针碰巧都指向双精度浮点数，但实际上我们可以存储任何类型的对象到这个向量中。对 <code
                                  class="docutils literal"><span class="pre">y</span></code> 来说，每个元素实际上都是双精度浮点数。 <code
                                  class="docutils literal"><span class="pre">y</span></code>
                                更快而且占用更少空间，但意味着它的元素只能是双精度浮点数。</p>
                              <p>注意我们使用 <code class="docutils literal"><span class="pre">aref</span></code> 来引用 <code
                                  class="docutils literal"><span class="pre">y</span></code>
                                的元素。一个特化的向量不再是一个简单向量，因此我们不再能够通过 <code
                                  class="docutils literal"><span class="pre">svref</span></code> 来引用它的元素。</p>
                              <p>除了在创建数组时指定元素的类型，你还应该在使用数组的代码中声明数组的维度以及它的元素类型。一个完整的向量声明如下：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="k">declare</span> <span class="p">(</span><span class="k">type</span> <span class="p">(</span><span class="nb">vector</span> <span class="kt">fixnum</span> <span class="mi">20</span><span class="p">)</span> <span class="nv">v</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p>以上代码声明了一个仅含有定长数，并且长度固定为 <code
                                  class="docutils literal"><span class="pre">20</span></code> 的向量。</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">setf</span> <span class="nv">a</span> <span class="p">(</span><span class="nb">make-array</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1000</span> <span class="mi">1000</span><span class="p">)</span>
                    <span class="ss">:element-type</span> <span class="ss">&#39;single-float</span>
                    <span class="ss">:initial-element</span> <span class="mf">1.0s0</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">sum-elts</span> <span class="p">(</span><span class="nv">a</span><span class="p">)</span>
  <span class="p">(</span><span class="k">declare</span> <span class="p">(</span><span class="k">type</span> <span class="p">(</span><span class="kt">simple-array</span> <span class="kt">single-float</span> <span class="p">(</span><span class="mi">1000</span> <span class="mi">1000</span><span class="p">))</span>
                 <span class="nv">a</span><span class="p">))</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">sum</span> <span class="mf">0.0s0</span><span class="p">))</span>
    <span class="p">(</span><span class="k">declare</span> <span class="p">(</span><span class="k">type</span> <span class="kt">single-float</span> <span class="nv">sum</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">dotimes</span> <span class="p">(</span><span class="nv">r</span> <span class="mi">1000</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">dotimes</span> <span class="p">(</span><span class="nv">c</span> <span class="mi">1000</span><span class="p">)</span>
        <span class="p">(</span><span class="nb">incf</span> <span class="nv">sum</span> <span class="p">(</span><span class="nb">aref</span> <span class="nv">a</span> <span class="nv">r</span> <span class="nv">c</span><span class="p">))))</span>
    <span class="nv">sum</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p><strong>图 13.2 对数组元素求和</strong></p>
                              <p>最为通用的数组声明形式由数组类型以及紧接其后的元素类型和一个维度列表构成：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="k">declare</span> <span class="p">(</span><span class="k">type</span> <span class="p">(</span><span class="kt">simple-array</span> <span class="kt">fixnum</span> <span class="p">(</span><span class="mi">4</span> <span class="mi">4</span><span class="p">))</span> <span class="nv">ar</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p>图 13.2 展示了如何创建一个 1000×1000 的单精度浮点数数组，以及如何编写一个将该数组元素相加的函数。数组以行主序 (row-major
                                order)存储，遍历时也应尽可能按此顺序进行。</p>
                              <p>我们将用 <code class="docutils literal"><span class="pre">time</span></code> 来比较 <code
                                  class="docutils literal"><span class="pre">sum-elts</span></code> 在有声明和无声明两种情况下的性能。
                                <code class="docutils literal"><span class="pre">time</span></code>
                                宏显示表达式求值所花费时间的某种度量(取决于实现)。对被编译的函数求取时间才是有意义的。在某个实现中，如果我们以获取最快速代码的编译参数编译 <code
                                  class="docutils literal"><span class="pre">sum-elts</span></code> ，它将在不到半秒的时间内返回：
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">time</span> <span class="p">(</span><span class="nv">sum-elts</span> <span class="nv">a</span><span class="p">))</span>
<span class="nv">User</span> <span class="nv">Run</span> <span class="nv">Time</span> <span class="nb">=</span> <span class="mf">0.43</span> <span class="nv">seconds</span>
<span class="mf">1000000.0</span>
</pre>
                                </div>
                              </div>
                              <p>如果我们把 <em>sum-elts</em> 中的类型声明去掉并重新编译它，同样的计算将花费超过5秒的时间：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">time</span> <span class="p">(</span><span class="nv">sum-elts</span> <span class="nv">a</span><span class="p">))</span>
<span class="nv">User</span> <span class="nv">Run</span> <span class="nv">Time</span> <span class="nb">=</span> <span class="mf">5.17</span> <span class="nv">seconds</span>
<span class="mf">1000000.0</span>
</pre>
                                </div>
                              </div>
                              <p>类型声明的重要性 ── 特别是对数组和数来说 ── 怎么强调都不过分。上面的例子中，仅仅两行代码就可以让 <code
                                  class="docutils literal"><span class="pre">sum-elts</span></code> 变快 12 倍。</p>
                            </div>
                            <div class="section" id="garbage-avoidance">
                              <h4>13.4 避免垃圾 (Garbage Avoidance)<a class="headerlink" href="#garbage-avoidance"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>Lisp 除了可以让你推迟考虑变量的类型以外，它还允许你推迟对内存分配的考虑。
                                在程序的早期阶段，暂时忽略内存分配和臭虫等问题，将有助于解放你的想象力。
                                等到程序基本固定下来以后，就可以开始考虑怎么减少动态分配，从而让程序运行得更快。</p>
                              <p>但是，并不是构造（consing）用得少的程序就一定快。
                                多数 Lisp 实现一直使用着差劲的垃圾回收器，在这些实现中，过多的内存分配容易让程序运行变得缓慢。
                                因此，『高效的程序应该尽可能地减少 <code class="docutils literal"><span class="pre">cons</span></code>
                                的使用』这种观点，逐渐成为了一种传统。
                                最近这种传统开始有所改变，因为一些实现已经用上了相当先进（sophisticated）的垃圾回收器，它们实行一种更为高效的策略：创建新的对象，用完之后抛弃而不是进行回收。
                              </p>
                              <p>本节介绍了几种方法，用于减少程序中的构造。
                                但构造数量的减少是否有利于加快程序的运行，这一点最终还是取决于实现。
                                最好的办法就是自己去试一试。</p>
                              <p>减少构造的办法有很多种。
                                有些办法对程序的修改非常少。
                                例如，最简单的方法就是使用破坏性函数。
                                下表罗列了一些常用的函数，以及这些函数对应的破坏性版本。</p>
                              <table border="1" class="docutils">
                                <colgroup>
                                  <col width="50%" />
                                  <col width="50%" />
                                </colgroup>
                                <thead valign="bottom">
                                  <tr class="row-odd">
                                    <th class="head">安全</th>
                                    <th class="head">破坏性</th>
                                  </tr>
                                </thead>
                                <tbody valign="top">
                                  <tr class="row-even">
                                    <td>append</td>
                                    <td>nconc</td>
                                  </tr>
                                  <tr class="row-odd">
                                    <td>reverse</td>
                                    <td>nreverse</td>
                                  </tr>
                                  <tr class="row-even">
                                    <td>remove</td>
                                    <td>delete</td>
                                  </tr>
                                  <tr class="row-odd">
                                    <td>remove-if</td>
                                    <td>delete-if</td>
                                  </tr>
                                  <tr class="row-even">
                                    <td>remove-duplicates</td>
                                    <td>delete-duplicates</td>
                                  </tr>
                                  <tr class="row-odd">
                                    <td>subst</td>
                                    <td>nsubst</td>
                                  </tr>
                                  <tr class="row-even">
                                    <td>subst-if</td>
                                    <td>nsubst-if</td>
                                  </tr>
                                  <tr class="row-odd">
                                    <td>union</td>
                                    <td>nunion</td>
                                  </tr>
                                  <tr class="row-even">
                                    <td>intersection</td>
                                    <td>nintersection</td>
                                  </tr>
                                  <tr class="row-odd">
                                    <td>set-difference</td>
                                    <td>nset-difference</td>
                                  </tr>
                                </tbody>
                              </table>
                              <p>当确认修改列表是安全的时候，可以使用 <code
                                  class="docutils literal"><span class="pre">delete</span></code> 替换 <code
                                  class="docutils literal"><span class="pre">remove</span></code> ，用 <code
                                  class="docutils literal"><span class="pre">nreverse</span></code> 替换 <code
                                  class="docutils literal"><span class="pre">reverse</span></code> ，诸如此类。</p>
                              <p>即便你想完全摆脱构造，你也不必放弃在运行中 (on the fly)创建对象的可能性。
                                你需要做的是避免在运行中为它们分配空间和通过垃圾回收收回空间。通用方案是你自己预先分配内存块 (block of
                                memory)，以及明确回收用过的块。<em>预先</em>可能意味着在编译期或者某些初始化例程中。具体情况还应具体分析。</p>
                              <p>例如，当情况允许我们利用一个有限大小的堆栈时，我们可以让堆栈在一个已经分配了空间的向量中增长或缩减，而不是构造它。Common Lisp
                                内置支持把向量作为堆栈使用。如果我们传给 <code
                                  class="docutils literal"><span class="pre">make-array</span></code> 可选的 <code
                                  class="docutils literal"><span class="pre">fill-pointer</span></code>
                                参数，我们将得到一个看起来可扩展的向量。 <code
                                  class="docutils literal"><span class="pre">make-array</span></code>
                                的第一个参数指定了分配给向量的存储量，而 <code
                                  class="docutils literal"><span class="pre">fill-pointer</span></code> 指定了初始有效长度：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">setf</span> <span class="vg">*print-array*</span> <span class="no">t</span><span class="p">)</span>
<span class="no">T</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="nb">setf</span> <span class="nv">vec</span> <span class="p">(</span><span class="nb">make-array</span> <span class="mi">10</span> <span class="ss">:fill-pointer</span> <span class="mi">2</span>
                           <span class="ss">:initial-element</span> <span class="no">nil</span><span class="p">))</span>
<span class="o">#(</span><span class="no">NIL</span> <span class="no">NIL</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>我们刚刚制造的向量对于操作序列的函数来说，仍好像只含有两个元素，</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">length</span> <span class="nv">vec</span><span class="p">)</span>
<span class="mi">2</span>
</pre>
                                </div>
                              </div>
                              <p>但它能够增长直到十个元素。因为 <code class="docutils literal"><span class="pre">vec</span></code>
                                有一个填充指针，我们可以使用 <code
                                  class="docutils literal"><span class="pre">vector-push</span></code> 和 <code
                                  class="docutils literal"><span class="pre">vector-pop</span></code>
                                函数推入和弹出元素，就像它是一个列表一样：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">vector-push</span> <span class="ss">&#39;a</span> <span class="nv">vec</span><span class="p">)</span>
<span class="mi">2</span>
<span class="nb">&gt;</span> <span class="nv">vec</span>
<span class="o">#(</span><span class="no">NIL</span> <span class="no">NIL</span> <span class="nv">A</span><span class="p">)</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="nb">vector-pop</span> <span class="nv">vec</span><span class="p">)</span>
<span class="nv">A</span>
<span class="nb">&gt;</span> <span class="nv">vec</span>
<span class="o">#(</span><span class="no">NIL</span> <span class="no">NIL</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>当我们调用 <code class="docutils literal"><span class="pre">vector-push</span></code>
                                时，它增加填充指针并返回它过去的值。只要填充指针小于 <code
                                  class="docutils literal"><span class="pre">make-array</span></code>
                                的第一个参数，我们就可以向这个向量中推入新元素；当空间用尽时， <code
                                  class="docutils literal"><span class="pre">vector-push</span></code> 返回 <code
                                  class="docutils literal"><span class="pre">nil</span></code> 。目前我们还可以向 <code
                                  class="docutils literal"><span class="pre">vec</span></code> 中推入八个元素。</p>
                              <p>使用带有填充指针的向量有一个缺点，就是它们不再是简单向量了。我们不得不使用 <code
                                  class="docutils literal"><span class="pre">aref</span></code> 来代替 <code
                                  class="docutils literal"><span class="pre">svref</span></code> 引用元素。代价需要和潜在的收益保持平衡。
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defconstant</span> <span class="nv">dict</span> <span class="p">(</span><span class="nb">make-array</span> <span class="mi">25000</span> <span class="ss">:fill-pointer</span> <span class="mi">0</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">read-words</span> <span class="p">(</span><span class="nv">from</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nb">fill-pointer</span> <span class="nv">dict</span><span class="p">)</span> <span class="mi">0</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">with-open-file</span> <span class="p">(</span><span class="nv">in</span> <span class="nv">from</span> <span class="ss">:direction</span> <span class="ss">:input</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">do</span> <span class="p">((</span><span class="nv">w</span> <span class="p">(</span><span class="nb">read-line</span> <span class="nv">in</span> <span class="no">nil</span> <span class="ss">:eof</span><span class="p">)</span>
            <span class="p">(</span><span class="nb">read-line</span> <span class="nv">in</span> <span class="no">nil</span> <span class="ss">:eof</span><span class="p">)))</span>
        <span class="p">((</span><span class="nb">eql</span> <span class="nv">w</span> <span class="ss">:eof</span><span class="p">))</span>
      <span class="p">(</span><span class="nb">vector-push</span> <span class="nv">w</span> <span class="nv">dict</span><span class="p">))))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">xform</span> <span class="p">(</span><span class="nv">fn</span> <span class="nv">seq</span><span class="p">)</span> <span class="p">(</span><span class="nb">map-into</span> <span class="nv">seq</span> <span class="nv">fn</span> <span class="nv">seq</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">write-words</span> <span class="p">(</span><span class="nv">to</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">with-open-file</span> <span class="p">(</span><span class="nv">out</span> <span class="nv">to</span> <span class="ss">:direction</span> <span class="ss">:output</span>
                          <span class="ss">:if-exists</span> <span class="ss">:supersede</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">map</span> <span class="no">nil</span> <span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span>
                 <span class="p">(</span><span class="nb">fresh-line</span> <span class="nv">out</span><span class="p">)</span>
                 <span class="p">(</span><span class="nb">princ</span> <span class="nv">x</span> <span class="nv">out</span><span class="p">))</span>
             <span class="p">(</span><span class="nv">xform</span> <span class="nf">#&#39;</span><span class="nb">nreverse</span>
                    <span class="p">(</span><span class="nb">sort</span> <span class="p">(</span><span class="nv">xform</span> <span class="nf">#&#39;</span><span class="nb">nreverse</span> <span class="nv">dict</span><span class="p">)</span>
                          <span class="nf">#&#39;</span><span class="nb">string&lt;</span><span class="p">)))))</span>
</pre>
                                </div>
                              </div>
                              <p><strong>图 13.3 生成同韵字辞典</strong></p>
                              <p>当应用涉及很长的序列时，你可以用 <code
                                  class="docutils literal"><span class="pre">map-into</span></code> 代替 <code
                                  class="docutils literal"><span class="pre">map</span></code> 。 <code
                                  class="docutils literal"><span class="pre">map-into</span></code>
                                的第一个参数不是一个序列类型，而是用来存储结果的，实际的序列。这个序列可以是该函数接受的其他序列参数中的任何一个。所以，打个比方，如果你想为一个向量的每个元素加
                                1，你可以这么写：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">setf</span> <span class="nv">v</span> <span class="p">(</span><span class="nb">map-into</span> <span class="nv">v</span> <span class="nf">#&#39;</span><span class="nb">1+</span> <span class="nv">v</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p>图 13.3 展示了一个使用大向量应用的例子：一个生成简单的同韵字辞典 (或者更确切的说，一个不完全韵辞典)的程序。函数 <code
                                  class="docutils literal"><span class="pre">read-line</span></code>
                                从一个每行仅含有一个单词的文件中读取单词，而函数 <code
                                  class="docutils literal"><span class="pre">write-words</span></code>
                                将它们按照字母的逆序打印出来。比如，输出的起始可能是</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nv">a</span> <span class="nv">amoeba</span> <span class="nv">alba</span> <span class="nv">samba</span> <span class="nv">marimba...</span>
</pre>
                                </div>
                              </div>
                              <p>结束是</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="o">...</span><span class="nv">megahertz</span> <span class="nv">gigahertz</span> <span class="nv">jazz</span> <span class="nv">buzz</span> <span class="nv">fuzz</span>
</pre>
                                </div>
                              </div>
                              <p>利用填充指针和 <code class="docutils literal"><span class="pre">map-into</span></code>
                                ，我们可以把程序写的既简单又高效。</p>
                              <p>在数值应用中要当心大数 (bignums)。大数运算需要构造，因此也就会比较慢。
                                即使程序的最后结果为大数，但是，通过调整计算，将中间结果保存在定长数中，这种优化也是有可能的。</p>
                              <p>另一个避免垃圾回收的方法是，鼓励编译器在栈上分配对象而不是在堆上。
                                如果你知道只是临时需要某个东西，你可以通过将它声明为 <code
                                  class="docutils literal"><span class="pre">dynamic</span> <span class="pre">extent</span></code>
                                来避免在堆上分配空间。</p>
                              <p>通过一个动态范围 (dynamic extent)变量声明，你告诉编译器，变量的值应该和变量保持相同的生命期。
                                什么时候值的生命期比变量长呢？这里有个例子：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">our-reverse</span> <span class="p">(</span><span class="nv">lst</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">rev</span> <span class="no">nil</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">dolist</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">lst</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">push</span> <span class="nv">x</span> <span class="nv">rev</span><span class="p">))</span>
    <span class="nv">rev</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p>在 <code class="docutils literal"><span class="pre">our-reverse</span></code>
                                中，作为参数传入的列表以逆序被收集到 <code class="docutils literal"><span class="pre">rev</span></code>
                                中。当函数返回时，变量 <code class="docutils literal"><span class="pre">rev</span></code> 将不复存在。
                                然而，它的值 ── 一个逆序的列表 ── 将继续存活：它被送回调用函数，一个知道它的命运何去何从的地方。</p>
                              <p>相比之下，考虑如下 <code class="docutils literal"><span class="pre">adjoin</span></code> 实现：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">our-adjoin</span> <span class="p">(</span><span class="nv">obj</span> <span class="nv">lst</span> <span class="k">&amp;rest</span> <span class="nv">args</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">apply</span> <span class="nf">#&#39;</span><span class="nb">member</span> <span class="nv">obj</span> <span class="nv">lst</span> <span class="nv">args</span><span class="p">)</span>
      <span class="nv">lst</span>
      <span class="p">(</span><span class="nb">cons</span> <span class="nv">obj</span> <span class="nv">lst</span><span class="p">)))</span>
</pre>
                                </div>
                              </div>
                              <p>在这个例子里，我们可以从函数的定义看出， <code
                                  class="docutils literal"><span class="pre">args</span></code> 参数中的值 (列表)
                                哪儿也没去。它不必比存储它的变量活的更久。在这种情形下把它声明为动态范围的就比较有意义。如果我们加上这样的声明：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">our-adjoin</span> <span class="p">(</span><span class="nv">obj</span> <span class="nv">lst</span> <span class="k">&amp;rest</span> <span class="nv">args</span><span class="p">)</span>
  <span class="p">(</span><span class="k">declare</span> <span class="p">(</span><span class="k">dynamic-extent</span> <span class="nv">args</span><span class="p">))</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">apply</span> <span class="nf">#&#39;</span><span class="nb">member</span> <span class="nv">obj</span> <span class="nv">lst</span> <span class="nv">args</span><span class="p">)</span>
      <span class="nv">lst</span>
      <span class="p">(</span><span class="nb">cons</span> <span class="nv">obj</span> <span class="nv">lst</span><span class="p">)))</span>
</pre>
                                </div>
                              </div>
                              <p>那么编译器就可以 (但不是必须)在栈上为 <code
                                  class="docutils literal"><span class="pre">args</span></code> 分配空间，在 <code
                                  class="docutils literal"><span class="pre">our-adjoin</span></code> 返回后，它将自动被释放。</p>
                            </div>
                            <div class="section" id="example-pools">
                              <h4>13.5 示例: 存储池 (Example: Pools)<a class="headerlink" href="#example-pools"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>对于涉及数据结构的应用，你可以通过在一个存储池
                                (pool)中预先分配一定数量的结构来避免动态分配。当你需要一个结构时，你从池中取得一份，当你用完后，再把它送回池中。为了演示存储池的使用，我们将快速的编写一段记录港口中船舶数量的程序原型
                                (prototype of a program)，然后用存储池的方式重写它。</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defparameter</span> <span class="vg">*harbor*</span> <span class="no">nil</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defstruct</span> <span class="nv">ship</span>
  <span class="nv">name</span> <span class="nv">flag</span> <span class="nv">tons</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">enter</span> <span class="p">(</span><span class="nv">n</span> <span class="nv">f</span> <span class="nv">d</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">push</span> <span class="p">(</span><span class="nv">make-ship</span> <span class="ss">:name</span> <span class="nv">n</span> <span class="ss">:flag</span> <span class="nv">f</span> <span class="ss">:tons</span> <span class="nv">d</span><span class="p">)</span>
        <span class="vg">*harbor*</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">find-ship</span> <span class="p">(</span><span class="nv">n</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">find</span> <span class="nv">n</span> <span class="vg">*harbor*</span> <span class="ss">:key</span> <span class="nf">#&#39;</span><span class="nv">ship-name</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">leave</span> <span class="p">(</span><span class="nv">n</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">setf</span> <span class="vg">*harbor*</span>
        <span class="p">(</span><span class="nb">delete</span> <span class="p">(</span><span class="nv">find-ship</span> <span class="nv">n</span><span class="p">)</span> <span class="vg">*harbor*</span><span class="p">)))</span>
</pre>
                                </div>
                              </div>
                              <p><strong>图 13.4 港口</strong></p>
                              <p>图 13.4 中展示的是第一个版本。 全局变量 <code
                                  class="docutils literal"><span class="pre">harbor</span></code> 是一个船只的列表， 每一艘船只由一个
                                <code class="docutils literal"><span class="pre">ship</span></code> 结构表示。 函数 <code
                                  class="docutils literal"><span class="pre">enter</span></code>
                                在船只进入港口时被调用； <code class="docutils literal"><span class="pre">find-ship</span></code>
                                根据给定名字 (如果有的话) 来寻找对应的船只；最后， <code
                                  class="docutils literal"><span class="pre">leave</span></code> 在船只离开港口时被调用。
                              </p>
                              <p>一个程序的初始版本这么写简直是棒呆了，但它会产生许多的垃圾。当这个程序运行时，它会在两个方面构造：当船只进入港口时，新的结构将会被分配；而 <code
                                  class="docutils literal"><span class="pre">harbor</span></code> 的每一次增大都需要使用构造。</p>
                              <p>我们可以通过在编译期分配空间来消除这两种构造的源头 (sources of consing)。图 13.5 展示了程序的第二个版本，它根本不会构造。</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defconstant</span> <span class="nv">pool</span> <span class="p">(</span><span class="nb">make-array</span> <span class="mi">1000</span> <span class="ss">:fill-pointer</span> <span class="no">t</span><span class="p">))</span>

<span class="p">(</span><span class="nb">dotimes</span> <span class="p">(</span><span class="nv">i</span> <span class="mi">1000</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nb">aref</span> <span class="nv">pool</span> <span class="nv">i</span><span class="p">)</span> <span class="p">(</span><span class="nv">make-ship</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defconstant</span> <span class="nv">harbor</span> <span class="p">(</span><span class="nb">make-hash-table</span> <span class="ss">:size</span> <span class="mi">1100</span>
                                     <span class="ss">:test</span> <span class="nf">#&#39;</span><span class="nb">eq</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">enter</span> <span class="p">(</span><span class="nv">n</span> <span class="nv">f</span> <span class="nv">d</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">s</span> <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">plusp</span> <span class="p">(</span><span class="nb">length</span> <span class="nv">pool</span><span class="p">))</span>
               <span class="p">(</span><span class="nb">vector-pop</span> <span class="nv">pool</span><span class="p">)</span>
               <span class="p">(</span><span class="nv">make-ship</span><span class="p">))))</span>
    <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nv">ship-name</span> <span class="nv">s</span><span class="p">)</span>        <span class="nv">n</span>
          <span class="p">(</span><span class="nv">ship-flag</span> <span class="nv">s</span><span class="p">)</span>        <span class="nv">f</span>
          <span class="p">(</span><span class="nv">ship-tons</span> <span class="nv">s</span><span class="p">)</span>        <span class="nv">d</span>
          <span class="p">(</span><span class="nb">gethash</span> <span class="nv">n</span> <span class="nv">harbor</span><span class="p">)</span> <span class="nv">s</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">find-ship</span> <span class="p">(</span><span class="nv">n</span><span class="p">)</span> <span class="p">(</span><span class="nb">gethash</span> <span class="nv">n</span> <span class="nv">harbor</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">leave</span> <span class="p">(</span><span class="nv">n</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">s</span> <span class="p">(</span><span class="nb">gethash</span> <span class="nv">n</span> <span class="nv">harbor</span><span class="p">)))</span>
    <span class="p">(</span><span class="nb">remhash</span> <span class="nv">n</span> <span class="nv">harbor</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">vector-push</span> <span class="nv">s</span> <span class="nv">pool</span><span class="p">)))</span>
</pre>
                                </div>
                              </div>
                              <p><strong>图 13.5 港口（第二版）</strong></p>
                              <p>严格说来，新的版本仍然会构造，只是不在运行期。在第二个版本中， <code
                                  class="docutils literal"><span class="pre">harbor</span></code>
                                从列表变成了哈希表，所以它所有的空间都在编译期分配了。
                                一千个 <code class="docutils literal"><span class="pre">ship</span></code>
                                结构体也会在编译期被创建出来，并被保存在向量池(vector pool) 中。(如果 <code
                                  class="docutils literal"><span class="pre">:fill-pointer</span></code> 参数为 <code
                                  class="docutils literal"><span class="pre">t</span></code> ，填充指针将指向向量的末尾。) 此时，当 <code
                                  class="docutils literal"><span class="pre">enter</span></code>
                                需要一个新的结构时，它只需从池中取来一个便是，无须再调用 <code
                                  class="docutils literal"><span class="pre">make-ship</span></code> 。
                                而且当 <code class="docutils literal"><span class="pre">leave</span></code> 从 <code
                                  class="docutils literal"><span class="pre">harbor</span></code> 中移除一艘 <code
                                  class="docutils literal"><span class="pre">ship</span></code> 时，它把它送回池中，而不是抛弃它。</p>
                              <p>我们使用存储池的行为实际上是肩负起内存管理的工作。这是否会让我们的程序更快仍取决于我们的 Lisp
                                实现怎样管理内存。总的说来，只有在那些仍使用着原始垃圾回收器的实现中，或者在那些对 GC 的不可预见性比较敏感的实时应用中才值得一试。</p>
                            </div>
                            <div class="section" id="fast-operators">
                              <h4>13.6 快速操作符 (Fast Operators)<a class="headerlink" href="#fast-operators"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>本章一开始就宣称 Lisp 是两种不同的语言。就某种意义来讲这确实是正确的。如果你仔细看过 Common Lisp
                                的设计，你会发现某些特性主要是为了速度，而另外一些主要为了便捷性。</p>
                              <p>例如，你可以通过三个不同的函数取得向量给定位置上的元素： <code
                                  class="docutils literal"><span class="pre">elt</span></code> 、 <code
                                  class="docutils literal"><span class="pre">aref</span></code> 、 <code
                                  class="docutils literal"><span class="pre">svref</span></code>
                                。如此的多样性允许你把一个程序的性能提升到极致。 所以如果你可以使用 <code
                                  class="docutils literal"><span class="pre">svref</span></code> ，完事儿！
                                相反，如果对某段程序来说速度很重要的话，或许不应该调用 <code
                                  class="docutils literal"><span class="pre">elt</span></code> ，它既可以用于数组也可以用于列表。</p>
                              <p>对于列表来说，你应该调用 <code class="docutils literal"><span class="pre">nth</span></code> ，而不是
                                <code class="docutils literal"><span class="pre">elt</span></code> 。然而只有单一的一个函数 ── <code
                                  class="docutils literal"><span class="pre">length</span></code> ── 用于计算任何一个序列的长度。为什么
                                Common Lisp 不单独为列表提供一个特定的版本呢？因为如果你的程序正在计算一个列表的长度，它在速度上已经输了。在这个
                                例子中，就像许多其他的例子一样，语言的设计暗示了哪些会是快速的而哪些不是。
                              </p>
                              <p>另一对相似的函数是 <code class="docutils literal"><span class="pre">eql</span></code> 和 <code
                                  class="docutils literal"><span class="pre">eq</span></code> 。前者是验证同一性 (identity)
                                的默认判断式，但如果你知道参数不会是字符或者数字时，使用后者其实更快。两个对象 <em>eq</em>
                                只有当它们处在相同的内存位置上时才成立。数字和字符可能不会与任何特定的内存位置相关，因此 <code
                                  class="docutils literal"><span class="pre">eq</span></code> 不适用于它们
                                (即便多数实现中它仍然能用于定长数)。对于其他任何种类的参数， <code
                                  class="docutils literal"><span class="pre">eq</span></code> 和 <code
                                  class="docutils literal"><span class="pre">eql</span></code> 将返回相同的值。</p>
                              <p>使用 <code class="docutils literal"><span class="pre">eq</span></code> 来比较对象总是最快的，因为 Lisp
                                所需要比较的仅仅是指向对象的指针。因此 <code class="docutils literal"><span class="pre">eq</span></code>
                                哈希表 (如图 13.5 所示) 应该会提供最快的访问。 在一个 <code
                                  class="docutils literal"><span class="pre">eq</span></code> 哈希表中， <code
                                  class="docutils literal"><span class="pre">gethash</span></code>
                                可以只根据指针查找，甚至不需要查看它们指向的是什么。然而，访问不是唯一要考虑的因素； <em>eq</em> 和 <em>eql</em> 哈希表在拷贝型垃圾回收算法
                                (copying garbage collection algorithm)中会引起额外的开销，因为垃圾回收后需要对一些哈希值重新进行计算
                                (rehashing)。如果这变成了一个问题，最好的解决方案是使用一个把定长数作为键值的 <code
                                  class="docutils literal"><span class="pre">eql</span></code> 哈希表。</p>
                              <p>当被调函数有一个余留参数时，调用 <code class="docutils literal"><span class="pre">reduce</span></code>
                                可能是比 <code class="docutils literal"><span class="pre">apply</span></code> 更高效的一种方式。例如，相比
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">apply</span> <span class="nf">#&#39;</span><span class="nb">+</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p>写成如下可以更高效：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">reduce</span> <span class="nf">#&#39;</span><span class="nb">+</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p>它不仅有助于调用正确的函数，还有助于按照正确的方式调用它们。余留、可选和关键字参数
                                是昂贵的。只使用普通参数，函数调用中的参量会被调用者简单的留在被调者能够找到的地方。但其他种类的参数涉及运行时的处理。关键字参数是最差的。针对内置函数，优秀的编译器采用特殊的办法把使用关键字参量的调用编译成快速代码
                                (fast code)。但对于你自己编写的函数，避免在程序中对速度敏感的部分使用它们只有好处没有坏处。另外，不把大量的参量都放到余留参数中也是明智的举措，如果这可以避免的话。
                              </p>
                              <p>不同的编译器有时也会有一些它们独到优化。例如，有些编译器可以针对键值是一个狭小范围中的整数的 <code
                                  class="docutils literal"><span class="pre">case</span></code>
                                语句进行优化。查看你的用户手册来了解那些实现特有的优化的建议吧。</p>
                            </div>
                            <div class="section" id="two-phase-development">
                              <h4>13.7 二阶段开发 (Two-Phase Development)<a class="headerlink" href="#two-phase-development"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>在以速度至上的应用中，你也许想要使用诸如 C 或者汇编这样的低级语言来重写一个 Lisp 程序的某部分。你可以对用任何语言编写的程序使用这一技巧 ── C
                                程序的关键部分经常用汇编重写 ── 但语言越抽象，用两阶段（two phases）开发程序的好处就越明显。</p>
                              <p>Common Lisp 没有规定如何集成其他语言所编写的代码。这部分留给了实现决定，而几乎所有的实现都提供了某种方式来实现它。</p>
                              <p>使用一种语言编写程序然后用另一种语言重写它其中部分看起来可能是一种浪费。事实上，经验显示这是一种好的开发软件的方式。先针对功能、然后是速度比试着同时达成两者来的简单。</p>
                              <p>如果编程完全是一个机械的过程 ── 简单的把规格说明翻译为代码 ── 在一步中把所有的事情都搞定也许是合理的。但编程永远不是如此。不论规格说明多么精确，
                                编程总是涉及一定量的探索 ── 通常比任何人能预期到的还多的多。</p>
                              <p>
                                一份好的规格说明，也许会让编程看起来像是简单的把它们翻译成代码的过程。这是一个普遍的误区。编程必定涉及探索，因为规格说明必定含糊不清。如果它们不含糊的话，它们就都算不上规格说明。
                              </p>
                              <p>
                                在其他领域，尽可能精准的规格说明也许是可取的。如果你要求一块金属被切割成某种形状，最好准确的说出你想要的。但这个规则不适用于软件，因为程序和规格说明由相同的东西构成：文本。你不可能编写出完全合意的规格说明。如果规格说明有那么精确的话，它们就变成程序了。
                                <a class="reference external"
                                  href="http://acl.readthedocs.org/en/latest/zhCN/notes-cn.html#notes-229">λ</a>
                              </p>
                              <p>对于存在着可观数量的探索的应用 (再一次，比任何人承认的还要多，将实现分成两个阶段是值得的。而且在第一阶段中你所使用的手段 (medium)
                                不必就是最后的那个。例如，制作铜像的标准方法是先从粘土开始。你先用粘土做一个塑像出来，然后用它做一个模子，在这个模子中铸造铜像。在最后的塑像中是没有丁点粘土的，但你可以从铜像的形状中认识到它发挥的作用。试想下从一开始就只用一块儿铜和一个凿子来制造这么个一模一样的塑像要多难啊！出于相同的原因，首先用
                                Lisp 来编写程序，然后用 C 改写它，要比从头开始就用 C 编写这个程序要好。</p>
                            </div>
                            <div class="section" id="chapter-13-summary">
                              <h4>Chapter 13 总结 (Summary)<a class="headerlink" href="#chapter-13-summary"
                                  title="Permalink to this headline">¶</a></h4>
                              <ol class="arabic simple">
                                <li>不应过早开始优化，应该关注瓶颈，而且应该从算法开始。</li>
                                <li>有五个不同的参数控制编译。它们可以在本地声明也可以在全局声明。</li>
                                <li>优秀的编译器能够优化尾递归，将一个尾递归的函数转换为一个循环。内联编译是另一种避免函数调用的方法。</li>
                                <li>类型声明并不是必须的，但它们可以让一个程序更高效。类型声明对于处理数值和数组的代码特别重要。</li>
                                <li>少的构造可以让程序更快，特别是在使用着原始的垃圾回收器的实现中。解决方案是使用破坏性函数、预先分配空间块、以及在栈上分配。</li>
                                <li>某些情况下，从预先分配的存储池中提取对象可能是有价值的。</li>
                                <li>Common Lisp 的某些部分是为了速度而设计的，另一些则为了灵活性。</li>
                                <li>编程必定存在探索的过程。探索和优化应该被分开 ── 有时甚至需要使用不同的语言。</li>
                              </ol>
                            </div>
                            <div class="section" id="chapter-13-exercises">
                              <h4>Chapter 13 练习 (Exercises)<a class="headerlink" href="#chapter-13-exercises"
                                  title="Permalink to this headline">¶</a></h4>
                              <ol class="arabic simple">
                                <li>检验你的编译器是否支持 (observe)内敛声明。</li>
                                <li>将下述函数重写为尾递归形式。它被编译后能快多少？</li>
                              </ol>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre>(defun foo (x)
  (if (zerop x)
      0
      (1+ (foo (1- x)))))

注意：你需要增加额外的参数。
</pre>
                                </div>
                              </div>
                              <ol class="arabic simple" start="3">
                                <li>为下述程序增加声明。你能让它们变快多少？</li>
                              </ol>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre>(a) 在 5.7 节中的日期运算代码。
(b) 在 9.8 节中的光线跟踪器 (ray-tracer)。
</pre>
                                </div>
                              </div>
                              <ol class="arabic simple" start="4">
                                <li>重写 3.15 节中的广度优先搜索的代码让它尽可能减少使用构造。</li>
                                <li>使用存储池修改 4.7 节中的二叉搜索的代码。</li>
                              </ol>
                              <p class="rubric">脚注</p>
                              <table class="docutils footnote" frame="void" id="id9" rules="none">
                                <colgroup>
                                  <col class="label" />
                                  <col />
                                </colgroup>
                                <tbody valign="top">
                                  <tr>
                                    <td class="label"><a class="fn-backref" href="#id4">[1]</a></td>
                                    <td>较早的实现或许不提供 <code
                                        class="docutils literal"><span class="pre">declaim</span></code> ；需要使用 <code
                                        class="docutils literal"><span class="pre">proclaim</span></code> 并且引用这些参量
                                      (quote the argument)。</td>
                                  </tr>
                                </tbody>
                              </table>
                              <table class="docutils footnote" frame="void" id="id10" rules="none">
                                <colgroup>
                                  <col class="label" />
                                  <col />
                                </colgroup>
                                <tbody valign="top">
                                  <tr>
                                    <td class="label"><a class="fn-backref" href="#id5">[2]</a></td>
                                    <td>为了让内联声明 (inline declaration) 有效，你同时必须设置编译参数，告诉它你想获得最快的代码。</td>
                                  </tr>
                                </tbody>
                              </table>
                              <table class="docutils footnote" frame="void" id="id11" rules="none">
                                <colgroup>
                                  <col class="label" />
                                  <col />
                                </colgroup>
                                <tbody valign="top">
                                  <tr>
                                    <td class="label"><a class="fn-backref" href="#id6">[3]</a></td>
                                    <td>有两种方法可以描述 Lisp 声明类型 (typing) 的方式：从类型信息被存放的位置或者从它被使用的时间。显示类型 (manifest typing)
                                      的意思是类型信息与数据对象 (data objects) 绑定，而运行时类型(run-time typing)
                                      的意思是类型信息在运行时被使用。实际上，两者是一回事儿。</td>
                                  </tr>
                                </tbody>
                              </table>
                            </div>
                          </div>
                          <div class="section">
                            <h3 id="14">第十四章：进阶议题</h3>
                            <p>本章是选择性阅读的。本章描述了 Common Lisp 里一些更深奥的特性。Common Lisp
                              像是一个冰山：大部分的功能对于那些永远不需要他们的多数用户是看不见的。你或许永远不需要自己定义包 (Package)或读取宏
                              (read-macros)，但当你需要时，有些例子可以让你参考是很有用的。</p>
                            <div class="section" id="type-specifiers">
                              <h4>14.1 类型标识符 (Type Specifiers)<a class="headerlink" href="#type-specifiers"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>类型在 Common Lisp 里不是对象。举例来说，没有对象对应到 <code
                                  class="docutils literal"><span class="pre">integer</span></code> 这个类型。我们像是从 <code
                                  class="docutils literal"><span class="pre">type-of</span></code> 函数里所获得的，以及作为传给像是
                                <code class="docutils literal"><span class="pre">typep</span></code>
                                函数的参数，不是一个类型，而是一个类型标识符 (type specifier)。
                              </p>
                              <p>一个类型标识符是一个类型的名称。最简单的类型标识符是像是 <code
                                  class="docutils literal"><span class="pre">integer</span></code> 的符号。这些符号形成了 Common
                                Lisp 里的类型层级。在层级的最顶端是类型 <code class="docutils literal"><span class="pre">t</span></code>
                                ── 所有的对象皆为类型 <code class="docutils literal"><span class="pre">t</span></code>
                                。而类型层级不是一棵树。从 <code class="docutils literal"><span class="pre">nil</span></code>
                                至顶端有两条路，举例来说：一条从 <code class="docutils literal"><span class="pre">atom</span></code>
                                ，另一条从 <code class="docutils literal"><span class="pre">list</span></code> 与 <code
                                  class="docutils literal"><span class="pre">sequence</span></code> 。</p>
                              <p>一个类型实际上只是一个对象集合。这意味著有多少类型就有多少个对象的集合：一个无穷大的数目。我们可以用原子的类型标识符 (atomic type
                                specifiers)来表示某些集合：比如 <code
                                  class="docutils literal"><span class="pre">integer</span></code>
                                表示所有整数集合。但我们也可以建构一个复合类型标识符 (compound type specifiers)来参照到任何对象的集合。</p>
                              <p>举例来说，如果 <code class="docutils literal"><span class="pre">a</span></code> 与 <code
                                  class="docutils literal"><span class="pre">b</span></code> 是两个类型标识符，则 <code
                                  class="docutils literal"><span class="pre">(or</span> <span class="pre">a</span> <span class="pre">b)</span></code>
                                表示分别由 <code class="docutils literal"><span class="pre">a</span></code> 与 <code
                                  class="docutils literal"><span class="pre">b</span></code> 类型所表示的联集 (union)。也就是说，一个类型
                                <code
                                  class="docutils literal"><span class="pre">(or</span> <span class="pre">a</span> <span class="pre">b)</span></code>
                                的对象是类型 <code class="docutils literal"><span class="pre">a</span></code> 或 类型 <code
                                  class="docutils literal"><span class="pre">b</span></code> 。
                              </p>
                              <p>如果 <code class="docutils literal"><span class="pre">circular?</span></code> 是一个对于 <code
                                  class="docutils literal"><span class="pre">cdr</span></code>
                                为环状的列表返回真的函数，则你可以使用适当的序列集合来表示： <a class="footnote-reference" href="#id4"
                                  id="id2">[1]</a></p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">or</span> <span class="nb">vector</span> <span class="p">(</span><span class="nb">and</span> <span class="nb">list</span> <span class="p">(</span><span class="nb">not</span> <span class="p">(</span><span class="nv">satisfies</span> <span class="nv">circular?</span><span class="p">))))</span>
</pre>
                                </div>
                              </div>
                              <p>某些原子的类型标识符也可以出现在复合类型标识符。要表示介于 1 至 100 的整数（包含），我们可以用：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nc">integer</span> <span class="mi">1</span> <span class="mi">100</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>这样的类型标识符用来表示一个有限的类型 (finite type)。</p>
                              <p>在一个复合类型标识符里，你可以通过在一个参数的位置使用 <code
                                  class="docutils literal"><span class="pre">*</span></code> 来留下某些未指定的信息。所以</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="kt">simple-array</span> <span class="kt">fixnum</span> <span class="p">(</span><span class="nb">*</span> <span class="nb">*</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p>描述了指定给 <code class="docutils literal"><span class="pre">fixnum</span></code> 使用的二维简单数组
                                (simple array)集合，而</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="kt">simple-array</span> <span class="kt">fixnum</span> <span class="nb">*</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>描述了指定给 <code class="docutils literal"><span class="pre">finxnum</span></code> 使用的简单数组集合
                                (前者的超类型 「supertype」)。尾随的星号可以省略，所以上个例子可以写为：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="kt">simple-array</span> <span class="kt">fixnum</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>若一个复合类型标识符没有传入参数，你可以使用一个原子。所以 <code
                                  class="docutils literal"><span class="pre">simple-array</span></code> 描述了所有简单数组的集合。
                              </p>
                              <p>如果有某些复合类型标识符你想重复使用，你可以使用 <code
                                  class="docutils literal"><span class="pre">deftype</span></code> 定义一个缩写。这个宏与 <code
                                  class="docutils literal"><span class="pre">defmacro</span></code>
                                相似，但会展开成一个类型标识符，而不是一个表达式。通过表达</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">deftype</span> <span class="nv">proseq</span> <span class="p">()</span>
        <span class="o">&#39;</span><span class="p">(</span><span class="nb">or</span> <span class="nb">vector</span> <span class="p">(</span><span class="nb">and</span> <span class="nb">list</span> <span class="p">(</span><span class="nb">not</span> <span class="p">(</span><span class="nv">satisfies</span> <span class="nv">circular?</span><span class="p">)))))</span>
</pre>
                                </div>
                              </div>
                              <p>我们定义了 <code class="docutils literal"><span class="pre">proseq</span></code>
                                作为一个新的原子类型标识符：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">typep</span> <span class="o">#(</span><span class="mi">1</span> <span class="mi">2</span><span class="p">)</span> <span class="ss">&#39;proseq</span><span class="p">)</span>
<span class="no">T</span>
</pre>
                                </div>
                              </div>
                              <p>如果你定义一个接受参数的类型标识符，参数会被视为 Lisp 形式（即没有被求值），与 <code
                                  class="docutils literal"><span class="pre">defmacro</span></code> 一样。所以</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">deftype</span> <span class="nv">multiple-of</span> <span class="p">(</span><span class="nv">n</span><span class="p">)</span>
  <span class="o">`</span><span class="p">(</span><span class="nb">and</span> <span class="nc">integer</span> <span class="p">(</span><span class="nv">satisfies</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span>
                             <span class="p">(</span><span class="nb">zerop</span> <span class="p">(</span><span class="nb">mod</span> <span class="nv">x</span> <span class="o">,</span><span class="nv">n</span><span class="p">))))))</span>
</pre>
                                </div>
                              </div>
                              <p>(译注: 注意上面代码是使用反引号 <code class="docutils literal"><span class="pre">`</span></code> )
                              </p>
                              <p>定义了 <cite>(multiple-of n)</cite> 当成所有 <code
                                  class="docutils literal"><span class="pre">n</span></code> 的倍数的标识符：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="k">type</span> <span class="mi">12</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">multiple-of</span> <span class="mi">4</span><span class="p">))</span>
<span class="no">T</span>
</pre>
                                </div>
                              </div>
                              <p>类型标识符会被直译 (interpreted)，因此很慢，所以通常你最好定义一个函数来处理这类的测试。</p>
                            </div>
                            <div class="section" id="binary-streams">
                              <h4>14.2 二进制流 (Binary Streams)<a class="headerlink" href="#binary-streams"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>第 7 章曾提及的流有二进制流 (binary streams)以及字符流 (character
                                streams)。一个二进制流是一个整数的来源及/或终点，而不是字符。你通过指定一个整数的子类型来创建一个二进制流 ── 当你打开流时，通常是用 <code
                                  class="docutils literal"><span class="pre">unsigned-byte</span></code> ── 来作为 <code
                                  class="docutils literal"><span class="pre">:element-type</span></code> 的参数。</p>
                              <p>关于二进制流的 I/O 函数仅有两个， <code
                                  class="docutils literal"><span class="pre">read-byte</span></code> 以及 <code
                                  class="docutils literal"><span class="pre">write-byte</span></code>
                                。所以下面是如何定义复制一个文件的函数：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">copy-file</span> <span class="p">(</span><span class="nv">from</span> <span class="nv">to</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">with-open-file</span> <span class="p">(</span><span class="nv">in</span> <span class="nv">from</span> <span class="ss">:direction</span> <span class="ss">:input</span>
                           <span class="ss">:element-type</span> <span class="ss">&#39;unsigned-byte</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">with-open-file</span> <span class="p">(</span><span class="nv">out</span> <span class="nv">to</span> <span class="ss">:direction</span> <span class="ss">:output</span>
                            <span class="ss">:element-type</span> <span class="ss">&#39;unsigned-byte</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">do</span> <span class="p">((</span><span class="nv">i</span> <span class="p">(</span><span class="nb">read-byte</span> <span class="nv">in</span> <span class="no">nil</span> <span class="mi">-1</span><span class="p">)</span>
              <span class="p">(</span><span class="nb">read-byte</span> <span class="nv">in</span> <span class="no">nil</span> <span class="mi">-1</span><span class="p">)))</span>
          <span class="p">((</span><span class="nb">minusp</span> <span class="nv">i</span><span class="p">))</span>
        <span class="p">(</span><span class="k">declare</span> <span class="p">(</span><span class="kt">fixnum</span> <span class="nv">i</span><span class="p">))</span>
        <span class="p">(</span><span class="nb">write-byte</span> <span class="nv">i</span> <span class="nv">out</span><span class="p">)))))</span>
</pre>
                                </div>
                              </div>
                              <p>仅通过指定 <code class="docutils literal"><span class="pre">unsigned-byte</span></code> 给
                                <code class="docutils literal"><span class="pre">:element-type</span></code>
                                ，你让操作系统选择一个字节 (byte)的长度。举例来说，如果你明确地想要读写 7 比特的整数，你可以使用：
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="kt">unsigned-byte</span> <span class="mi">7</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>来传给 <code class="docutils literal"><span class="pre">:element-type</span></code> 。</p>
                            </div>
                            <div class="section" id="read-macros">
                              <h4>14.3 读取宏 (Read-Macros)<a class="headerlink" href="#read-macros"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>7.5 节介绍过宏字符 (macro character)的概念，一个对于 <code
                                  class="docutils literal"><span class="pre">read</span></code>
                                有特别意义的字符。每一个这样的字符，都有一个相关联的函数，这函数告诉 <code
                                  class="docutils literal"><span class="pre">read</span></code>
                                当遇到这个字符时该怎么处理。你可以变更某个已存在宏字符所相关联的函数，或是自己定义新的宏字符。</p>
                              <p>函数 <code class="docutils literal"><span class="pre">set-macro-character</span></code>
                                提供了一种方式来定义读取宏 (read-macros)。它接受一个字符及一个函数，因此当 <code
                                  class="docutils literal"><span class="pre">read</span></code> 碰到该字符时，它返回调用传入函数后的结果。
                              </p>
                              <p>Lisp 中最古老的读取宏之一是 <code class="docutils literal"><span class="pre">'</span></code> ，即
                                <code class="docutils literal"><span class="pre">quote</span></code> 。我们可以定义成：
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">set-macro-character</span> <span class="sc">#\&#39;</span>
        <span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nc">stream</span> <span class="nb">char</span><span class="p">)</span>
                <span class="p">(</span><span class="nb">list</span> <span class="p">(</span><span class="k">quote</span> <span class="k">quote</span><span class="p">)</span> <span class="p">(</span><span class="nb">read</span> <span class="nc">stream</span> <span class="no">t</span> <span class="no">nil</span> <span class="no">t</span><span class="p">))))</span>
</pre>
                                </div>
                              </div>
                              <p>当 <code class="docutils literal"><span class="pre">read</span></code> 在一个普通的语境下遇到 <code
                                  class="docutils literal"><span class="pre">'</span></code>
                                时，它会返回在当前流和字符上调用这个函数的结果。(这个函数忽略了第二个参数，第二个参数永远是引用字符。)所以当 <code
                                  class="docutils literal"><span class="pre">read</span></code> 看到 <code
                                  class="docutils literal"><span class="pre">'a</span></code> 时，会返回 <code
                                  class="docutils literal"><span class="pre">(quote</span> <span class="pre">a)</span></code>
                                。</p>
                              <p>译注: <code class="docutils literal"><span class="pre">read</span></code> 函数接受的参数 <code
                                  class="docutils literal"><span class="pre">(read</span> <span class="pre">&amp;optional</span> <span class="pre">stream</span> <span class="pre">eof-error</span> <span class="pre">eof-value</span> <span class="pre">recursive)</span></code>
                              </p>
                              <p>现在我们明白了 <code class="docutils literal"><span class="pre">read</span></code>
                                最后一个参数的用途。它表示无论 <code class="docutils literal"><span class="pre">read</span></code>
                                调用是否在另一个 <code class="docutils literal"><span class="pre">read</span></code> 里。传给 <code
                                  class="docutils literal"><span class="pre">read</span></code> 的参数在几乎所有的读取宏里皆相同：传入参数有流
                                (stream)；接著是第二个参数， <code class="docutils literal"><span class="pre">t</span></code> ，说明了
                                <code class="docutils literal"><span class="pre">read</span></code> 若读入的东西是 end-of-file
                                时，应不应该报错；第三个参数说明了不报错时要返回什么，因此在这里也就不重要了；而第四个参数 <code
                                  class="docutils literal"><span class="pre">t</span></code> 说明了这个 <code
                                  class="docutils literal"><span class="pre">read</span></code> 调用是递归的。
                              </p>
                              <p>(译注：困惑的话可以看看 <a class="reference external" href="https://gist.github.com/3467235">read
                                  的定义</a> )</p>
                              <p>你可以（通过使用 <code
                                  class="docutils literal"><span class="pre">make-dispatch-macro-character</span></code>
                                ）来定义你自己的派发宏字符（dispatching macro character），但由于 <code
                                  class="docutils literal"><span class="pre">#</span></code> 已经是一个宏字符，所以你也可以直接使用。六个
                                <code class="docutils literal"><span class="pre">#</span></code> 打头的组合特别保留给你使用： <code
                                  class="docutils literal"><span class="pre">#!</span></code> 、 <code
                                  class="docutils literal"><span class="pre">#?</span></code> 、 <code
                                  class="docutils literal"><span class="pre">##[</span></code> 、 <code
                                  class="docutils literal"><span class="pre">##]</span></code> 、 <code
                                  class="docutils literal"><span class="pre">#{</span></code> 、 <code
                                  class="docutils literal"><span class="pre">#}</span></code> 。
                              </p>
                              <p>你可以通过调用 <code
                                  class="docutils literal"><span class="pre">set-dispatch-macro-character</span></code>
                                定义新的派发宏字符组合，与 <code
                                  class="docutils literal"><span class="pre">set-macro-character</span></code>
                                类似，除了它接受两个字符参数外。下面的代码定义了 <code
                                  class="docutils literal"><span class="pre">#?</span></code> 作为返回一个整数列表的读取宏。</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">set-dispatch-macro-character</span> <span class="sc">#\#</span> <span class="sc">#\?</span>
  <span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nc">stream</span> <span class="nv">char1</span> <span class="nv">char2</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">list</span> <span class="ss">&#39;quote</span>
            <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">lst</span> <span class="no">nil</span><span class="p">))</span>
              <span class="p">(</span><span class="nb">dotimes</span> <span class="p">(</span><span class="nv">i</span> <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nb">read</span> <span class="nc">stream</span> <span class="no">t</span> <span class="no">nil</span> <span class="no">t</span><span class="p">)</span> <span class="mi">1</span><span class="p">))</span>
                <span class="p">(</span><span class="nb">push</span> <span class="nv">i</span> <span class="nv">lst</span><span class="p">))</span>
              <span class="p">(</span><span class="nb">nreverse</span> <span class="nv">lst</span><span class="p">)))))</span>
</pre>
                                </div>
                              </div>
                              <p>现在 <code class="docutils literal"><span class="pre">#?n</span></code> 会被读取成一个含有整数 <code
                                  class="docutils literal"><span class="pre">0</span></code> 至 <code
                                  class="docutils literal"><span class="pre">n</span></code> 的列表。举例来说：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre>&gt; #?7
(1 2 3 4 5 6 7)
</pre>
                                </div>
                              </div>
                              <p>除了简单的宏字符，最常定义的宏字符是列表分隔符 (list delimiters)。另一个保留给用户的字符组是 <code
                                  class="docutils literal"><span class="pre">#{</span></code> 。以下我们定义了一种更复杂的左括号：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">set-macro-character</span> <span class="sc">#\}</span> <span class="p">(</span><span class="nb">get-macro-character</span> <span class="sc">#\)</span><span class="p">))</span>

<span class="p">(</span><span class="nb">set-dispatch-macro-character</span> <span class="sc">#\#</span> <span class="sc">#\{</span>
  <span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nc">stream</span> <span class="nv">char1</span> <span class="nv">char2</span><span class="p">)</span>
      <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">accum</span> <span class="no">nil</span><span class="p">)</span>
            <span class="p">(</span><span class="nv">pair</span> <span class="p">(</span><span class="nb">read-delimited-list</span> <span class="sc">#\}</span> <span class="nc">stream</span> <span class="no">t</span><span class="p">)))</span>
        <span class="p">(</span><span class="nb">do</span> <span class="p">((</span><span class="nv">i</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">pair</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">i</span> <span class="mi">1</span><span class="p">)))</span>
            <span class="p">((</span><span class="nb">&gt;</span> <span class="nv">i</span> <span class="p">(</span><span class="nb">cadr</span> <span class="nv">pair</span><span class="p">))</span>
             <span class="p">(</span><span class="nb">list</span> <span class="ss">&#39;quote</span> <span class="p">(</span><span class="nb">nreverse</span> <span class="nv">accum</span><span class="p">)))</span>
          <span class="p">(</span><span class="nb">push</span> <span class="nv">i</span> <span class="nv">accum</span><span class="p">)))))</span>
</pre>
                                </div>
                              </div>
                              <p>这定义了一个这样形式 <code
                                  class="docutils literal"><span class="pre">#{x</span> <span class="pre">y}</span></code>
                                的表达式，使得这样的表达式被读取为所有介于 <code class="docutils literal"><span class="pre">x</span></code> 与
                                <code class="docutils literal"><span class="pre">y</span></code> 之间的整数列表，包含 <code
                                  class="docutils literal"><span class="pre">x</span></code> 与 <code
                                  class="docutils literal"><span class="pre">y</span></code> ：
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre>&gt; #{2 7}
(2 3 4 4 5 6 7)
</pre>
                                </div>
                              </div>
                              <p>函数 <code class="docutils literal"><span class="pre">read-delimited-list</span></code>
                                正是为了这样的读取宏而生的。它的第一个参数是被视为列表结束的字符。为了使 <code
                                  class="docutils literal"><span class="pre">}</span></code>
                                被识别为分隔符，必须先给它这个角色，所以程序在开始的地方调用了 <code
                                  class="docutils literal"><span class="pre">set-macro-character</span></code> 。</p>
                              <p>如果你想要在定义一个读取宏的文件里使用该读取宏，则读取宏的定义应要包在一个 <code
                                  class="docutils literal"><span class="pre">eval-when</span></code>
                                表达式里，来确保它在编译期会被求值。不然它的定义会被编译，但不会被求值，直到编译文件被载入时才会被求值。</p>
                            </div>
                            <div class="section" id="packages">
                              <h4>14.4 包 (Packages)<a class="headerlink" href="#packages"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>一个包是一个将名字映对到符号的 Lisp 对象。当前的包总是存在全局变量 <code
                                  class="docutils literal"><span class="pre">*package*</span></code> 里。当 Common Lisp
                                启动时，当前的包会是 <code
                                  class="docutils literal"><span class="pre">*common-lisp-user*</span></code> ，通常称为用户包
                                (user package)。函数 <code
                                  class="docutils literal"><span class="pre">package-name</span></code> 返回包的名字，而 <code
                                  class="docutils literal"><span class="pre">find-package</span></code> 返回一个给定名称的包:</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre>&gt; (package-name *package*)
&quot;COMMON-LISP-USER&quot;
&gt; (find-package &quot;COMMON-LISP-USER&quot;)
#&lt;Package &quot;COMMON-LISP-USER&quot; 4CD15E&gt;
</pre>
                                </div>
                              </div>
                              <p>通常一个符号在读入时就被 interned 至当前的包里面了。函数 <code
                                  class="docutils literal"><span class="pre">symbol-package</span></code> 接受一个符号并返回该符号被
                                interned 的包。</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre>(symbol-package &#39;sym)
#&lt;Package &quot;COMMON-LISP-USER&quot; 4CD15E&gt;
</pre>
                                </div>
                              </div>
                              <p>有趣的是，这个表达式返回它该返回的值，因为表达式在可以被求值前必须先被读入，而读取这个表达式导致 <code
                                  class="docutils literal"><span class="pre">sym</span></code> 被 interned。为了之后的用途，让我们给
                                <code class="docutils literal"><span class="pre">sym</span></code> 一个值:
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">setf</span> <span class="nv">sym</span> <span class="mi">99</span><span class="p">)</span>
<span class="mi">99</span>
</pre>
                                </div>
                              </div>
                              <p>现在我们可以创建及切换至一个新的包：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre>&gt; (setf *package* (make-package &#39;mine
                                :use &#39;(common-lisp)))
#&lt;Package &quot;MINE&quot; 63390E&gt;
</pre>
                                </div>
                              </div>
                              <p>现在应该会听到诡异的背景音乐，因为我们来到一个不一样的世界了：
                                在这里 <code class="docutils literal"><span class="pre">sym</span></code> 不再是本来的 <code
                                  class="docutils literal"><span class="pre">sym</span></code> 了。</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nv">MINE&gt;</span> <span class="nv">sym</span>
<span class="nv">Error:</span> <span class="nv">SYM</span> <span class="nv">has</span> <span class="nv">no</span> <span class="nv">value</span>
</pre>
                                </div>
                              </div>
                              <p>为什么会这样？因为上面我们设为 99 的 <code class="docutils literal"><span class="pre">sym</span></code>
                                与 <code class="docutils literal"><span class="pre">mine</span></code> 里的 <code
                                  class="docutils literal"><span class="pre">sym</span></code> 是两个不同的符号。 <a
                                  class="footnote-reference" href="#id5" id="id3">[2]</a> 要在用户包之外参照到原来的 <code
                                  class="docutils literal"><span class="pre">sym</span></code> ，我们必须把包的名字加上两个冒号作为前缀：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nv">MINE&gt;</span> <span class="nv">common-lisp-user::sym</span>
<span class="mi">99</span>
</pre>
                                </div>
                              </div>
                              <p>所以有着相同打印名称的不同符号能够在不同的包内共存。可以有一个 <code
                                  class="docutils literal"><span class="pre">sym</span></code> 在 <code
                                  class="docutils literal"><span class="pre">common-lisp-user</span></code> 包，而另一个 <code
                                  class="docutils literal"><span class="pre">sym</span></code> 在 <code
                                  class="docutils literal"><span class="pre">mine</span></code>
                                包，而他们会是不一样的符号。这就是包存在的意义。如果你在分开的包内写你的程序，你大可放心选择函数与变量的名字，而不用担心某人使用了同样的名字。即便是他们使用了同样的名字，也不会是相同的符号。
                              </p>
                              <p>包也提供了信息隐藏的手段。程序应通过函数与变量的名字来参照它们。如果你不让一个名字在你的包之外可见的话，那么另一个包中的代码就无法使用或者修改这个名字所参照的对象。</p>
                              <p>通常使用两个冒号作为包的前缀也是很差的风格。这么做你就违反了包本应提供的模块性。如果你不得不使用一个双冒号来参照到一个符号，这是因为某人根本不想让你用。</p>
                              <p>通常我们应该只参照被输出 ( <em>exported</em> )的符号。如果我们回到用户包里，并输出一个被 interned 的符号，</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre>MINE&gt; (in-package common-lisp-user)
#&lt;Package &quot;COMMON-LISP-USER&quot; 4CD15E&gt;
&gt; (export &#39;bar)
T
&gt; (setf bar 5)
5
</pre>
                                </div>
                              </div>
                              <p>我们使这个符号对于其它的包是可视的。现在当我们回到 <code
                                  class="docutils literal"><span class="pre">mine</span></code> ，我们可以仅使用单冒号来参照到 <code
                                  class="docutils literal"><span class="pre">bar</span></code> ，因为他是一个公开可用的名字：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre>&gt; (in-package mine)
#&lt;Package &quot;MINE&quot; 63390E&gt;
MINE&gt; common-lisp-user:bar
5
</pre>
                                </div>
                              </div>
                              <p>通过把 <code class="docutils literal"><span class="pre">bar</span></code> 输入 ( <code
                                  class="docutils literal"><span class="pre">import</span></code> )至 <code
                                  class="docutils literal"><span class="pre">mine</span></code> 包，我们就能进一步让 <code
                                  class="docutils literal"><span class="pre">mine</span></code> 和 <code
                                  class="docutils literal"><span class="pre">user</span></code> 包可以共享 <code
                                  class="docutils literal"><span class="pre">bar</span></code> 这个符号：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nv">MINE&gt;</span> <span class="p">(</span><span class="nb">import</span> <span class="ss">&#39;common-lisp-user:bar</span><span class="p">)</span>
<span class="no">T</span>
<span class="nv">MINE&gt;</span> <span class="nv">bar</span>
<span class="mi">5</span>
</pre>
                                </div>
                              </div>
                              <p>在输入 <code class="docutils literal"><span class="pre">bar</span></code>
                                之后，我们根本不需要用任何包的限定符 (package qualifier)，就能参照它了。这两个包现在共享了同样的符号；不可能会有一个独立的 <code
                                  class="docutils literal"><span class="pre">mine:bar</span></code> 了。</p>
                              <p>要是已经有一个了怎么办？在这种情况下， <code
                                  class="docutils literal"><span class="pre">import</span></code> 调用会产生一个错误，如下面我们试著输入
                                <code class="docutils literal"><span class="pre">sym</span></code> 时便知：
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nv">MINE&gt;</span> <span class="p">(</span><span class="nb">import</span> <span class="ss">&#39;common-lisp-user::sym</span><span class="p">)</span>
<span class="nv">Error:</span> <span class="nv">SYM</span> <span class="nv">is</span> <span class="nv">already</span> <span class="nv">present</span> <span class="nv">in</span> <span class="nv">MINE.</span>
</pre>
                                </div>
                              </div>
                              <p>在此之前，当我们试着在 <code class="docutils literal"><span class="pre">mine</span></code> 包里对
                                <code class="docutils literal"><span class="pre">sym</span></code> 进行了一次不成功的求值，我们使 <code
                                  class="docutils literal"><span class="pre">sym</span></code> 被 interned 至 <code
                                  class="docutils literal"><span class="pre">mine</span></code>
                                包里。而因为它没有值，所以产生了一个错误，但输入符号名的后果就是使这个符号被 intern 进这个包。所以现在当我们试著输入 <code
                                  class="docutils literal"><span class="pre">sym</span></code> 至 <code
                                  class="docutils literal"><span class="pre">mine</span></code> 包里，已经有一个相同名称的符号了。
                              </p>
                              <p>另一个方法来获得别的包内符号的存取权是使用( <code
                                  class="docutils literal"><span class="pre">use</span></code> )它：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nv">MINE&gt;</span> <span class="p">(</span><span class="nb">use-package</span> <span class="ss">&#39;common-lisp-user</span><span class="p">)</span>
<span class="no">T</span>
</pre>
                                </div>
                              </div>
                              <p>现在所有由用户包 (译注: common-lisp-user 包）所输出的符号，可以不需要使用任何限定符在 <code
                                  class="docutils literal"><span class="pre">mine</span></code> 包里使用。(如果 <code
                                  class="docutils literal"><span class="pre">sym</span></code> 已经被用户包输出了，这个调用也会产生一个错误。)
                              </p>
                              <p>含有自带操作符及变量名字的包叫做 <code
                                  class="docutils literal"><span class="pre">common-lisp</span></code> 。由于我们将这个包的名字在创建
                                <code class="docutils literal"><span class="pre">mine</span></code> 包时作为 <code
                                  class="docutils literal"><span class="pre">make-package</span></code> 的 <code
                                  class="docutils literal"><span class="pre">:use</span></code> 参数，所有的 Common Lisp
                                自带的名字在 <code class="docutils literal"><span class="pre">mine</span></code> 里都是可视的:
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre>MINE&gt; #&#39;cons
#&lt;Compiled-Function CONS 462A3E&gt;
</pre>
                                </div>
                              </div>
                              <p>在编译后的代码中, 通常不会像这样在顶层进行包的操作。更常见的是包的调用会包含在源文件里。通常，只要把 <code
                                  class="docutils literal"><span class="pre">in-package</span></code> 和 <code
                                  class="docutils literal"><span class="pre">defpackage</span></code> 放在源文件的开头就可以了，正如
                                137 页所示。</p>
                              <p>这种由包所提供的模块性实际上有点奇怪。我们不是对象的模块 (modules)，而是名字的模块。</p>
                              <p>每一个使用了 <code class="docutils literal"><span class="pre">common-lisp</span></code>
                                的包，都可以存取 <code class="docutils literal"><span class="pre">cons</span></code> ，因为 <code
                                  class="docutils literal"><span class="pre">common-lisp</span></code>
                                包里有一个叫这个名字的函数。但这会导致一个名字为 <code
                                  class="docutils literal"><span class="pre">cons</span></code> 的变量也会在每个使用了 <code
                                  class="docutils literal"><span class="pre">common-lisp</span></code>
                                包里是可视的。如果包使你困惑，这就是主要的原因；因为包不是基于对象而是基于名字。</p>
                            </div>
                            <div class="section" id="loop-the-loop-facility">
                              <h4>14.5 Loop 宏 (The Loop Facility)<a class="headerlink" href="#loop-the-loop-facility"
                                  title="Permalink to this headline">¶</a></h4>
                              <p><code class="docutils literal"><span class="pre">loop</span></code> 宏最初是设计来帮助无经验的 Lisp
                                用户来写出迭代的代码。与其撰写 Lisp 代码，你用一种更接近英语的形式来表达你的程序，然后这个形式被翻译成 Lisp。不幸的是， <code
                                  class="docutils literal"><span class="pre">loop</span></code>
                                比原先设计者预期的更接近英语：你可以在简单的情况下使用它，而不需了解它是如何工作的，但想在抽象层面上理解它几乎是不可能的。</p>
                              <p>如果你是曾经计划某天要理解 <code class="docutils literal"><span class="pre">loop</span></code>
                                怎么工作的许多 Lisp 程序员之一，有一些好消息与坏消息。好消息是你并不孤单：几乎没有人理解它。坏消息是你永远不会理解它，因为 ANSI
                                标准实际上并没有给出它行为的正式规范。</p>
                              <p>这个宏唯一的实际定义是它的实现方式，而唯一可以理解它（如果有人可以理解的话）的方法是通过实例。ANSI 标准讨论 <code
                                  class="docutils literal"><span class="pre">loop</span></code>
                                的章节大部分由例子组成，而我们将会使用同样的方式来介绍相关的基础概念。</p>
                              <p>第一个关于 <code class="docutils literal"><span class="pre">loop</span></code> 宏我们要注意到的是语法 (
                                <em>syntax</em> )。一个 <code class="docutils literal"><span class="pre">loop</span></code>
                                表达式不是包含子表达式而是子句 (<em>clauses</em>)。這些子句不是由括号分隔出来；而是每种都有一个不同的语法。在这个方面上， <code
                                  class="docutils literal"><span class="pre">loop</span></code> 与传统的 Algol-like 语言相似。但其它
                                <code class="docutils literal"><span class="pre">loop</span></code> 独特的特性，使得它与 Algol
                                不同，也就是在 <code class="docutils literal"><span class="pre">loop</span></code>
                                宏里调换子句的顺序与会发生的事情没有太大的关联。
                              </p>
                              <p>一个 <code class="docutils literal"><span class="pre">loop</span></code>
                                表达式的求值分为三个阶段，而一个给定的子句可以替多于一个的阶段贡献代码。这些阶段如下：</p>
                              <ol class="arabic simple">
                                <li><em>序幕</em> (<em>Prologue</em>)。 被求值一次来做为迭代过程的序幕。包括了将变量设至它们的初始值。</li>
                                <li><em>主体</em> (<em>Body</em>) 每一次迭代时都会被求值。</li>
                                <li><em>闭幕</em> (<em>Epilogue</em>) 当迭代结束时被求值。决定了 <code
                                    class="docutils literal"><span class="pre">loop</span></code> 表达式的返回值（可能返回多个值）。</li>
                              </ol>
                              <p>我们会看几个 <code class="docutils literal"><span class="pre">loop</span></code>
                                子句的例子，并考虑何种代码会贡献至何个阶段。</p>
                              <p>举例来说，最简单的 <code class="docutils literal"><span class="pre">loop</span></code>
                                表达式，我们可能会看到像是下列的代码：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">loop</span> <span class="nv">for</span> <span class="nv">x</span> <span class="nv">from</span> <span class="mi">0</span> <span class="nv">to</span> <span class="mi">9</span>
        <span class="nb">do</span> <span class="p">(</span><span class="nb">princ</span> <span class="nv">x</span><span class="p">))</span>
<span class="mi">0123456789</span>
<span class="no">NIL</span>
</pre>
                                </div>
                              </div>
                              <p>这个 <code class="docutils literal"><span class="pre">loop</span></code> 表达式印出从 <code
                                  class="docutils literal"><span class="pre">0</span></code> 至 <code
                                  class="docutils literal"><span class="pre">9</span></code> 的整数，并返回 <code
                                  class="docutils literal"><span class="pre">nil</span></code> 。第一个子句，</p>
                              <p><code
                                  class="docutils literal"><span class="pre">for</span> <span class="pre">x</span> <span class="pre">from</span> <span class="pre">0</span> <span class="pre">to</span> <span class="pre">9</span></code>
                              </p>
                              <p>贡献代码至前两个阶段，导致 <code class="docutils literal"><span class="pre">x</span></code> 在序幕中被设为
                                <code class="docutils literal"><span class="pre">0</span></code> ，在主体开头与 <code
                                  class="docutils literal"><span class="pre">9</span></code> 来做比较，在主体结尾被递增。第二个子句，
                              </p>
                              <p><code
                                  class="docutils literal"><span class="pre">do</span> <span class="pre">(princ</span> <span class="pre">x)</span></code>
                              </p>
                              <p>贡献代码给主体。</p>
                              <p>一个更通用的 <code class="docutils literal"><span class="pre">for</span></code> 子句说明了起始与更新的形式
                                (initial and update form)。停止迭代可以被像是 <code
                                  class="docutils literal"><span class="pre">while</span></code> 或 <code
                                  class="docutils literal"><span class="pre">until</span></code> 子句来控制。</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">loop</span> <span class="nv">for</span> <span class="nv">x</span> <span class="nb">=</span> <span class="mi">8</span> <span class="nv">then</span> <span class="p">(</span><span class="nb">/</span> <span class="nv">x</span> <span class="mi">2</span><span class="p">)</span>
        <span class="nv">until</span> <span class="p">(</span><span class="nb">&lt;</span> <span class="nv">x</span> <span class="mi">1</span><span class="p">)</span>
        <span class="nb">do</span> <span class="p">(</span><span class="nb">princ</span> <span class="nv">x</span><span class="p">))</span>
<span class="mi">8421</span>
<span class="no">NIL</span>
</pre>
                                </div>
                              </div>
                              <p>你可以使用 <code class="docutils literal"><span class="pre">and</span></code> 来创建复合的 <code
                                  class="docutils literal"><span class="pre">for</span></code> 子句，同时初始及更新两个变量：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">loop</span> <span class="nv">for</span> <span class="nv">x</span> <span class="nv">from</span> <span class="mi">1</span> <span class="nv">to</span> <span class="mi">4</span>
        <span class="nb">and</span> <span class="nv">y</span> <span class="nv">from</span> <span class="mi">1</span> <span class="nv">to</span> <span class="mi">4</span>
        <span class="nb">do</span> <span class="p">(</span><span class="nb">princ</span> <span class="p">(</span><span class="nb">list</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)))</span>
<span class="p">(</span><span class="mi">1</span> <span class="mi">1</span><span class="p">)(</span><span class="mi">2</span> <span class="mi">2</span><span class="p">)(</span><span class="mi">3</span> <span class="mi">3</span><span class="p">)(</span><span class="mi">4</span> <span class="mi">4</span><span class="p">)</span>
<span class="no">NIL</span>
</pre>
                                </div>
                              </div>
                              <p>要不然有多重 <code class="docutils literal"><span class="pre">for</span></code> 子句时，变量会被循序更新。
                              </p>
                              <p>另一件在迭代代码通常会做的事是累积某种值。举例来说：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">loop</span> <span class="nv">for</span> <span class="nv">x</span> <span class="nv">in</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">)</span>
        <span class="nv">collect</span> <span class="p">(</span><span class="nb">1+</span> <span class="nv">x</span><span class="p">))</span>
<span class="p">(</span><span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>在 <code class="docutils literal"><span class="pre">for</span></code> 子句使用 <code
                                  class="docutils literal"><span class="pre">in</span></code> 而不是 <code
                                  class="docutils literal"><span class="pre">from</span></code>
                                ，导致变量被设为一个列表的后续元素，而不是连续的整数。</p>
                              <p>在这个情况里， <code class="docutils literal"><span class="pre">collect</span></code>
                                子句贡献代码至三个阶段。在序幕，一個匿名累加器 (anonymous accumulator)設為 <code
                                  class="docutils literal"><span class="pre">nil</span></code> ；在主体裡， <code
                                  class="docutils literal"><span class="pre">(1+</span> <span class="pre">x)</span></code>
                                被累加至這個累加器，而在闭幕时返回累加器的值。</p>
                              <p>这是返回一个特定值的第一个例子。有用来明确指定返回值的子句，但没有这些子句时，一个 <code
                                  class="docutils literal"><span class="pre">collect</span></code>
                                子句决定了返回值。所以我们在这里所做的其实是重复了 <code
                                  class="docutils literal"><span class="pre">mapcar</span></code> 。</p>
                              <p><code class="docutils literal"><span class="pre">loop</span></code>
                                最常见的用途大概是蒐集调用一个函数数次的结果：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">loop</span> <span class="nv">for</span> <span class="nv">x</span> <span class="nv">from</span> <span class="mi">1</span> <span class="nv">to</span> <span class="mi">5</span>
        <span class="nv">collect</span> <span class="p">(</span><span class="nb">random</span> <span class="mi">10</span><span class="p">))</span>
<span class="p">(</span><span class="mi">3</span> <span class="mi">8</span> <span class="mi">6</span> <span class="mi">5</span> <span class="mi">0</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>这里我们获得了一个含五个随机数的列表。这跟我们定义过的 <code
                                  class="docutils literal"><span class="pre">map-int</span></code> 情况类似 (105 页「译注: 6.4
                                小节。」)。如果我们有了 <code class="docutils literal"><span class="pre">loop</span></code> ，为什么还需要
                                <code class="docutils literal"><span class="pre">map-int</span></code> ？另一个人也可以说，如果我们有了
                                <code class="docutils literal"><span class="pre">map-int</span></code> ，为什么还需要 <code
                                  class="docutils literal"><span class="pre">loop</span></code> ？
                              </p>
                              <p>一个 <code class="docutils literal"><span class="pre">collect</span></code>
                                子句也可以累积值到一个有名字的变量上。下面的函数接受一个数字的列表并返回偶数与奇数列表：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">even/odd</span> <span class="p">(</span><span class="nv">ns</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">loop</span> <span class="nv">for</span> <span class="nv">n</span> <span class="nv">in</span> <span class="nv">ns</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">evenp</span> <span class="nv">n</span><span class="p">)</span>
           <span class="nv">collect</span> <span class="nv">n</span> <span class="nv">into</span> <span class="nv">evens</span>
           <span class="nv">else</span> <span class="nv">collect</span> <span class="nv">n</span> <span class="nv">into</span> <span class="nv">odds</span>
        <span class="nv">finally</span> <span class="p">(</span><span class="nb">return</span> <span class="p">(</span><span class="nb">values</span> <span class="nv">evens</span> <span class="nv">odds</span><span class="p">))))</span>
</pre>
                                </div>
                              </div>
                              <p>一个 <code class="docutils literal"><span class="pre">finally</span></code>
                                子句贡献代码至闭幕。在这个情况它指定了返回值。</p>
                              <p>一个 <code class="docutils literal"><span class="pre">sum</span></code> 子句和一个 <code
                                  class="docutils literal"><span class="pre">collect</span></code> 子句类似，但 <code
                                  class="docutils literal"><span class="pre">sum</span></code> 子句累积一个数字，而不是一个列表。要获得
                                <code class="docutils literal"><span class="pre">1</span></code> 至 <code
                                  class="docutils literal"><span class="pre">n</span></code> 的和，我们可以写：
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">sum</span> <span class="p">(</span><span class="nv">n</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">loop</span> <span class="nv">for</span> <span class="nv">x</span> <span class="nv">from</span> <span class="mi">1</span> <span class="nv">to</span> <span class="nv">n</span>
        <span class="nv">sum</span> <span class="nv">x</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p><code class="docutils literal"><span class="pre">loop</span></code> 更进一步的细节在附录 D 讨论，从
                                325 页开始。举个例子，图 14.1 包含了先前章节的两个迭代函数，而图 14.2 演示了将同样的函数翻译成 <code
                                  class="docutils literal"><span class="pre">loop</span></code> 。</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">most</span> <span class="p">(</span><span class="nv">fn</span> <span class="nv">lst</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">null</span> <span class="nv">lst</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">values</span> <span class="no">nil</span> <span class="no">nil</span><span class="p">)</span>
      <span class="p">(</span><span class="k">let*</span> <span class="p">((</span><span class="nv">wins</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">lst</span><span class="p">))</span>
             <span class="p">(</span><span class="nb">max</span> <span class="p">(</span><span class="nb">funcall</span> <span class="nv">fn</span> <span class="nv">wins</span><span class="p">)))</span>
        <span class="p">(</span><span class="nb">dolist</span> <span class="p">(</span><span class="nv">obj</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">lst</span><span class="p">))</span>
          <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">score</span> <span class="p">(</span><span class="nb">funcall</span> <span class="nv">fn</span> <span class="nv">obj</span><span class="p">)))</span>
            <span class="p">(</span><span class="nb">when</span> <span class="p">(</span><span class="nb">&gt;</span> <span class="nv">score</span> <span class="nb">max</span><span class="p">)</span>
              <span class="p">(</span><span class="nb">setf</span> <span class="nv">wins</span> <span class="nv">obj</span>
                    <span class="nb">max</span>  <span class="nv">score</span><span class="p">))))</span>
        <span class="p">(</span><span class="nb">values</span> <span class="nv">wins</span> <span class="nb">max</span><span class="p">))))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">num-year</span> <span class="p">(</span><span class="nv">n</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">&lt;</span> <span class="nv">n</span> <span class="mi">0</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">do*</span> <span class="p">((</span><span class="nv">y</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">yzero</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">y</span> <span class="mi">1</span><span class="p">))</span>
            <span class="p">(</span><span class="nv">d</span> <span class="p">(</span><span class="nb">-</span> <span class="p">(</span><span class="nv">year-days</span> <span class="nv">y</span><span class="p">))</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">d</span> <span class="p">(</span><span class="nv">year-days</span> <span class="nv">y</span><span class="p">))))</span>
           <span class="p">((</span><span class="nb">&lt;=</span> <span class="nv">d</span> <span class="nv">n</span><span class="p">)</span> <span class="p">(</span><span class="nb">values</span> <span class="nv">y</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">n</span> <span class="nv">d</span><span class="p">))))</span>
      <span class="p">(</span><span class="nb">do*</span> <span class="p">((</span><span class="nv">y</span> <span class="nv">yzero</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">y</span> <span class="mi">1</span><span class="p">))</span>
            <span class="p">(</span><span class="nv">prev</span> <span class="mi">0</span> <span class="nv">d</span><span class="p">)</span>
            <span class="p">(</span><span class="nv">d</span> <span class="p">(</span><span class="nv">year-days</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">d</span> <span class="p">(</span><span class="nv">year-days</span> <span class="nv">y</span><span class="p">))))</span>
           <span class="p">((</span><span class="nb">&gt;</span> <span class="nv">d</span> <span class="nv">n</span><span class="p">)</span> <span class="p">(</span><span class="nb">values</span> <span class="nv">y</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">n</span> <span class="nv">prev</span><span class="p">))))))</span>
</pre>
                                </div>
                              </div>
                              <p><strong>图 14.1 不使用 loop 的迭代函数</strong></p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">most</span> <span class="p">(</span><span class="nv">fn</span> <span class="nv">lst</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">null</span> <span class="nv">lst</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">values</span> <span class="no">nil</span> <span class="no">nil</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">loop</span> <span class="nv">with</span> <span class="nv">wins</span> <span class="nb">=</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">lst</span><span class="p">)</span>
            <span class="nv">with</span> <span class="nb">max</span> <span class="nb">=</span> <span class="p">(</span><span class="nb">funcall</span> <span class="nv">fn</span> <span class="nv">wins</span><span class="p">)</span>
            <span class="nv">for</span> <span class="nv">obj</span> <span class="nv">in</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">lst</span><span class="p">)</span>
            <span class="nv">for</span> <span class="nv">score</span> <span class="nb">=</span> <span class="p">(</span><span class="nb">funcall</span> <span class="nv">fn</span> <span class="nv">obj</span><span class="p">)</span>
            <span class="nb">when</span> <span class="p">(</span><span class="nb">&gt;</span> <span class="nv">score</span> <span class="nb">max</span><span class="p">)</span>
                 <span class="p">(</span><span class="nb">do</span> <span class="p">(</span><span class="nb">setf</span> <span class="nv">wins</span> <span class="nv">obj</span>
                           <span class="nb">max</span> <span class="nv">score</span><span class="p">)</span>
            <span class="nv">finally</span> <span class="p">(</span><span class="nb">return</span> <span class="p">(</span><span class="nb">values</span> <span class="nv">wins</span> <span class="nb">max</span><span class="p">))))))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">num-year</span> <span class="p">(</span><span class="nv">n</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">&lt;</span> <span class="nv">n</span> <span class="mi">0</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">loop</span> <span class="nv">for</span> <span class="nv">y</span> <span class="nv">downfrom</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">yzero</span> <span class="mi">1</span><span class="p">)</span>
            <span class="nv">until</span> <span class="p">(</span><span class="nb">&lt;=</span> <span class="nv">d</span> <span class="nv">n</span><span class="p">)</span>
            <span class="nv">sum</span> <span class="p">(</span><span class="nb">-</span> <span class="p">(</span><span class="nv">year-days</span> <span class="nv">y</span><span class="p">))</span> <span class="nv">into</span> <span class="nv">d</span>
            <span class="nv">finally</span> <span class="p">(</span><span class="nb">return</span> <span class="p">(</span><span class="nb">values</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">y</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">n</span> <span class="nv">d</span><span class="p">))))</span>
      <span class="p">(</span><span class="nb">loop</span> <span class="nv">with</span> <span class="nv">prev</span> <span class="nb">=</span> <span class="mi">0</span>
            <span class="nv">for</span> <span class="nv">y</span> <span class="nv">from</span> <span class="nv">yzero</span>
            <span class="nv">until</span> <span class="p">(</span><span class="nb">&gt;</span> <span class="nv">d</span> <span class="nv">n</span><span class="p">)</span>
            <span class="nb">do</span> <span class="p">(</span><span class="nb">setf</span> <span class="nv">prev</span> <span class="nv">d</span><span class="p">)</span>
            <span class="nv">sum</span> <span class="p">(</span><span class="nv">year-days</span> <span class="nv">y</span><span class="p">)</span> <span class="nv">into</span> <span class="nv">d</span>
            <span class="nv">finally</span> <span class="p">(</span><span class="nb">return</span> <span class="p">(</span><span class="nb">values</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">y</span> <span class="mi">1</span><span class="p">)</span>
                                    <span class="p">(</span><span class="nb">-</span> <span class="nv">n</span> <span class="nv">prev</span><span class="p">))))))</span>
</pre>
                                </div>
                              </div>
                              <p><strong>图 14.2 使用 loop 的迭代函数</strong></p>
                              <p>一个 <code class="docutils literal"><span class="pre">loop</span></code>
                                的子句可以参照到由另一个子句所设置的变量。举例来说，在 <code
                                  class="docutils literal"><span class="pre">even/odd</span></code> 的定义里面， <code
                                  class="docutils literal"><span class="pre">finally</span></code> 子句参照到由两个 <code
                                  class="docutils literal"><span class="pre">collect</span></code> 子句所创建的变量。这些变量之间的关系，是
                                <code class="docutils literal"><span class="pre">loop</span></code>
                                定义最含糊不清的地方。考虑下列两个表达式：
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">loop</span> <span class="nv">for</span> <span class="nv">y</span> <span class="nb">=</span> <span class="mi">0</span> <span class="nv">then</span> <span class="nv">z</span>
      <span class="nv">for</span> <span class="nv">x</span> <span class="nv">from</span> <span class="mi">1</span> <span class="nv">to</span> <span class="mi">5</span>
      <span class="nv">sum</span> <span class="mi">1</span> <span class="nv">into</span> <span class="nv">z</span>
      <span class="nv">finally</span> <span class="p">(</span><span class="nb">return</span> <span class="nv">y</span> <span class="nv">z</span><span class="p">))</span>

<span class="p">(</span><span class="nb">loop</span> <span class="nv">for</span> <span class="nv">x</span> <span class="nv">from</span> <span class="mi">1</span> <span class="nv">to</span> <span class="mi">5</span>
      <span class="nv">for</span> <span class="nv">y</span> <span class="nb">=</span> <span class="mi">0</span> <span class="nv">then</span> <span class="nv">z</span>
      <span class="nv">sum</span> <span class="mi">1</span> <span class="nv">into</span> <span class="nv">z</span>
      <span class="nv">finally</span> <span class="p">(</span><span class="nb">return</span> <span class="nv">y</span> <span class="nv">z</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p>它们看起来够简单 ── 每一个有四个子句。但它们返回同样的值吗？它们返回的值多少？你若试着在标准中想找答案将徒劳无功。每一个 <code
                                  class="docutils literal"><span class="pre">loop</span></code>
                                子句本身是够简单的。但它们组合起来的方式是极为复杂的 ── 而最终，甚至标准里也没有明确定义。</p>
                              <p>由于这类原因，使用 <code class="docutils literal"><span class="pre">loop</span></code> 是不推荐的。推荐
                                <code class="docutils literal"><span class="pre">loop</span></code> 的理由，你最多可以说，在像是图 14.2
                                这般经典的例子中， <code class="docutils literal"><span class="pre">loop</span></code>
                                让代码看起来更容易理解。
                              </p>
                            </div>
                            <div class="section" id="conditions">
                              <h4>14.6 状况 (Conditions)<a class="headerlink" href="#conditions"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>在 Common Lisp 里，状况 (condition)包括了错误以及其它可能在执行期发生的情况。当一个状况被捕捉时 (signalled)，相应的处理程序
                                (handler)会被调用。处理错误状况的缺省处理程序通常会调用一个中断循环 (break-loop)。但 Common Lisp
                                提供了多样的操作符来捕捉及处理错误。要覆写缺省的处理程序，甚至是自己写一个新的处理程序也是有可能的。</p>
                              <p>多数的程序员不会直接处理状况。然而有许多更抽象的操作符使用了状况，而要了解这些操作符，知道背后的原理是很有用的。</p>
                              <p>Common lisp 有数个操作符用来捕捉错误。最基本的是 <code
                                  class="docutils literal"><span class="pre">error</span></code> 。一个调用它的方法是给入你会给 <code
                                  class="docutils literal"><span class="pre">format</span></code> 的相同参数：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">error</span> <span class="s">&quot;Your report uses ~A as a verb.&quot;</span> <span class="ss">&#39;status</span><span class="p">)</span>
<span class="nv">Error:</span> <span class="nv">Your</span> <span class="nv">report</span> <span class="nv">uses</span> <span class="nv">STATUS</span> <span class="nv">as</span> <span class="nv">a</span> <span class="nv">verb</span>
                         <span class="nv">Options:</span> <span class="ss">:abort,</span> <span class="ss">:backtrace</span>
<span class="nv">&gt;&gt;</span>
</pre>
                                </div>
                              </div>
                              <p>如上所示，除非这样的状况被处理好了，不然执行就会被打断。</p>
                              <p>用来捕捉错误的更抽象操作符包括了 <code class="docutils literal"><span class="pre">ecase</span></code> 、
                                <code class="docutils literal"><span class="pre">check-type</span></code> 以及 <code
                                  class="docutils literal"><span class="pre">assert</span></code> 。前者与 <code
                                  class="docutils literal"><span class="pre">case</span></code> 相似，要是没有键值匹配时会捕捉一个错误：
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">ecase</span> <span class="mi">1</span> <span class="p">(</span><span class="mi">2</span> <span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="mi">4</span> <span class="mi">5</span><span class="p">))</span>
<span class="nv">Error:</span> <span class="nv">No</span> <span class="nv">applicable</span> <span class="nv">clause</span>
                         <span class="nv">Options:</span> <span class="ss">:abort,</span> <span class="ss">:backtrace</span>
<span class="nv">&gt;&gt;</span>
</pre>
                                </div>
                              </div>
                              <p>普通的 <code class="docutils literal"><span class="pre">case</span></code> 在没有键值匹配时会返回
                                <code class="docutils literal"><span class="pre">nil</span></code>
                                ，但由于利用这个返回值是很差的编码风格，你或许会在当你没有 <code
                                  class="docutils literal"><span class="pre">otherwise</span></code> 子句时使用 <code
                                  class="docutils literal"><span class="pre">ecase</span></code> 。
                              </p>
                              <p><code class="docutils literal"><span class="pre">check-type</span></code>
                                宏接受一个位置，一个类型名以及一个选择性字符串，并在该位置的值不是预期的类型时，捕捉一个可修正的错误 (correctable
                                error)。一个可修正错误的处理程序会给我们一个机会来提供一个新的值：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">x</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">)))</span>
                <span class="p">(</span><span class="nb">check-type</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">x</span><span class="p">)</span> <span class="nc">integer</span> <span class="s">&quot;an integer&quot;</span><span class="p">)</span>
                <span class="nv">x</span><span class="p">)</span>
<span class="nv">Error:</span> <span class="nv">The</span> <span class="nv">value</span> <span class="nv">of</span> <span class="p">(</span><span class="nv">CAR</span> <span class="nv">X</span><span class="p">)</span><span class="o">,</span> <span class="nv">A,</span> <span class="nv">should</span> <span class="nv">be</span> <span class="nv">an</span> <span class="nv">integer.</span>
<span class="nv">Options:</span> <span class="ss">:abort,</span> <span class="ss">:backtrace,</span> <span class="ss">:continue</span>
<span class="nv">&gt;&gt;</span> <span class="ss">:continue</span>
<span class="nv">New</span> <span class="nv">value</span> <span class="nv">of</span> <span class="p">(</span><span class="nv">CAR</span> <span class="nv">X</span><span class="p">)</span><span class="nv">?</span> <span class="mi">99</span>
<span class="p">(</span><span class="mi">99</span> <span class="nv">B</span> <span class="nv">C</span><span class="p">)</span>
<span class="nb">&gt;</span>
</pre>
                                </div>
                              </div>
                              <p>在这个例子里， <code
                                  class="docutils literal"><span class="pre">(car</span> <span class="pre">x)</span></code>
                                被设为我们提供的新值，并重新执行，返回了要是 <code
                                  class="docutils literal"><span class="pre">(car</span> <span class="pre">x)</span></code>
                                本来就包含我们所提供的值所会返回的结果。</p>
                              <p>这个宏是用更通用的 <code class="docutils literal"><span class="pre">assert</span></code> 所定义的，
                                <code class="docutils literal"><span class="pre">assert</span></code>
                                接受一个测试表达式以及一个有着一个或多个位置的列表，伴随着你可能传给 <code
                                  class="docutils literal"><span class="pre">error</span></code> 的参数：
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">sandwich</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">ham</span> <span class="nv">on</span> <span class="nv">rye</span><span class="p">)))</span>
    <span class="p">(</span><span class="nb">assert</span> <span class="p">(</span><span class="nb">eql</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">sandwich</span><span class="p">)</span> <span class="ss">&#39;chicken</span><span class="p">)</span>
            <span class="p">((</span><span class="nb">car</span> <span class="nv">sandwich</span><span class="p">))</span>
            <span class="s">&quot;I wanted a ~A sandwich.&quot;</span> <span class="ss">&#39;chicken</span><span class="p">)</span>
    <span class="nv">sandwich</span><span class="p">)</span>
<span class="nv">Error:</span> <span class="nv">I</span> <span class="nv">wanted</span> <span class="nv">a</span> <span class="nv">CHICKEN</span> <span class="nv">sandwich.</span>
<span class="nv">Options:</span> <span class="ss">:abort,</span> <span class="ss">:backtrace,</span> <span class="ss">:continue</span>
<span class="nv">&gt;&gt;</span> <span class="ss">:continue</span>
<span class="nv">New</span> <span class="nv">value</span> <span class="nv">of</span> <span class="p">(</span><span class="nv">CAR</span> <span class="nv">SANDWICH</span><span class="p">)</span><span class="nv">?</span> <span class="ss">&#39;chicken</span>
<span class="p">(</span><span class="nv">CHICKEN</span> <span class="nv">ON</span> <span class="nv">RYE</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>要建立新的处理程序也是可能的，但大多数程序员只会间接的利用这个可能性，通过使用像是 <code
                                  class="docutils literal"><span class="pre">ignore-errors</span></code>
                                的宏。如果它的参数没产生错误时像在 <code class="docutils literal"><span class="pre">progn</span></code>
                                里求值一样，但要是在求值过程中，不管什么参数报错，执行是不会被打断的。取而代之的是， <code
                                  class="docutils literal"><span class="pre">ignore-errors</span></code> 表达式会直接返回两个值：
                                <code class="docutils literal"><span class="pre">nil</span></code> 以及捕捉到的状况。
                              </p>
                              <p>举例来说，如果在某个时候，你想要用户能够输入一个表达式，但你不想要在输入是语法上不合时中断执行，你可以这样写：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">user-input</span> <span class="p">(</span><span class="nv">prompt</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="nv">prompt</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">str</span> <span class="p">(</span><span class="nb">read-line</span><span class="p">)))</span>
    <span class="p">(</span><span class="nb">or</span> <span class="p">(</span><span class="nb">ignore-errors</span> <span class="p">(</span><span class="nb">read-from-string</span> <span class="nv">str</span><span class="p">))</span>
        <span class="no">nil</span><span class="p">)))</span>
</pre>
                                </div>
                              </div>
                              <p>若输入包含语法错误时，这个函数仅返回 <code class="docutils literal"><span class="pre">nil</span></code> :
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre>&gt; (user-input &quot;Please type an expression&quot;)
Please type an expression&gt; #%@#+!!
NIL
</pre>
                                </div>
                              </div>
                              <p class="rubric">脚注</p>
                              <table class="docutils footnote" frame="void" id="id4" rules="none">
                                <colgroup>
                                  <col class="label" />
                                  <col />
                                </colgroup>
                                <tbody valign="top">
                                  <tr>
                                    <td class="label"><a class="fn-backref" href="#id2">[1]</a></td>
                                    <td>虽然标准没有提到这件事，你可以假定 <code
                                        class="docutils literal"><span class="pre">and</span></code> 以及 <code
                                        class="docutils literal"><span class="pre">or</span></code> 类型标示符仅考虑它们所要考虑的参数，与
                                      <code class="docutils literal"><span class="pre">or</span></code> 及 <code
                                        class="docutils literal"><span class="pre">and</span></code> 宏类似。
                                    </td>
                                  </tr>
                                </tbody>
                              </table>
                              <table class="docutils footnote" frame="void" id="id5" rules="none">
                                <colgroup>
                                  <col class="label" />
                                  <col />
                                </colgroup>
                                <tbody valign="top">
                                  <tr>
                                    <td class="label"><a class="fn-backref" href="#id3">[2]</a></td>
                                    <td>某些 Common Lisp 实现，当我们不在用户包下时，会在顶层提示符前打印包的名字。</td>
                                  </tr>
                                </tbody>
                              </table>
                            </div>
                          </div>
                          <div class="section">
                            <h3 id="15">第十五章：示例：推论
                            </h3>
                            <p>接下来三章提供了大量的 Lisp 程序例子。选择这些例子来说明那些较长的程序所采取的形式，和 Lisp 所擅长解决的问题类型。</p>
                            <p>在这一章中我们将要写一个基于一组 <code class="docutils literal"><span class="pre">if-then</span></code>
                              规则的推论程序。这是一个经典的例子 —— 不仅在于其经常出现在教科书上，还因为它反映了 Lisp 作为一个“符号计算”语言的本意。这个例子散发着很多早期 Lisp 程序的气息。
                            </p>
                            <div class="section" id="the-aim">
                              <h4>15.1 目标 (The Aim)<a class="headerlink" href="#the-aim"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>在这个程序中，我们将用一种熟悉的形式来表示信息：包含单个判断式，以及跟在之后的零个或多个参数所组成的列表。要表示 Donald 是 Nancy 的家长，我们可以这样写：
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nv">parent</span> <span class="nv">donald</span> <span class="nv">nancy</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>事实上，我们的程序是要表示一些从已有的事实作出推断的规则。我们可以这样来表示规则：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nv">&lt;-</span> <span class="nv">head</span> <span class="nv">body</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>其中， <code class="docutils literal"><span class="pre">head</span></code> 是
                                <strong>那么...部分</strong> (then-part)， <code
                                  class="docutils literal"><span class="pre">body</span></code> 是
                                <strong>如果...部分</strong> (if-part)。在 <code
                                  class="docutils literal"><span class="pre">head</span></code> 和 <code
                                  class="docutils literal"><span class="pre">body</span></code>
                                中我们使用以问号为前缀的符号来表示变量。所以下面这个规则：
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nv">&lt;-</span> <span class="p">(</span><span class="nv">child</span> <span class="nv">?x</span> <span class="nv">?y</span><span class="p">)</span> <span class="p">(</span><span class="nv">parent</span> <span class="nv">?y</span> <span class="nv">?x</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p>表示：如果 y 是 x 的家长，那么 x 是 y 的孩子；更恰当地说，我们可以通过证明 <code
                                  class="docutils literal"><span class="pre">(parent</span> <span class="pre">y</span> <span class="pre">x)</span></code>
                                来证明 <code
                                  class="docutils literal"><span class="pre">(child</span> <span class="pre">x</span> <span class="pre">y)</span></code>
                                的所表示的事实。</p>
                              <p>可以把规则中的 <em>body</em> 部分(if-part) 写成一个复杂的表达式，其中包含 <code
                                  class="docutils literal"><span class="pre">and</span></code> , <code
                                  class="docutils literal"><span class="pre">or</span></code> 和 <code
                                  class="docutils literal"><span class="pre">not</span></code> 等逻辑操作。所以当我们想要表达 “如果 x 是 y
                                的家长，并且 x 是男性，那么 x 是 y 的父亲” 这样的规则，我们可以写：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nv">&lt;-</span> <span class="p">(</span><span class="nv">father</span> <span class="nv">?x</span> <span class="nv">?y</span><span class="p">)</span> <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nv">parent</span> <span class="nv">?x</span> <span class="nv">?y</span><span class="p">)</span> <span class="p">(</span><span class="nv">male</span> <span class="nv">?x</span><span class="p">)))</span>
</pre>
                                </div>
                              </div>
                              <p>一些规则可能依赖另一些规则所产生的事实。比如，我们写的第一个规则是为了证明 <code
                                  class="docutils literal"><span class="pre">(child</span> <span class="pre">x</span> <span class="pre">y)</span></code>
                                的事实。如果我们定义如下规则：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nv">&lt;-</span> <span class="p">(</span><span class="nv">daughter</span> <span class="nv">?x</span> <span class="nv">?y</span><span class="p">)</span> <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nv">child</span> <span class="nv">?x</span> <span class="nv">?y</span><span class="p">)</span> <span class="p">(</span><span class="nv">female</span> <span class="nv">?x</span><span class="p">)))</span>
</pre>
                                </div>
                              </div>
                              <p>然后使用它来证明 <code
                                  class="docutils literal"><span class="pre">(daughter</span> <span class="pre">x</span> <span class="pre">y)</span></code>
                                可能导致程序使用第一个规则去证明 <code
                                  class="docutils literal"><span class="pre">(child</span> <span class="pre">x</span> <span class="pre">y)</span></code>
                                。</p>
                              <p>表达式的证明可以回溯任意数量的规则，只要它最终结束于给出的已知事实。这个过程有时候被称为反向链接 (backward-chaining)。之所以说 <em>反向</em>
                                (backward) 是因为这一类推论先考虑 <em>head</em> 部分，这是为了在继续证明 <em>body</em> 部分之前检查规则是否有效。<em>链接</em>
                                (chaining) 来源于规则之间的依赖关系，从我们想要证明的内容到我们的已知条件组成一个链接 (尽管事实上它更像一棵树)。 <a
                                  class="reference external"
                                  href="http://acl.readthedocs.org/en/latest/zhCN/notes-cn.html#notes-248">λ</a></p>
                            </div>
                            <div class="section" id="matching">
                              <h4>15.2 匹配 (Matching)<a class="headerlink" href="#matching"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>我们需要有一个函数来做模式匹配以完成我们的反向链接 (back-chaining)
                                程序，这个函数能够比较两个包含变量的列表，它会检查在给变量赋值后是否可以使两个列表相等。举例，如果 <code
                                  class="docutils literal"><span class="pre">?x</span></code> 和 <code
                                  class="docutils literal"><span class="pre">?y</span></code> 是变量，那么下面两个列表：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nv">p</span> <span class="nv">?x</span> <span class="nv">?y</span> <span class="nv">c</span> <span class="nv">?x</span><span class="p">)</span>
<span class="p">(</span><span class="nv">p</span>  <span class="nv">a</span>  <span class="nv">b</span> <span class="nv">c</span>  <span class="nv">a</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>当 <code
                                  class="docutils literal"><span class="pre">?x</span> <span class="pre">=</span> <span class="pre">a</span></code>
                                且 <code
                                  class="docutils literal"><span class="pre">?y</span> <span class="pre">=</span> <span class="pre">b</span></code>
                                时匹配，而下面两个列表：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nv">p</span> <span class="nv">?x</span> <span class="nv">b</span> <span class="nv">?y</span> <span class="nv">a</span><span class="p">)</span>
<span class="p">(</span><span class="nv">p</span> <span class="nv">?y</span> <span class="nv">b</span>  <span class="nv">c</span> <span class="nv">a</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>当 <code
                                  class="docutils literal"><span class="pre">?x</span> <span class="pre">=</span> <span class="pre">?y</span> <span class="pre">=</span> <span class="pre">c</span></code>
                                时匹配。</p>
                              <p>我们有一个 <code class="docutils literal"><span class="pre">match</span></code>
                                函数，它接受两棵树，如果这两棵树能匹配，则返回一个关联列表（assoc-list）来显示他们是如何匹配的：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">match</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">y</span> <span class="k">&amp;optional</span> <span class="nv">binds</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">cond</span>
   <span class="p">((</span><span class="nb">eql</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="nb">values</span> <span class="nv">binds</span> <span class="no">t</span><span class="p">))</span>
   <span class="p">((</span><span class="nb">assoc</span> <span class="nv">x</span> <span class="nv">binds</span><span class="p">)</span> <span class="p">(</span><span class="nv">match</span> <span class="p">(</span><span class="nv">binding</span> <span class="nv">x</span> <span class="nv">binds</span><span class="p">)</span> <span class="nv">y</span> <span class="nv">binds</span><span class="p">))</span>
   <span class="p">((</span><span class="nb">assoc</span> <span class="nv">y</span> <span class="nv">binds</span><span class="p">)</span> <span class="p">(</span><span class="nv">match</span> <span class="nv">x</span> <span class="p">(</span><span class="nv">binding</span> <span class="nv">y</span> <span class="nv">binds</span><span class="p">)</span> <span class="nv">binds</span><span class="p">))</span>
   <span class="p">((</span><span class="nv">var?</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">values</span> <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nb">cons</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span> <span class="nv">binds</span><span class="p">)</span> <span class="no">t</span><span class="p">))</span>
   <span class="p">((</span><span class="nv">var?</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="nb">values</span> <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nb">cons</span> <span class="nv">y</span> <span class="nv">x</span><span class="p">)</span> <span class="nv">binds</span><span class="p">)</span> <span class="no">t</span><span class="p">))</span>
   <span class="p">(</span><span class="no">t</span>
    <span class="p">(</span><span class="nb">when</span> <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nb">consp</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">consp</span> <span class="nv">y</span><span class="p">))</span>
      <span class="p">(</span><span class="nb">multiple-value-bind</span> <span class="p">(</span><span class="nv">b2</span> <span class="nv">yes</span><span class="p">)</span>
                           <span class="p">(</span><span class="nv">match</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">y</span><span class="p">)</span> <span class="nv">binds</span><span class="p">)</span>
        <span class="p">(</span><span class="nb">and</span> <span class="nv">yes</span> <span class="p">(</span><span class="nv">match</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">y</span><span class="p">)</span> <span class="nv">b2</span><span class="p">)))))))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">var?</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nb">symbolp</span> <span class="nv">x</span><span class="p">)</span>
       <span class="p">(</span><span class="nb">eql</span> <span class="p">(</span><span class="nb">char</span> <span class="p">(</span><span class="nb">symbol-name</span> <span class="nv">x</span><span class="p">)</span> <span class="mi">0</span><span class="p">)</span> <span class="sc">#\?</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">binding</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">binds</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">b</span> <span class="p">(</span><span class="nb">assoc</span> <span class="nv">x</span> <span class="nv">binds</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">if</span> <span class="nv">b</span>
        <span class="p">(</span><span class="nb">or</span> <span class="p">(</span><span class="nv">binding</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">b</span><span class="p">)</span> <span class="nv">binds</span><span class="p">)</span>
            <span class="p">(</span><span class="nb">cdr</span> <span class="nv">b</span><span class="p">)))))</span>
</pre>
                                </div>
                              </div>
                              <p><strong>图 15.1: 匹配函数。</strong></p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">match</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">p</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">a</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">p</span> <span class="nv">?x</span> <span class="nv">?y</span> <span class="nv">c</span> <span class="nv">?x</span><span class="p">))</span>
<span class="p">((</span><span class="nv">?Y</span> <span class="o">.</span> <span class="nv">B</span><span class="p">)</span> <span class="p">(</span><span class="nv">?X</span> <span class="o">.</span> <span class="nv">A</span><span class="p">))</span>
<span class="no">T</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="nv">match</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">p</span> <span class="nv">?x</span> <span class="nv">b</span> <span class="nv">?y</span> <span class="nv">a</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">p</span> <span class="nv">?y</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">a</span><span class="p">))</span>
<span class="p">((</span><span class="nv">?Y</span> <span class="o">.</span> <span class="nv">C</span><span class="p">)</span> <span class="p">(</span><span class="nv">?X</span> <span class="o">.</span> <span class="nv">?Y</span><span class="p">))</span>
<span class="no">T</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="nv">match</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">a</span> <span class="nv">a</span><span class="p">))</span>
<span class="no">NIL</span>
</pre>
                                </div>
                              </div>
                              <p>当 <code class="docutils literal"><span class="pre">match</span></code>
                                函数逐个元素地比较它的参数时候，它把 <code class="docutils literal"><span class="pre">binds</span></code>
                                参数中的值分配给变量，这被称为绑定 (bindings)。如果成功匹配， <code
                                  class="docutils literal"><span class="pre">match</span></code> 函数返回生成的绑定；否则，返回 <code
                                  class="docutils literal"><span class="pre">nil</span></code> 。当然并不是所有成功的匹配都会产生绑定，我们的
                                <code class="docutils literal"><span class="pre">match</span></code> 函数就像 <code
                                  class="docutils literal"><span class="pre">gethash</span></code> 函数那样返回第二个值来表明匹配成功：
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">match</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">p</span> <span class="nv">?x</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">p</span> <span class="nv">?x</span><span class="p">))</span>
<span class="no">NIL</span>
<span class="no">T</span>
</pre>
                                </div>
                              </div>
                              <p>如果 <code class="docutils literal"><span class="pre">match</span></code> 函数像上面那样返回 <code
                                  class="docutils literal"><span class="pre">nil</span></code> 和 <code
                                  class="docutils literal"><span class="pre">t</span></code> ，表明这是一个没有产生绑定的成功匹配。下面用中文来描述
                                <code class="docutils literal"><span class="pre">match</span></code> 算法是如何工作的：
                              </p>
                              <ol class="arabic simple">
                                <li>如果 x 和 y 在 <code class="docutils literal"><span class="pre">eql</span></code>
                                  上相等那么它们匹配；否则，</li>
                                <li>如果 x 是一个已绑定的变量，并且绑定匹配 y ，那么它们匹配；否则，</li>
                                <li>如果 y 是一个已绑定的变量，并且绑定匹配 x ，那么它们匹配；否则，</li>
                                <li>如果 x 是一个未绑定的变量，那么它们匹配，并且为 x 建立一个绑定；否则，</li>
                                <li>如果 y 是一个未绑定的变量，那么它们匹配，并且为 y 建立一个绑定；否则，</li>
                                <li>如果 x 和 y 都是 <code class="docutils literal"><span class="pre">cons</span></code>
                                  ，并且它们的 <code class="docutils literal"><span class="pre">car</span></code> 匹配，由此产生的绑定又让
                                  <code class="docutils literal"><span class="pre">cdr</span></code> 匹配，那么它们匹配。
                                </li>
                              </ol>
                              <p>下面是一个例子，按顺序来说明以上六种情况：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">match</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">p</span> <span class="nv">?v</span>  <span class="nv">b</span> <span class="nv">?x</span>  <span class="nv">d</span> <span class="p">(</span><span class="nv">?z</span> <span class="nv">?z</span><span class="p">))</span>
         <span class="o">&#39;</span><span class="p">(</span><span class="nv">p</span>  <span class="nv">a</span> <span class="nv">?w</span>  <span class="nv">c</span> <span class="nv">?y</span> <span class="p">(</span> <span class="nv">e</span>  <span class="nv">e</span><span class="p">))</span>
         <span class="o">&#39;</span><span class="p">((</span><span class="nv">?v</span> <span class="o">.</span> <span class="nv">a</span><span class="p">)</span> <span class="p">(</span><span class="nv">?w</span> <span class="o">.</span> <span class="nv">b</span><span class="p">)))</span>
<span class="p">((</span><span class="nv">?Z</span> <span class="o">.</span> <span class="nv">E</span><span class="p">)</span> <span class="p">(</span><span class="nv">?Y</span> <span class="o">.</span> <span class="nv">D</span><span class="p">)</span> <span class="p">(</span><span class="nv">?X</span> <span class="o">.</span> <span class="nv">C</span><span class="p">)</span> <span class="p">(</span><span class="nv">?V</span> <span class="o">.</span> <span class="nv">A</span><span class="p">)</span> <span class="p">(</span><span class="nv">?W</span> <span class="o">.</span> <span class="nv">B</span><span class="p">))</span>
<span class="no">T</span>
</pre>
                                </div>
                              </div>
                              <p><code class="docutils literal"><span class="pre">match</span></code> 函数通过调用 <code
                                  class="docutils literal"><span class="pre">binding</span></code>
                                函数在一个绑定列表中寻找变量（如果有的话）所关联的值。这个函数必须是递归的，因为有这样的情况 “匹配建立一个绑定列表，而列表中变量只是间接关联到它的值： <code
                                  class="docutils literal"><span class="pre">?x</span></code> 可能被绑定到一个包含 <code
                                  class="docutils literal"><span class="pre">(?x</span> <span class="pre">.</span> <span class="pre">?y)</span></code>
                                和 <code
                                  class="docutils literal"><span class="pre">(?y</span> <span class="pre">.</span> <span class="pre">a)</span></code>
                                的列表”：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">match</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">?x</span> <span class="nv">a</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">?y</span> <span class="nv">?y</span><span class="p">))</span>
<span class="p">((</span><span class="nv">?Y</span> <span class="o">.</span> <span class="nv">A</span><span class="p">)</span> <span class="p">(</span><span class="nv">?X</span> <span class="o">.</span> <span class="nv">?Y</span><span class="p">))</span>
<span class="no">T</span>
</pre>
                                </div>
                              </div>
                              <p>先匹配 <code class="docutils literal"><span class="pre">?x</span></code> 和 <code
                                  class="docutils literal"><span class="pre">?y</span></code> ，然后匹配 <code
                                  class="docutils literal"><span class="pre">?y</span></code> 和 <code
                                  class="docutils literal"><span class="pre">a</span></code> ，我们间接确定 <code
                                  class="docutils literal"><span class="pre">?x</span></code> 是 <code
                                  class="docutils literal"><span class="pre">a</span></code> 。</p>
                            </div>
                            <div class="section" id="answering-queries">
                              <h4>15.3 回答查询 (Answering Queries)<a class="headerlink" href="#answering-queries"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>
                                在介绍了绑定的概念之后，我们可以更准确的说一下我们的程序将要做什么：它得到一个可能包含变量的表达式，根据我们给定的事实和规则返回使它正确的所有绑定。比如，我们只有下面这个事实：
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nv">parent</span> <span class="nv">donald</span> <span class="nv">nancy</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>然后我们想让程序证明：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nv">parent</span> <span class="nv">?x</span> <span class="nv">?y</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>它会返回像下面这样的表达：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(((</span><span class="nv">?x</span> <span class="o">.</span> <span class="nv">donald</span><span class="p">)</span> <span class="p">(</span><span class="nv">?y</span> <span class="o">.</span> <span class="nv">nancy</span><span class="p">)))</span>
</pre>
                                </div>
                              </div>
                              <p>它告诉我们只有一个可以让这个表达式为真的方法： <code
                                  class="docutils literal"><span class="pre">?x</span></code> 是 <code
                                  class="docutils literal"><span class="pre">donald</span></code> 并且 <code
                                  class="docutils literal"><span class="pre">?y</span></code> 是 <code
                                  class="docutils literal"><span class="pre">nancy</span></code> 。</p>
                              <p>在通往目标的路上，我们已经有了一个的重要部分：一个匹配函数。
                                下面是用来定义规则的一段代码：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defvar</span> <span class="vg">*rules*</span> <span class="p">(</span><span class="nb">make-hash-table</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defmacro</span> <span class="nv">&lt;-</span> <span class="p">(</span><span class="nv">con</span> <span class="k">&amp;optional</span> <span class="nv">ant</span><span class="p">)</span>
  <span class="o">`</span><span class="p">(</span><span class="nb">length</span> <span class="p">(</span><span class="nb">push</span> <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nb">cdr</span> <span class="ss">&#39;,con</span><span class="p">)</span> <span class="ss">&#39;,ant</span><span class="p">)</span>
                 <span class="p">(</span><span class="nb">gethash</span> <span class="p">(</span><span class="nb">car</span> <span class="ss">&#39;,con</span><span class="p">)</span> <span class="vg">*rules*</span><span class="p">))))</span>
</pre>
                                </div>
                              </div>
                              <p><strong>图 15.2 定义规则</strong></p>
                              <p>规则将被包含于一个叫做 <code class="docutils literal"><span class="pre">*rules*</span></code>
                                的哈希表，通过头部 (head)
                                的判断式构建这个哈系表。这样做加强了我们无法使用判断式中的变量的限制。虽然我们可以通过把所有这样的规则放在分离的列表中来消除限制，但是如果这样做，当我们需要证明某件事的时侯不得不和每一个列表进行匹配。
                              </p>
                              <p>我们将要使用同一个宏 <code class="docutils literal"><span class="pre">&lt;-</span></code> 去定义事实
                                (facts)和规则 (rules)。一个事实将被表示成一个没有 <em>body</em> 部分的规则。这和我们对规则的定义保持一致。一个规则告诉我们你可以通过证明
                                <em>body</em> 部分来证明 <em>head</em> 部分，所以没有 <em>body</em> 部分的规则意味着你不需要通过证明任何东西来证明
                                <em>head</em> 部分。这里有两个对应的例子：
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">&lt;-</span> <span class="p">(</span><span class="nv">parent</span> <span class="nv">donald</span> <span class="nv">nancy</span><span class="p">))</span>
<span class="mi">1</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="nv">&lt;-</span> <span class="p">(</span><span class="nv">child</span> <span class="nv">?x</span> <span class="nv">?y</span><span class="p">)</span> <span class="p">(</span><span class="nv">parent</span> <span class="nv">?y</span> <span class="nv">?x</span><span class="p">))</span>
<span class="mi">1</span>
</pre>
                                </div>
                              </div>
                              <p>调用 <code class="docutils literal"><span class="pre">&lt;-</span></code>
                                返回的是给定判断式下存储的规则数量；用 <code
                                  class="docutils literal"><span class="pre">length</span></code> 函数来包装 <code
                                  class="docutils literal"><span class="pre">push</span></code> 能使我们免于看到顶层中的一大堆返回值。</p>
                              <p>下面是我们的推论程序所需的大多数代码：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">prove</span> <span class="p">(</span><span class="nv">expr</span> <span class="k">&amp;optional</span> <span class="nv">binds</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">case</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">expr</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nv">prove-and</span> <span class="p">(</span><span class="nb">reverse</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">expr</span><span class="p">))</span> <span class="nv">binds</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">or</span>  <span class="p">(</span><span class="nv">prove-or</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">expr</span><span class="p">)</span> <span class="nv">binds</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">not</span> <span class="p">(</span><span class="nv">prove-not</span> <span class="p">(</span><span class="nb">cadr</span> <span class="nv">expr</span><span class="p">)</span> <span class="nv">binds</span><span class="p">))</span>
    <span class="p">(</span><span class="no">t</span>   <span class="p">(</span><span class="nv">prove-simple</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">expr</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">expr</span><span class="p">)</span> <span class="nv">binds</span><span class="p">))))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">prove-simple</span> <span class="p">(</span><span class="nv">pred</span> <span class="nv">args</span> <span class="nv">binds</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">mapcan</span> <span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">r</span><span class="p">)</span>
              <span class="p">(</span><span class="nb">multiple-value-bind</span> <span class="p">(</span><span class="nv">b2</span> <span class="nv">yes</span><span class="p">)</span>
                                   <span class="p">(</span><span class="nv">match</span> <span class="nv">args</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">r</span><span class="p">)</span>
                                          <span class="nv">binds</span><span class="p">)</span>
                <span class="p">(</span><span class="nb">when</span> <span class="nv">yes</span>
                  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">r</span><span class="p">)</span>
                      <span class="p">(</span><span class="nv">prove</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">r</span><span class="p">)</span> <span class="nv">b2</span><span class="p">)</span>
                      <span class="p">(</span><span class="nb">list</span> <span class="nv">b2</span><span class="p">)))))</span>
          <span class="p">(</span><span class="nb">mapcar</span> <span class="nf">#&#39;</span><span class="nv">change-vars</span>
                  <span class="p">(</span><span class="nb">gethash</span> <span class="nv">pred</span> <span class="vg">*rules*</span><span class="p">))))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">change-vars</span> <span class="p">(</span><span class="nv">r</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">sublis</span> <span class="p">(</span><span class="nb">mapcar</span> <span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">v</span><span class="p">)</span> <span class="p">(</span><span class="nb">cons</span> <span class="nv">v</span> <span class="p">(</span><span class="nb">gensym</span> <span class="s">&quot;?&quot;</span><span class="p">)))</span>
                  <span class="p">(</span><span class="nv">vars-in</span> <span class="nv">r</span><span class="p">))</span>
          <span class="nv">r</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">vars-in</span> <span class="p">(</span><span class="nv">expr</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">atom</span> <span class="nv">expr</span><span class="p">)</span>
      <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nv">var?</span> <span class="nv">expr</span><span class="p">)</span> <span class="p">(</span><span class="nb">list</span> <span class="nv">expr</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">union</span> <span class="p">(</span><span class="nv">vars-in</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">expr</span><span class="p">))</span>
           <span class="p">(</span><span class="nv">vars-in</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">expr</span><span class="p">)))))</span>
</pre>
                                </div>
                              </div>
                              <p><strong>图 15.3: 推论。</strong></p>
                              <p>上面代码中的 <code class="docutils literal"><span class="pre">prove</span></code>
                                函数是推论进行的枢纽。它接受一个表达式和一个可选的绑定列表作为参数。如果表达式不包含逻辑操作，它调用 <code
                                  class="docutils literal"><span class="pre">prove-simple</span></code> 函数，前面所说的链接
                                (chaining)正是在这个函数里产生的。这个函数查看所有拥有正确判断式的规则，并尝试对每一个规则的 <em>head</em>
                                部分和它想要证明的事实做匹配。对于每一个匹配的 <em>head</em> ，使用匹配所产生的新的绑定在 <em>body</em> 上调用 <code
                                  class="docutils literal"><span class="pre">prove</span></code> 。对 <code
                                  class="docutils literal"><span class="pre">prove</span></code> 的调用所产生的绑定列表被 <code
                                  class="docutils literal"><span class="pre">mapcan</span></code> 收集并返回：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">prove-simple</span> <span class="ss">&#39;parent</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">donald</span> <span class="nv">nancy</span><span class="p">)</span> <span class="no">nil</span><span class="p">)</span>
<span class="p">(</span><span class="no">NIL</span><span class="p">)</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="nv">prove-simple</span> <span class="ss">&#39;child</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">?x</span> <span class="nv">?y</span><span class="p">)</span> <span class="no">nil</span><span class="p">)</span>
<span class="p">(((</span><span class="ss">#:?6</span> <span class="o">.</span> <span class="nv">NANCY</span><span class="p">)</span> <span class="p">(</span><span class="ss">#:?5</span> <span class="o">.</span> <span class="nv">DONALD</span><span class="p">)</span> <span class="p">(</span><span class="nv">?Y</span> <span class="o">.</span> <span class="ss">#:?5</span><span class="p">)</span> <span class="p">(</span><span class="nv">?X</span> <span class="o">.</span> <span class="ss">#:?6</span><span class="p">)))</span>
</pre>
                                </div>
                              </div>
                              <p>以上两个返回值指出有一种方法可以证明我们的问题。（一个失败的证明将返回 nil。）第一个例子产生了一组空的绑定，第二个例子产生了这样的绑定： <code
                                  class="docutils literal"><span class="pre">?x</span></code> 和 <code
                                  class="docutils literal"><span class="pre">?y</span></code> 被（间接）绑定到 <code
                                  class="docutils literal"><span class="pre">nancy</span></code> 和 <code
                                  class="docutils literal"><span class="pre">donald</span></code> 。</p>
                              <p>顺便说一句，这是一个很好的例子来实践 2.13 节提出的观点。因为我们用函数式的风格来写这个程序，所以可以交互式地测试每一个函数。</p>
                              <p>第二个例子返回的值里那些 <em>gensyms</em> 是怎么回事？如果我们打算使用含有变量的规则，我们需要避免两个规则恰好包含相同的变量。如果我们定义如下两条规则：
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nv">&lt;-</span> <span class="p">(</span><span class="nv">child</span> <span class="nv">?x</span> <span class="nv">?y</span><span class="p">)</span> <span class="p">(</span><span class="nv">parent</span> <span class="nv">?y</span> <span class="nv">?x</span><span class="p">))</span>

<span class="p">(</span><span class="nv">&lt;-</span> <span class="p">(</span><span class="nv">daughter</span> <span class="nv">?y</span> <span class="nv">?x</span><span class="p">)</span> <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nv">child</span> <span class="nv">?y</span> <span class="nv">?x</span><span class="p">)</span> <span class="p">(</span><span class="nv">female</span> <span class="nv">?y</span><span class="p">)))</span>
</pre>
                                </div>
                              </div>
                              <p>第一条规则要表达的意思是：对于任何的 <code class="docutils literal"><span class="pre">x</span></code> 和
                                <code class="docutils literal"><span class="pre">y</span></code> ， 如果 <code
                                  class="docutils literal"><span class="pre">y</span></code> 是 <code
                                  class="docutils literal"><span class="pre">x</span></code> 的家长，则 <code
                                  class="docutils literal"><span class="pre">x</span></code> 是 <code
                                  class="docutils literal"><span class="pre">y</span></code> 的孩子。第二条则是：对于任何的 <code
                                  class="docutils literal"><span class="pre">x</span></code> 和 <code
                                  class="docutils literal"><span class="pre">y</span></code> ， 如果 <code
                                  class="docutils literal"><span class="pre">y</span></code> 是 <code
                                  class="docutils literal"><span class="pre">x</span></code> 的孩子并且 <code
                                  class="docutils literal"><span class="pre">y</span></code> 是女性，则 <code
                                  class="docutils literal"><span class="pre">y</span></code> 是 <code
                                  class="docutils literal"><span class="pre">x</span></code>
                                的女儿。在每一条规则内部，变量之间的关系是显著的，但是两条规则使用了相同的变量并非我们刻意为之。
                              </p>
                              <p>如果我们使用上面所写的规则，它们将不会按预期的方式工作。如果我们尝试证明“ a 是 b 的女儿”，匹配到第二条规则的 <em>head</em> 部分时会将 <code
                                  class="docutils literal"><span class="pre">a</span></code> 绑定到 <code
                                  class="docutils literal"><span class="pre">?y</span></code> ，将 <code
                                  class="docutils literal"><span class="pre">b</span></code> 绑定到 ?x。我们无法用这样的绑定匹配第一条规则的
                                <em>head</em> 部分：
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">match</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">child</span> <span class="nv">?y</span> <span class="nv">?x</span><span class="p">)</span>
         <span class="o">&#39;</span><span class="p">(</span><span class="nv">child</span> <span class="nv">?x</span> <span class="nv">?y</span><span class="p">)</span>
         <span class="o">&#39;</span><span class="p">((</span><span class="nv">?y</span> <span class="o">.</span> <span class="nv">a</span><span class="p">)</span> <span class="p">(</span><span class="nv">?x</span> <span class="o">.</span> <span class="nv">b</span><span class="p">)))</span>
<span class="no">NIL</span>
</pre>
                                </div>
                              </div>
                              <p>为了保证一条规则中的变量只表示规则中各参数之间的关系，我们用 <em>gensyms</em> 来代替规则中的所有变量。这就是 <code
                                  class="docutils literal"><span class="pre">change-vars</span></code> 函数的目的。一个
                                <em>gensym</em> 不可能在另一个规则中作为变量出现。但是因为规则可以是递归的，我们必须防止出现一个规则和自身冲突的可能性，所以在定义和使用一个规则时都要调用
                                <code class="docutils literal"><span class="pre">chabge-vars</span></code> 函数。
                              </p>
                              <p>现在只剩下定义用以证明复杂表达式的函数了。下面就是需要的函数：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">prove-and</span> <span class="p">(</span><span class="nv">clauses</span> <span class="nv">binds</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">null</span> <span class="nv">clauses</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">list</span> <span class="nv">binds</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">mapcan</span> <span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">b</span><span class="p">)</span>
                  <span class="p">(</span><span class="nv">prove</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">clauses</span><span class="p">)</span> <span class="nv">b</span><span class="p">))</span>
              <span class="p">(</span><span class="nv">prove-and</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">clauses</span><span class="p">)</span> <span class="nv">binds</span><span class="p">))))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">prove-or</span> <span class="p">(</span><span class="nv">clauses</span> <span class="nv">binds</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">mapcan</span> <span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">c</span><span class="p">)</span> <span class="p">(</span><span class="nv">prove</span> <span class="nv">c</span> <span class="nv">binds</span><span class="p">))</span>
          <span class="nv">clauses</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">prove-not</span> <span class="p">(</span><span class="nv">clause</span> <span class="nv">binds</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">unless</span> <span class="p">(</span><span class="nv">prove</span> <span class="nv">clause</span> <span class="nv">binds</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">list</span> <span class="nv">binds</span><span class="p">)))</span>
</pre>
                                </div>
                              </div>
                              <p><strong>图 15.4 逻辑操作符 (Logical operators)</strong></p>
                              <p>操作一个 <code class="docutils literal"><span class="pre">or</span></code> 或者 <code
                                  class="docutils literal"><span class="pre">not</span></code> 表达式是非常简单的。操作 <code
                                  class="docutils literal"><span class="pre">or</span></code> 时，我们提取在 <code
                                  class="docutils literal"><span class="pre">or</span></code> 之间的每一个表达式返回的绑定。操作 <code
                                  class="docutils literal"><span class="pre">not</span></code> 时，当且仅当在 <code
                                  class="docutils literal"><span class="pre">not</span></code> 里的表达式产生 <code
                                  class="docutils literal"><span class="pre">none</span></code> 时，返回当前的绑定。</p>
                              <p><code class="docutils literal"><span class="pre">prove-and</span></code>
                                函数稍微复杂一点。它像一个过滤器，它用之后的表达式所建立的每一个绑定来证明第一个表达式。这将导致 <code
                                  class="docutils literal"><span class="pre">and</span></code> 里的表达式以相反的顺序被求值。除非调用 <code
                                  class="docutils literal"><span class="pre">prove</span></code> 中的 <code
                                  class="docutils literal"><span class="pre">prove-and</span></code> 函数则会先逆转它们。</p>
                              <p>现在我们有了一个可以工作的程序，但它不是很友好。必须要解析 <code
                                  class="docutils literal"><span class="pre">prove-and</span></code>
                                返回的绑定列表是令人厌烦的，它们会变得更长随着规则变得更加复杂。下面有一个宏来帮助我们更愉快地使用这个程序：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defmacro</span> <span class="nv">with-answer</span> <span class="p">(</span><span class="nv">query</span> <span class="k">&amp;body</span> <span class="nv">body</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">binds</span> <span class="p">(</span><span class="nb">gensym</span><span class="p">)))</span>
    <span class="o">`</span><span class="p">(</span><span class="nb">dolist</span> <span class="p">(</span><span class="o">,</span><span class="nv">binds</span> <span class="p">(</span><span class="nv">prove</span> <span class="ss">&#39;,query</span><span class="p">))</span>
       <span class="p">(</span><span class="k">let</span> <span class="o">,</span><span class="p">(</span><span class="nb">mapcar</span> <span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">v</span><span class="p">)</span>
                         <span class="o">`</span><span class="p">(</span><span class="o">,</span><span class="nv">v</span> <span class="p">(</span><span class="nv">binding</span> <span class="ss">&#39;,v</span> <span class="o">,</span><span class="nv">binds</span><span class="p">)))</span>
                     <span class="p">(</span><span class="nv">vars-in</span> <span class="nv">query</span><span class="p">))</span>
         <span class="o">,@</span><span class="nv">body</span><span class="p">))))</span>
</pre>
                                </div>
                              </div>
                              <p><strong>图 15.5 介面宏 (Interface macro)</strong></p>
                              <p>它接受一个 <code class="docutils literal"><span class="pre">query</span></code>
                                （不被求值）和若干表达式构成的 <code class="docutils literal"><span class="pre">body</span></code>
                                作为参数，把 <code class="docutils literal"><span class="pre">query</span></code>
                                所生成的每一组绑定的值赋给 <code class="docutils literal"><span class="pre">query</span></code>
                                中对应的模式变量，并计算 <code class="docutils literal"><span class="pre">body</span></code> 。</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">with-answer</span> <span class="p">(</span><span class="nv">parent</span> <span class="nv">?x</span> <span class="nv">?y</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;~A is the parent of ~A.~%&quot;</span> <span class="nv">?x</span> <span class="nv">?y</span><span class="p">))</span>
<span class="nv">DONALD</span> <span class="nv">is</span> <span class="k">the</span> <span class="nv">parent</span> <span class="nv">of</span> <span class="nv">NANCY.</span>
<span class="no">NIL</span>
</pre>
                                </div>
                              </div>
                              <p>这个宏帮我们做了解析绑定的工作，同时为我们在程序中使用 <code
                                  class="docutils literal"><span class="pre">prove</span></code> 提供了一个便捷的方法。下面是这个宏展开的情况：
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nv">with-answer</span> <span class="p">(</span><span class="nv">p</span> <span class="nv">?x</span> <span class="nv">?y</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">f</span> <span class="nv">?x</span> <span class="nv">?y</span><span class="p">))</span>

<span class="c1">;;将被展开成下面的代码</span>

<span class="p">(</span><span class="nb">dolist</span> <span class="p">(</span><span class="ss">#:g1</span> <span class="p">(</span><span class="nv">prove</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">p</span> <span class="nv">?x</span> <span class="nv">?y</span><span class="p">)))</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">?x</span> <span class="p">(</span><span class="nv">binding</span> <span class="ss">&#39;?x</span> <span class="ss">#:g1</span><span class="p">))</span>
        <span class="p">(</span><span class="nv">?y</span> <span class="p">(</span><span class="nv">binding</span> <span class="ss">&#39;?y</span> <span class="ss">#:g1</span><span class="p">)))</span>
    <span class="p">(</span><span class="nv">f</span> <span class="nv">?x</span> <span class="nv">?y</span><span class="p">)))</span>
</pre>
                                </div>
                              </div>
                              <p><strong>图 15.6: with-answer 调用的展开式</strong></p>
                              <p>下面是使用它的一个例子：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nv">&lt;-</span> <span class="p">(</span><span class="nv">parent</span> <span class="nv">donald</span> <span class="nv">nancy</span><span class="p">))</span>
<span class="p">(</span><span class="nv">&lt;-</span> <span class="p">(</span><span class="nv">parent</span> <span class="nv">donald</span> <span class="nv">debbie</span><span class="p">))</span>
<span class="p">(</span><span class="nv">&lt;-</span> <span class="p">(</span><span class="nv">male</span> <span class="nv">donald</span><span class="p">))</span>
<span class="p">(</span><span class="nv">&lt;-</span> <span class="p">(</span><span class="nv">father</span> <span class="nv">?x</span> <span class="nv">?y</span><span class="p">)</span> <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nv">parent</span> <span class="nv">?x</span> <span class="nv">?y</span><span class="p">)</span> <span class="p">(</span><span class="nv">male</span> <span class="nv">?x</span><span class="p">)))</span>
<span class="p">(</span><span class="nv">&lt;-</span> <span class="p">(</span><span class="nb">=</span> <span class="nv">?x</span> <span class="nv">?y</span><span class="p">))</span>
<span class="p">(</span><span class="nv">&lt;-</span> <span class="p">(</span><span class="nv">sibling</span> <span class="nv">?x</span> <span class="nv">?y</span><span class="p">)</span> <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nv">parent</span> <span class="nv">?z</span> <span class="nv">?x</span><span class="p">)</span>
                         <span class="p">(</span><span class="nv">parent</span> <span class="nv">?z</span> <span class="nv">?y</span><span class="p">)</span>
                         <span class="p">(</span><span class="nb">not</span> <span class="p">(</span><span class="nb">=</span> <span class="nv">?x</span> <span class="nv">?y</span><span class="p">))))</span>

<span class="c1">;;我们可以像下面这样做出推论</span>

<span class="nb">&gt;</span> <span class="p">(</span><span class="nv">with-answer</span> <span class="p">(</span><span class="nv">father</span> <span class="nv">?x</span> <span class="nv">?y</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;~A is the father of ~A.~%&quot;</span> <span class="nv">?x</span> <span class="nv">?y</span><span class="p">))</span>
<span class="nv">DONALD</span> <span class="nv">is</span> <span class="k">the</span> <span class="nv">father</span> <span class="nv">of</span> <span class="nv">DEBBIE.</span>
<span class="nv">DONALD</span> <span class="nv">is</span> <span class="k">the</span> <span class="nv">father</span> <span class="nv">of</span> <span class="nv">NANCY.</span>
<span class="no">NIL</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="nv">with-answer</span> <span class="p">(</span><span class="nv">sibling</span> <span class="nv">?x</span> <span class="nv">?y</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;~A is the sibling of ~A.~%&quot;</span> <span class="nv">?x</span> <span class="nv">?y</span><span class="p">))</span>
<span class="nv">DEBBLE</span> <span class="nv">is</span> <span class="k">the</span> <span class="nv">sibling</span> <span class="nv">of</span> <span class="nv">NANCY.</span>
<span class="nv">NANCY</span> <span class="nv">is</span> <span class="k">the</span>  <span class="nv">sibling</span> <span class="nv">of</span> <span class="nv">DEBBIE.</span>
<span class="no">NIL</span>
</pre>
                                </div>
                              </div>
                              <p><strong>图 15.7: 使用中的程序</strong></p>
                            </div>
                            <div class="section" id="analysis">
                              <h4>15.4 分析 (Analysis)<a class="headerlink" href="#analysis"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>看上去，我们在这一章中写的代码，是用简单自然的方式去实现这样一个程序。事实上，它的效率非常差。我们在这里是其实是做了一个解释器。我们能够把这个程序做得像一个编译器。</p>
                              <p>这里做一个简单的描述。基本的思想是把整个程序打包到两个宏 <code
                                  class="docutils literal"><span class="pre">&lt;-</span></code> 和 <code
                                  class="docutils literal"><span class="pre">with-answer</span></code>
                                ，把已有程序中在<em>运行期</em>做的多数工作搬到<em>宏展开期</em>（在 10.7 节的 <code
                                  class="docutils literal"><span class="pre">avg</span></code> 可以看到这种构思的雏形)
                                用函数取代列表来表示规则，我们不在运行时用 <code
                                  class="docutils literal"><span class="pre">prove</span></code> 和 <code
                                  class="docutils literal"><span class="pre">prove-and</span></code>
                                这样的函数来解释表达式，而是用相应的函数把表达式转化成代码。当一个规则被定义的时候就有表达式可用。为什么要等到使用的时候才去分析它呢？这同样适用于和 <code
                                  class="docutils literal"><span class="pre">&lt;-</span></code> 调用了相同的函数来进行宏展开的 <code
                                  class="docutils literal"><span class="pre">with-answer</span></code> 。</p>
                              <p>听上去好像比我们已经写的这个程序复杂很多，但其实可能只是长了两三倍。想要学习这种技术的读者可以看 <em>On Lisp</em> 或者 <em>Paradigms of
                                  Artificial Intelligence Programming</em> ，这两本书有一些使用这种风格写的示例程序。</p>
                            </div>
                          </div>
                          <div class="section" id="html">
                            <h3 id="16">第十六章：示例：生成 HTML<a class="headerlink" href="#html"
                                title="Permalink to this headline">¶</a></h3>
                            <p>本章的目标是完成一个简单的 HTML 生成器 —— 这个程序可以自动生成一系列包含超文本链接的网页。除了介绍特定 Lisp
                              技术之外，本章还是一个典型的自底向上编程（bottom-up programming）的例子。
                              我们以一些通用 HTML 实用函数作为开始，继而将这些例程看作是一门编程语言，从而更好地编写这个生成器。</p>
                            <div class="section">
                              <h4>16.1 超文本标记语言 (HTML)<a class="headerlink" href="#id1"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>HTML （HyperText Markup Language，超文本标记语言）用于构建网页，是一种简单、易学的语言。本节就对这种语言作概括性介绍。</p>
                              <p>当你使用<em>网页浏览器</em>阅览网页时，浏览器从远程服务器获取 HTML 文件，并将它们显示在你的屏幕上。每个 HTML
                                文件都包含任意多个<em>标签</em>（tag），这些标签相当于发送给浏览器的指令。</p>
                              <div class="figure">
                                <img alt="_images/Figure-16.1.png" src="_images/Figure-16.1.png" />
                              </div>
                              <p><strong>图 16.1 一个 HTML 文件</strong></p>
                              <p>图 16.1 给出了一个简单的 HTML 文件，图 16.2 展示了这个 HTML 文件在浏览器里显示时大概是什么样子。</p>
                              <div class="figure">
                                <img alt="_images/Figure-16.2.png" src="_images/Figure-16.2.png" />
                              </div>
                              <p><strong>图 16.2 一个网页</strong></p>
                              <p>注意在尖角括号之间的文本并没有被显示出来，这些用尖角括号包围的文本就是标签。
                                HTML 的标签分为两种，一种是成双成对地出现的：</p>
                              <div class="highlight-html">
                                <div class="highlight">
                                  <pre><span class="nt">&lt;tag&gt;</span>...<span class="nt">&lt;/tag&gt;</span>
</pre>
                                </div>
                              </div>
                              <p>第一个标签标志着某种情景（environment）的开始，而第二个标签标志着这种情景的结束。
                                这种标签的一个例子是 <code class="docutils literal"><span class="pre">&lt;h2&gt;</span></code>
                                ：所有被 <code class="docutils literal"><span class="pre">&lt;h2&gt;</span></code> 和 <code
                                  class="docutils literal"><span class="pre">&lt;/h2&gt;</span></code>
                                包围的文本，都会使用比平常字体尺寸稍大的字体来显示。</p>
                              <p>另外一些成双成对出现的标签包括：创建带编号列表的 <code
                                  class="docutils literal"><span class="pre">&lt;ol&gt;</span></code> 标签（ol 代表 ordered
                                list，有序表），令文本居中的 <code
                                  class="docutils literal"><span class="pre">&lt;center&gt;</span></code> 标签，以及创建链接的
                                <code class="docutils literal"><span class="pre">&lt;a&gt;</span></code> 标签（a 代表
                                anchor，锚点）。
                              </p>
                              <p>被 <code class="docutils literal"><span class="pre">&lt;a&gt;</span></code> 和 <code
                                  class="docutils literal"><span class="pre">&lt;/a&gt;</span></code>
                                包围的文本就是超文本（hypertext）。
                                在大多数浏览器上，超文本都会以一种与众不同的方式被凸显出来 —— 它们通常会带有下划线 —— 并且点击这些文本会让浏览器跳转到另一个页面。
                                在标签 <code class="docutils literal"><span class="pre">a</span></code>
                                之后的部分，指示了链接被点击时，浏览器应该跳转到的位置。</p>
                              <p>一个像</p>
                              <div class="highlight-html">
                                <div class="highlight">
                                  <pre><span class="nt">&lt;a</span> <span class="na">href=</span><span class="s">&quot;foo.html&quot;</span><span class="nt">&gt;</span>
</pre>
                                </div>
                              </div>
                              <p>这样的标签，就标识了一个指向另一个 HTML 文件的链接，其中这个 HTML 文件和当前网页的文件夹相同。
                                当点击这个链接时，浏览器就会获取并显示 <code
                                  class="docutils literal"><span class="pre">foo.html</span></code> 这个文件。</p>
                              <p>当然，链接并不一定都要指向相同文件夹下的 HTML 文件，实际上，一个链接可以指向互联网的任何一个文件。</p>
                              <p>和成双成对出现的标签相反，另一种标签没有结束标记。
                                在图 16.1 里有一些这样的标签，包括：创建一个新文本行的 <code
                                  class="docutils literal"><span class="pre">&lt;br&gt;</span></code> 标签（br 代表 break
                                ，断行），以及在列表情景中，创建一个新列表项的 <code
                                  class="docutils literal"><span class="pre">&lt;li&gt;</span></code> 标签（li 代表 list item
                                ，列表项）。</p>
                              <p>HTML 还有不少其他的标签，但是本章要用到的标签，基本都包含在图 16.1 里了。</p>
                            </div>
                            <div class="section" id="html-html-utilities">
                              <h4>16.2 HTML 实用函数 (HTML Utilities)<a class="headerlink" href="#html-html-utilities"
                                  title="Permalink to this headline">¶</a></h4>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defmacro</span> <span class="nv">as</span> <span class="p">(</span><span class="nv">tag</span> <span class="nv">content</span><span class="p">)</span>
  <span class="o">`</span><span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;&lt;~(~A~)&gt;~A&lt;/~(~A~)&gt;&quot;</span>
           <span class="ss">&#39;,tag</span> <span class="o">,</span><span class="nv">content</span> <span class="ss">&#39;,tag</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defmacro</span> <span class="nv">with</span> <span class="p">(</span><span class="nv">tag</span> <span class="k">&amp;rest</span> <span class="nv">body</span><span class="p">)</span>
  <span class="o">`</span><span class="p">(</span><span class="k">progn</span>
     <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;~&amp;&lt;~(~A~)&gt;~%&quot;</span> <span class="ss">&#39;,tag</span><span class="p">)</span>
     <span class="o">,@</span><span class="nv">body</span>
     <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;~&amp;&lt;/~(~A~)&gt;~%&quot;</span> <span class="ss">&#39;,tag</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defmacro</span> <span class="nv">brs</span> <span class="p">(</span><span class="k">&amp;optional</span> <span class="p">(</span><span class="nv">n</span> <span class="mi">1</span><span class="p">))</span>
  <span class="p">(</span><span class="nb">fresh-line</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">dotimes</span> <span class="p">(</span><span class="nv">i</span> <span class="nv">n</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">princ</span> <span class="s">&quot;&lt;br&gt;&quot;</span><span class="p">))</span>
  <span class="p">(</span><span class="nb">terpri</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p><strong>图 16.3 标签生成例程</strong></p>
                              <p>本节会定义一些生成 HTML 的例程。
                                图 16.3 包含了三个基本的、生成标签的例程。
                                所有例程都将它们的输出发送到 <code
                                  class="docutils literal"><span class="pre">*standard-output*</span></code>
                                ；可以通过重新绑定这个变量，将输出重定向到一个文件。</p>
                              <p>宏 <code class="docutils literal"><span class="pre">as</span></code> 和 <code
                                  class="docutils literal"><span class="pre">with</span></code> 都用于在标签之间生成表达式。其中 <code
                                  class="docutils literal"><span class="pre">as</span></code> 接受一个字符串，并将它打印在两个标签之间：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">as</span> <span class="nv">center</span> <span class="s">&quot;The Missing Lambda&quot;</span><span class="p">)</span>
<span class="nv">&lt;center&gt;The</span> <span class="nv">Missing</span> <span class="nv">Lambda&lt;/center&gt;</span>
<span class="no">NIL</span>
</pre>
                                </div>
                              </div>
                              <p><code class="docutils literal"><span class="pre">with</span></code> 则接受一个代码体（body of
                                code），并将它放置在两个标签之间：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">with</span> <span class="nv">center</span>
    <span class="p">(</span><span class="nb">princ</span> <span class="s">&quot;The Unbalanced Parenthesis&quot;</span><span class="p">))</span>
<span class="nv">&lt;center&gt;</span>
<span class="nv">The</span> <span class="nv">Unbalanced</span> <span class="nv">Parenthesis</span>
<span class="nv">&lt;/center&gt;</span>
<span class="no">NIL</span>
</pre>
                                </div>
                              </div>
                              <p>两个宏都使用了 <code class="docutils literal"><span class="pre">~(...~)</span></code>
                                来进行格式化，从而将标签转化为小写字母的标签。
                                HTML 并不介意标签是大写还是小写，但是在包含许许多多标签的 HTML 文件中，小写字母的标签可读性更好一些。</p>
                              <p>除此之外， <code class="docutils literal"><span class="pre">as</span></code>
                                倾向于将所有输出都放在同一行，而 <code class="docutils literal"><span class="pre">with</span></code>
                                则将标签和内容都放在不同的行里。
                                （使用 <code class="docutils literal"><span class="pre">~&amp;</span></code>
                                来进行格式化，以确保输出从一个新行中开始。）
                                以上这些工作都只是为了让 HTML 更具可读性，实际上，标签之外的空白并不影响页面的显示方式。</p>
                              <p>图 16.3 中的最后一个例程 <code class="docutils literal"><span class="pre">brs</span></code>
                                用于创建多个文本行。
                                在很多浏览器中，这个例程都可以用于控制垂直间距。</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">html-file</span> <span class="p">(</span><span class="nv">base</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">format</span> <span class="no">nil</span> <span class="s">&quot;~(~A~).html&quot;</span> <span class="nv">base</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defmacro</span> <span class="nv">page</span> <span class="p">(</span><span class="nv">name</span> <span class="nv">title</span> <span class="k">&amp;rest</span> <span class="nv">body</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">ti</span> <span class="p">(</span><span class="nb">gensym</span><span class="p">)))</span>
    <span class="o">`</span><span class="p">(</span><span class="nb">with-open-file</span> <span class="p">(</span><span class="vg">*standard-output*</span>
                      <span class="p">(</span><span class="nv">html-file</span> <span class="o">,</span><span class="nv">name</span><span class="p">)</span>
                      <span class="ss">:direction</span> <span class="ss">:output</span>
                      <span class="ss">:if-exists</span> <span class="ss">:supersede</span><span class="p">)</span>
       <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="o">,</span><span class="nv">ti</span> <span class="o">,</span><span class="nv">title</span><span class="p">))</span>
         <span class="p">(</span><span class="nv">as</span> <span class="nv">title</span> <span class="o">,</span><span class="nv">ti</span><span class="p">)</span>
         <span class="p">(</span><span class="nv">with</span> <span class="nv">center</span>
           <span class="p">(</span><span class="nv">as</span> <span class="nv">h2</span> <span class="p">(</span><span class="nb">string-upcase</span> <span class="o">,</span><span class="nv">ti</span><span class="p">)))</span>
         <span class="p">(</span><span class="nv">brs</span> <span class="mi">3</span><span class="p">)</span>
         <span class="o">,@</span><span class="nv">body</span><span class="p">))))</span>
</pre>
                                </div>
                              </div>
                              <p><strong>图 16.4 HTML 文件生成例程</strong></p>
                              <p>图 16.4 包含用于生成 HTML 文件的例程。
                                第一个函数根据给定的符号（symbol）返回一个文件名。
                                在一个实际应用中，这个函数可能会返回指向某个特定文件夹的路径（path）。
                                目前来说，这个函数只是简单地将 <code class="docutils literal"><span class="pre">.html</span></code>
                                后缀追加到给定符号名的后边。</p>
                              <p>宏 <code class="docutils literal"><span class="pre">page</span></code> 负责生成整个页面，它的实现和
                                <code class="docutils literal"><span class="pre">with-open-file</span></code> 很相似： <code
                                  class="docutils literal"><span class="pre">body</span></code> 中的表达式会被求值，求值的结果通过 <code
                                  class="docutils literal"><span class="pre">*standard-output*</span></code>
                                所绑定的流，最终被写入到相应的 HTML 文件中。
                              </p>
                              <p>6.7 小节展示了如何临时性地绑定一个特殊变量。
                                在 113 页的例子中，我们在 <code class="docutils literal"><span class="pre">let</span></code> 的体内将
                                <code class="docutils literal"><span class="pre">*print-base*</span></code> 绑定为 <code
                                  class="docutils literal"><span class="pre">16</span></code> 。
                                这一次，通过将 <code class="docutils literal"><span class="pre">*standard-output*</span></code>
                                和一个指向 HTML 文件的流绑定，只要我们在 <code
                                  class="docutils literal"><span class="pre">page</span></code> 的函数体内调用 <code
                                  class="docutils literal"><span class="pre">as</span></code> 或者 <code
                                  class="docutils literal"><span class="pre">princ</span></code> ，输出就会被传送到 HTML 文件里。
                              </p>
                              <p><code class="docutils literal"><span class="pre">page</span></code> 宏的输出先在顶部打印 <code
                                  class="docutils literal"><span class="pre">title</span></code> ，接着求值 <code
                                  class="docutils literal"><span class="pre">body</span></code> 中的表达式，打印 <code
                                  class="docutils literal"><span class="pre">body</span></code> 部分的输出。</p>
                              <p>如果我们调用</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nv">page</span> <span class="ss">&#39;paren</span> <span class="s">&quot;The Unbalanced Parenthesis&quot;</span>
  <span class="p">(</span><span class="nb">princ</span> <span class="s">&quot;Something in his expression told her...&quot;</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p>这会产生一个名为 <code class="docutils literal"><span class="pre">paren.html</span></code>
                                的文件（文件名由 <code class="docutils literal"><span class="pre">html-file</span></code>
                                函数生成），文件中的内容为：</p>
                              <div class="highlight-html">
                                <div class="highlight">
                                  <pre><span class="nt">&lt;title&gt;</span>The Unbalanced Parenthesis<span class="nt">&lt;/title&gt;</span>
<span class="nt">&lt;center&gt;</span>
<span class="nt">&lt;h2&gt;</span>THE UNBALANCED PARENTHESIS<span class="nt">&lt;/h2&gt;</span>
<span class="nt">&lt;/center&gt;</span>
<span class="nt">&lt;br&gt;&lt;br&gt;&lt;br&gt;</span>
Something in his expression told her...
</pre>
                                </div>
                              </div>
                              <p>除了 <code class="docutils literal"><span class="pre">title</span></code> 标签以外，以上输出的所有
                                HTML 标签在前面已经见到过了。
                                被 <code class="docutils literal"><span class="pre">&lt;title&gt;</span></code>
                                标签包围的文本并不显示在网页之内，它们会显示在浏览器窗口，用作页面的标题。</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defmacro</span> <span class="nv">with-link</span> <span class="p">(</span><span class="nv">dest</span> <span class="k">&amp;rest</span> <span class="nv">body</span><span class="p">)</span>
  <span class="o">`</span><span class="p">(</span><span class="k">progn</span>
     <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;&lt;a href=\&quot;~A\&quot;&gt;&quot;</span> <span class="p">(</span><span class="nv">html-file</span> <span class="o">,</span><span class="nv">dest</span><span class="p">))</span>
     <span class="o">,@</span><span class="nv">body</span>
     <span class="p">(</span><span class="nb">princ</span> <span class="s">&quot;&lt;/a&gt;&quot;</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">link-item</span> <span class="p">(</span><span class="nv">dest</span> <span class="nv">text</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">princ</span> <span class="s">&quot;&lt;li&gt;&quot;</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">with-link</span> <span class="nv">dest</span>
    <span class="p">(</span><span class="nb">princ</span> <span class="nv">text</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">button</span> <span class="p">(</span><span class="nv">dest</span> <span class="nv">text</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">princ</span> <span class="s">&quot;[ &quot;</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">with-link</span> <span class="nv">dest</span>
    <span class="p">(</span><span class="nb">princ</span> <span class="nv">text</span><span class="p">))</span>
  <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot; ]~%&quot;</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p><strong>图 16.5 生成链接的例程</strong></p>
                              <p>图片 16.5 给出了用于生成链接的例程。
                                <code class="docutils literal"><span class="pre">with-link</span></code> 和 <code
                                  class="docutils literal"><span class="pre">with</span></code> 很相似：它根据给定的地址 <code
                                  class="docutils literal"><span class="pre">dest</span></code> ，创建一个指向 HTML 文件的链接。
                                而链接内部的文本，则通过求值 <code class="docutils literal"><span class="pre">body</span></code>
                                参数中的代码段得出：
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">with-link</span> <span class="ss">&#39;capture</span>
    <span class="p">(</span><span class="nb">princ</span> <span class="s">&quot;The Captured Variable&quot;</span><span class="p">))</span>
<span class="nv">&lt;a</span> <span class="nv">href=</span><span class="s">&quot;capture.html&quot;</span><span class="nv">&gt;The</span> <span class="nv">Captured</span> <span class="nv">Variable&lt;/a&gt;</span>
<span class="s">&quot;&lt;/a&gt;&quot;</span>
</pre>
                                </div>
                              </div>
                              <p><code class="docutils literal"><span class="pre">with-link</span></code> 也被用在 <code
                                  class="docutils literal"><span class="pre">link-item</span></code>
                                当中，这个函数接受一个字符串，并创建一个带链接的列表项：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">link-item</span> <span class="ss">&#39;bq</span> <span class="s">&quot;Backquote!&quot;</span><span class="p">)</span>
<span class="nv">&lt;li&gt;&lt;a</span> <span class="nv">href=</span><span class="s">&quot;bq.html&quot;</span><span class="nv">&gt;Backquote!&lt;/a&gt;</span>
<span class="s">&quot;&lt;/a&gt;&quot;</span>
</pre>
                                </div>
                              </div>
                              <p>最后， <code class="docutils literal"><span class="pre">button</span></code> 也使用了 <code
                                  class="docutils literal"><span class="pre">with-link</span></code> ，从而创建一个被方括号包围的链接：
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">button</span> <span class="ss">&#39;help</span> <span class="s">&quot;Help&quot;</span><span class="p">)</span>
<span class="nv">[</span> <span class="nv">&lt;a</span> <span class="nv">href=</span><span class="s">&quot;help.html&quot;</span><span class="nv">&gt;Help&lt;/a&gt;</span> <span class="nv">]</span>
<span class="no">NIL</span>
</pre>
                                </div>
                              </div>
                            </div>
                            <div class="section" id="an-iteration-utility">
                              <h4>16.3 迭代式实用函数 (An Iteration Utility)<a class="headerlink" href="#an-iteration-utility"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>在这一节，我们先暂停一下编写 HTML 生成器的工作，转到编写迭代式例程的工作上来。</p>
                              <p>你可能会问，怎样才能知道，什么时候应该编写主程序，什么时候又应该编写子例程？</p>
                              <p>实际上，这个问题，没有答案。</p>
                              <p>通常情况下，你总是先开始写一个程序，然后发现需要写一个新的例程，于是你转而去编写新例程，完成它，接着再回过头去编写原来的程序。
                                时间关系，要在这里演示这个开始-完成-又再开始的过程是不太可能的，这里只展示这个迭代式例程的最终形态，需要注意的是，这个程序的编写并不如想象中的那么简单。
                                程序通常需要经历多次重写，才会变得简单。</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">map3</span> <span class="p">(</span><span class="nv">fn</span> <span class="nv">lst</span><span class="p">)</span>
  <span class="p">(</span><span class="k">labels</span> <span class="p">((</span><span class="nv">rec</span> <span class="p">(</span><span class="nv">curr</span> <span class="nv">prev</span> <span class="nv">next</span> <span class="nv">left</span><span class="p">)</span>
             <span class="p">(</span><span class="nb">funcall</span> <span class="nv">fn</span> <span class="nv">curr</span> <span class="nv">prev</span> <span class="nv">next</span><span class="p">)</span>
             <span class="p">(</span><span class="nb">when</span> <span class="nv">left</span>
               <span class="p">(</span><span class="nv">rec</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">left</span><span class="p">)</span>
                    <span class="nv">curr</span>
                    <span class="p">(</span><span class="nb">cadr</span> <span class="nv">left</span><span class="p">)</span>
                    <span class="p">(</span><span class="nb">cdr</span> <span class="nv">left</span><span class="p">)))))</span>
    <span class="p">(</span><span class="nb">when</span> <span class="nv">lst</span>
      <span class="p">(</span><span class="nv">rec</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">lst</span><span class="p">)</span> <span class="no">nil</span> <span class="p">(</span><span class="nb">cadr</span> <span class="nv">lst</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">lst</span><span class="p">)))))</span>
</pre>
                                </div>
                              </div>
                              <p><strong>图 16.6 对树进行迭代</strong></p>
                              <p>图 16.6 里定义的新例程是 <code class="docutils literal"><span class="pre">mapc</span></code>
                                的一个变种。它接受一个函数和一个列表作为参数，对于传入列表中的每个元素，它都会用三个参数来调用传入函数，分别是元素本身，前一个元素，以及后一个元素。（当没有前一个元素或者后一个元素时，使用
                                <code class="docutils literal"><span class="pre">nil</span></code> 代替。）
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">map3</span> <span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="k">&amp;rest</span> <span class="nv">args</span><span class="p">)</span> <span class="p">(</span><span class="nb">princ</span> <span class="nv">args</span><span class="p">))</span>
        <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span><span class="p">))</span>
<span class="p">(</span><span class="nv">A</span> <span class="no">NIL</span> <span class="nv">B</span><span class="p">)</span> <span class="p">(</span><span class="nv">B</span> <span class="nv">A</span> <span class="nv">C</span><span class="p">)</span> <span class="p">(</span><span class="nv">C</span> <span class="nv">B</span> <span class="nv">D</span><span class="p">)</span> <span class="p">(</span><span class="nv">D</span> <span class="nv">C</span> <span class="no">NIL</span><span class="p">)</span>
<span class="no">NIL</span>
</pre>
                                </div>
                              </div>
                              <p>和 <code class="docutils literal"><span class="pre">mapc</span></code> 一样， <code
                                  class="docutils literal"><span class="pre">map3</span></code> 总是返回 <code
                                  class="docutils literal"><span class="pre">nil</span></code>
                                作为函数的返回值。需要这类例程的情况非常多。在下一个小节就会看到，这个例程是如何让每个页面都实现“前进一页”和“后退一页”功能的。</p>
                              <p><code class="docutils literal"><span class="pre">map3</span></code>
                                的一个常见功能是，在列表的两个相邻元素之间进行某些处理：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre>&gt; (map3 #&#39;(lambda (c p n)
            (princ c)
            (if n (princ &quot; | &quot;)))
        &#39;(a b c d))
A | B | C | D
NIL
</pre>
                                </div>
                              </div>
                              <p>程序员经常会遇到上面的这类问题，但只要花些功夫，定义一些例程来处理它们，就能为后续工作节省不少时间。</p>
                            </div>
                            <div class="section" id="generating-pages">
                              <h4>16.4 生成页面 (Generating Pages)<a class="headerlink" href="#generating-pages"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>一本书可以有任意数量的大章，每个大章又有任意数量的小节，而每个小节又有任意数量的分节，整本书的结构呈现出一棵树的形状。</p>
                              <p>尽管网页使用的术语和书本不同，但多个网页同样可以被组织成树状。</p>
                              <p>本节要构建的是这样一个程序，它生成多个网页，这些网页带有以下结构：
                                第一页是一个目录，目录中的链接指向各个<em>节点</em>（section）页面。
                                每个节点包含一些指向<em>项</em>（item）的链接。
                                而一个项就是一个包含纯文本的页面。</p>
                              <p>除了页面本身的链接以外，根据页面在树状结构中的位置，每个页面都会带有前进、后退和向上的链接。
                                其中，前进和后退链接用于在同级（sibling）页面中进行导航。
                                举个例子，点击一个项页面中的前进链接时，如果这个项的同一个节点下还有下一个项，那么就跳到这个新项的页面里。
                                另一方面，向上链接将页面跳转到树形结构的上一层 —— 如果当前页面是项页面，那么返回到节点页面；如果当前页面是节点页面，那么返回到目录页面。
                                最后，还会有索引页面：这个页面包含一系列链接，按字母顺序排列所有项。</p>
                              <div class="figure">
                                <img alt="_images/Figure-16.7.png" src="_images/Figure-16.7.png" />
                              </div>
                              <p><strong>图 16.7 网站的结构</strong></p>
                              <p>图 16.7 展示了生成程序创建的页面所形成的链接结构。</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defparameter</span> <span class="vg">*sections*</span> <span class="no">nil</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defstruct</span> <span class="nv">item</span>
  <span class="nv">id</span> <span class="nv">title</span> <span class="nv">text</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defstruct</span> <span class="nv">section</span>
  <span class="nv">id</span> <span class="nv">title</span> <span class="nv">items</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defmacro</span> <span class="nv">defitem</span> <span class="p">(</span><span class="nv">id</span> <span class="nv">title</span> <span class="nv">text</span><span class="p">)</span>
  <span class="o">`</span><span class="p">(</span><span class="nb">setf</span> <span class="o">,</span><span class="nv">id</span>
         <span class="p">(</span><span class="nv">make-item</span> <span class="ss">:id</span>     <span class="ss">&#39;,id</span>
                    <span class="ss">:title</span>  <span class="o">,</span><span class="nv">title</span>
                    <span class="ss">:text</span>   <span class="o">,</span><span class="nv">text</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defmacro</span> <span class="nv">defsection</span> <span class="p">(</span><span class="nv">id</span> <span class="nv">title</span> <span class="k">&amp;rest</span> <span class="nv">items</span><span class="p">)</span>
  <span class="o">`</span><span class="p">(</span><span class="nb">setf</span> <span class="o">,</span><span class="nv">id</span>
         <span class="p">(</span><span class="nv">make-section</span> <span class="ss">:id</span>    <span class="ss">&#39;,id</span>
                       <span class="ss">:title</span> <span class="o">,</span><span class="nv">title</span>
                       <span class="ss">:items</span> <span class="p">(</span><span class="nb">list</span> <span class="o">,@</span><span class="nv">items</span><span class="p">))))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">defsite</span> <span class="p">(</span><span class="k">&amp;rest</span> <span class="nv">sections</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">setf</span> <span class="vg">*sections*</span> <span class="nv">sections</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p><strong>图 16.8 定义一个网站</strong></p>
                              <p>图 16.8 包含定义页面所需的数据结构。程序需要处理两类对象：项和节点。这两类对象的结构很相似，不过节点包含的是项的列表，而项包含的是文本块。</p>
                              <p>节点和项两类对象都带有 <code class="docutils literal"><span class="pre">id</span></code> 域。
                                标识符（id）被用作符号（symbol），并达到以下两个目的：在 <code
                                  class="docutils literal"><span class="pre">defitem</span></code> 和 <code
                                  class="docutils literal"><span class="pre">defsection</span></code> 的定义中，
                                标识符会被设置到被创建的项或者节点当中，作为我们引用它们的一种手段；另一方面，标识符还会作为相应文件的前缀名（base name），比如说，如果项的标识符为 <code
                                  class="docutils literal"><span class="pre">foo</span></code> ，那么项就会被写到 <code
                                  class="docutils literal"><span class="pre">foo.html</span></code> 文件当中。</p>
                              <p>节点和项也同时带有 <code class="docutils literal"><span class="pre">title</span></code>
                                域。这个域的值应该为字符串，并且被用作相应页面的标题。</p>
                              <p>在节点里，项的排列顺序由传给 <code
                                  class="docutils literal"><span class="pre">defsection</span></code> 的参数决定。
                                与此类似，在目录里，节点的排列顺序由传给 <code
                                  class="docutils literal"><span class="pre">defsite</span></code> 的参数决定。</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defconstant</span> <span class="nv">contents</span> <span class="s">&quot;contents&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="nb">defconstant</span> <span class="nv">index</span>    <span class="s">&quot;index&quot;</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">gen-contents</span> <span class="p">(</span><span class="k">&amp;optional</span> <span class="p">(</span><span class="nv">sections</span> <span class="vg">*sections*</span><span class="p">))</span>
  <span class="p">(</span><span class="nv">page</span> <span class="nv">contents</span> <span class="nv">contents</span>
    <span class="p">(</span><span class="nv">with</span> <span class="nv">ol</span>
      <span class="p">(</span><span class="nb">dolist</span> <span class="p">(</span><span class="nv">s</span> <span class="nv">sections</span><span class="p">)</span>
        <span class="p">(</span><span class="nv">link-item</span> <span class="p">(</span><span class="nv">section-id</span> <span class="nv">s</span><span class="p">)</span> <span class="p">(</span><span class="nv">section-title</span> <span class="nv">s</span><span class="p">))</span>
        <span class="p">(</span><span class="nv">brs</span> <span class="mi">2</span><span class="p">))</span>
      <span class="p">(</span><span class="nv">link-item</span> <span class="nv">index</span> <span class="p">(</span><span class="nb">string-capitalize</span> <span class="nv">index</span><span class="p">)))))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">gen-index</span> <span class="p">(</span><span class="k">&amp;optional</span> <span class="p">(</span><span class="nv">sections</span> <span class="vg">*sections*</span><span class="p">))</span>
  <span class="p">(</span><span class="nv">page</span> <span class="nv">index</span> <span class="nv">index</span>
    <span class="p">(</span><span class="nv">with</span> <span class="nv">ol</span>
      <span class="p">(</span><span class="nb">dolist</span> <span class="p">(</span><span class="nv">i</span> <span class="p">(</span><span class="nv">all-items</span> <span class="nv">sections</span><span class="p">))</span>
        <span class="p">(</span><span class="nv">link-item</span> <span class="p">(</span><span class="nv">item-id</span> <span class="nv">i</span><span class="p">)</span> <span class="p">(</span><span class="nv">item-title</span> <span class="nv">i</span><span class="p">))</span>
        <span class="p">(</span><span class="nv">brs</span> <span class="mi">2</span><span class="p">)))))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">all-items</span> <span class="p">(</span><span class="nv">sections</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">is</span> <span class="no">nil</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">dolist</span> <span class="p">(</span><span class="nv">s</span> <span class="nv">sections</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">dolist</span> <span class="p">(</span><span class="nv">i</span> <span class="p">(</span><span class="nv">section-items</span> <span class="nv">s</span><span class="p">))</span>
        <span class="p">(</span><span class="nb">setf</span> <span class="nv">is</span> <span class="p">(</span><span class="nb">merge</span> <span class="ss">&#39;list</span> <span class="p">(</span><span class="nb">list</span> <span class="nv">i</span><span class="p">)</span> <span class="nv">is</span> <span class="nf">#&#39;</span><span class="nv">title&lt;</span><span class="p">))))</span>
    <span class="nv">is</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">title&lt;</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">string-lessp</span> <span class="p">(</span><span class="nv">item-title</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nv">item-title</span> <span class="nv">y</span><span class="p">)))</span>
</pre>
                                </div>
                              </div>
                              <p><strong>图 16.9 生成索引和目录</strong></p>
                              <p>图 16.9 包含的函数用于生成索引和目录。
                                常量 <code class="docutils literal"><span class="pre">contents</span></code> 和 <code
                                  class="docutils literal"><span class="pre">index</span></code> 都是字符串，它们分别用作 <code
                                  class="docutils literal"><span class="pre">contents</span></code> 页面的标题和 <code
                                  class="docutils literal"><span class="pre">index</span></code>
                                页面的标题；另一方面，如果有其他页面包含了目录和索引这两个页面，那么这两个常量也会作为这些页面文件的前缀名。</p>
                              <p>函数 <code class="docutils literal"><span class="pre">gen-contents</span></code> 和 <code
                                  class="docutils literal"><span class="pre">gen-index</span></code> 非常相似。
                                它们都打开一个 HTML 文件，生成标题和链接列表。
                                不同的地方是，索引页面的项必须是有序的。
                                有序列表通过 <code class="docutils literal"><span class="pre">all-items</span></code>
                                函数生成，它遍历各个项并将它加入到保存已知项的列表当中，并使用 <code
                                  class="docutils literal"><span class="pre">title&lt;</span></code> 函数作为排序函数。
                                注意，因为 <code class="docutils literal"><span class="pre">title&lt;</span></code>
                                函数对大小写敏感，所以在对比标题前，输入必须先经过 <code
                                  class="docutils literal"><span class="pre">string-lessp</span></code> 处理，从而忽略大小写区别。
                              </p>
                              <p>实际程序中的对比操作通常更复杂一些。举个例子，它们需要忽略无意义的句首词汇，比如 <code
                                  class="docutils literal"><span class="pre">&quot;a&quot;</span></code> 和 <code
                                  class="docutils literal"><span class="pre">&quot;the&quot;</span></code> 。</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">gen-site</span> <span class="p">()</span>
  <span class="p">(</span><span class="nv">map3</span> <span class="nf">#&#39;</span><span class="nv">gen-section</span> <span class="vg">*sections*</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">gen-contents</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">gen-index</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">gen-section</span> <span class="p">(</span><span class="nv">sect</span> <span class="nv">&lt;sect</span> <span class="nv">sect&gt;</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">page</span> <span class="p">(</span><span class="nv">section-id</span> <span class="nv">sect</span><span class="p">)</span> <span class="p">(</span><span class="nv">section-title</span> <span class="nv">sect</span><span class="p">)</span>
    <span class="p">(</span><span class="nv">with</span> <span class="nv">ol</span>
      <span class="p">(</span><span class="nv">map3</span> <span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">item</span> <span class="nv">&lt;item</span> <span class="nv">item&gt;</span><span class="p">)</span>
                <span class="p">(</span><span class="nv">link-item</span> <span class="p">(</span><span class="nv">item-id</span> <span class="nv">item</span><span class="p">)</span>
                           <span class="p">(</span><span class="nv">item-title</span> <span class="nv">item</span><span class="p">))</span>
                <span class="p">(</span><span class="nv">brs</span> <span class="mi">2</span><span class="p">)</span>
                <span class="p">(</span><span class="nv">gen-item</span> <span class="nv">sect</span> <span class="nv">item</span> <span class="nv">&lt;item</span> <span class="nv">item&gt;</span><span class="p">))</span>
            <span class="p">(</span><span class="nv">section-items</span> <span class="nv">sect</span><span class="p">)))</span>
    <span class="p">(</span><span class="nv">brs</span> <span class="mi">3</span><span class="p">)</span>
    <span class="p">(</span><span class="nv">gen-move-buttons</span> <span class="p">(</span><span class="k">if</span> <span class="nv">&lt;sect</span> <span class="p">(</span><span class="nv">section-id</span> <span class="nv">&lt;sect</span><span class="p">))</span>
                      <span class="nv">contents</span>
                      <span class="p">(</span><span class="k">if</span> <span class="nv">sect&gt;</span> <span class="p">(</span><span class="nv">section-id</span> <span class="nv">sect&gt;</span><span class="p">)))))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">gen-item</span> <span class="p">(</span><span class="nv">sect</span> <span class="nv">item</span> <span class="nv">&lt;item</span> <span class="nv">item&gt;</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">page</span> <span class="p">(</span><span class="nv">item-id</span> <span class="nv">item</span><span class="p">)</span> <span class="p">(</span><span class="nv">item-title</span> <span class="nv">item</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">princ</span> <span class="p">(</span><span class="nv">item-text</span> <span class="nv">item</span><span class="p">))</span>
    <span class="p">(</span><span class="nv">brs</span> <span class="mi">3</span><span class="p">)</span>
    <span class="p">(</span><span class="nv">gen-move-buttons</span> <span class="p">(</span><span class="k">if</span> <span class="nv">&lt;item</span> <span class="p">(</span><span class="nv">item-id</span> <span class="nv">&lt;item</span><span class="p">))</span>
                      <span class="p">(</span><span class="nv">section-id</span> <span class="nv">sect</span><span class="p">)</span>
                      <span class="p">(</span><span class="k">if</span> <span class="nv">item&gt;</span> <span class="p">(</span><span class="nv">item-id</span> <span class="nv">item&gt;</span><span class="p">)))))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">gen-move-buttons</span> <span class="p">(</span><span class="nv">back</span> <span class="nv">up</span> <span class="nv">forward</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="nv">back</span> <span class="p">(</span><span class="nv">button</span> <span class="nv">back</span> <span class="s">&quot;Back&quot;</span><span class="p">))</span>
  <span class="p">(</span><span class="k">if</span> <span class="nv">up</span> <span class="p">(</span><span class="nv">button</span> <span class="nv">up</span> <span class="s">&quot;Up&quot;</span><span class="p">))</span>
  <span class="p">(</span><span class="k">if</span> <span class="nv">forward</span> <span class="p">(</span><span class="nv">button</span> <span class="nv">forward</span> <span class="s">&quot;Forward&quot;</span><span class="p">)))</span>
</pre>
                                </div>
                              </div>
                              <p><strong>图 16.10 生成网站、节点和项</strong></p>
                              <p>图 16.10 包含其余的代码： <code
                                  class="docutils literal"><span class="pre">gen-site</span></code>
                                生成整个页面集合，并调用相应的函数，生成节点和项。</p>
                              <p>所有页面的集合包括目录、索引、各个节点以及各个项的页面。
                                目录和索引的生成由图 16.9 中的代码完成。
                                节点和项由分别由生成节点页面的 <code
                                  class="docutils literal"><span class="pre">gen-section</span></code> 和生成项页面的 <code
                                  class="docutils literal"><span class="pre">gen-item</span></code> 完成。</p>
                              <p>这两个函数的开头和结尾非常相似。
                                它们都接受一个对象、对象的左兄弟、对象的右兄弟作为参数；它们都从对象的 <code
                                  class="docutils literal"><span class="pre">title</span></code> 域中提取标题内容；它们都以调用 <code
                                  class="docutils literal"><span class="pre">gen-move-buttons</span></code> 作为结束，其中
                                <code class="docutils literal"><span class="pre">gen-move-buttons</span></code>
                                创建指向左兄弟的后退按钮、指向右兄弟的前进按钮和指向双亲（parent）对象的向上按钮。
                                它们的不同在于函数体的中间部分： <code
                                  class="docutils literal"><span class="pre">gen-section</span></code>
                                创建有序列表，列表中的链接指向节点包含的项，而 <code
                                  class="docutils literal"><span class="pre">gen-item</span></code> 创建的项则链接到相应的文本页面。
                              </p>
                              <p>项所包含的内容完全由用户决定。
                                比如说，将 HTML 标签作为内容也是完全没问题的。
                                项的文本当然也可以由其他程序来生成。</p>
                              <p>图 16.11 演示了如何手工地定义一个微型网页。
                                在这个例子中，列出的项都是 Fortune 饼干公司新推出的产品。</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nv">defitem</span> <span class="nv">des</span> <span class="s">&quot;Fortune Cookies: Dessert or Fraud?&quot;</span> <span class="s">&quot;...&quot;</span><span class="p">)</span>

<span class="p">(</span><span class="nv">defitem</span> <span class="nb">case</span> <span class="s">&quot;The Case for Pessimism&quot;</span> <span class="s">&quot;...&quot;</span><span class="p">)</span>

<span class="p">(</span><span class="nv">defsection</span> <span class="nb">position</span> <span class="s">&quot;Position Papers&quot;</span> <span class="nv">des</span> <span class="nb">case</span><span class="p">)</span>

<span class="p">(</span><span class="nv">defitem</span> <span class="nv">luck</span> <span class="s">&quot;Distribution of Bad Luck&quot;</span> <span class="s">&quot;...&quot;</span><span class="p">)</span>

<span class="p">(</span><span class="nv">defitem</span> <span class="nv">haz</span> <span class="s">&quot;Health Hazards of Optimism&quot;</span> <span class="s">&quot;...&quot;</span><span class="p">)</span>

<span class="p">(</span><span class="nv">defsection</span> <span class="nv">abstract</span> <span class="s">&quot;Research Abstracts&quot;</span> <span class="nv">luck</span> <span class="nv">haz</span><span class="p">)</span>

<span class="p">(</span><span class="nv">defsite</span> <span class="nb">position</span> <span class="nv">abstract</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p><strong>图 16.11 一个微型网站</strong></p>
                            </div>
                          </div>
                          <div class="section">
                            <h3 id="17">第十七章：示例：对象
                            </h3>
                            <p>在本章里，我们将使用 Lisp 来自己实现面向对象语言。这样子的程序称为嵌入式语言 (<em>embedded language</em>)。嵌入一个面向对象语言到 Lisp
                              里是一个绝佳的例子。同時作为一个 Lisp 的典型用途，並演示了面向对象的抽象是如何多自然地在 Lisp 基本的抽象上构建出来。</p>
                            <div class="section" id="inheritance">
                              <h4>17.1 继承 (Inheritance)<a class="headerlink" href="#inheritance"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>11.10 小节解释过通用函数与消息传递的差别。</p>
                              <p>在消息传递模型里，</p>
                              <ol class="arabic simple">
                                <li>对象有属性，</li>
                                <li>并回应消息，</li>
                                <li>并从其父类继承属性与方法。</li>
                              </ol>
                              <p>当然了，我们知道 CLOS 使用的是通用函数模型。但本章我们只对于写一个迷你的对象系统 (minimal object system)感兴趣，而不是一个可与 CLOS
                                匹敌的系统，所以我们将使用消息传递模型。</p>
                              <p>我们已经在 Lisp 里看过许多保存属性集合的方法。一种可能的方法是使用哈希表来代表对象，并将属性作为哈希表的条目保存。接著可以通过 <code
                                  class="docutils literal"><span class="pre">gethash</span></code> 来存取每个属性：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">gethash</span> <span class="ss">&#39;color</span> <span class="nv">obj</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>由于函数是数据对象，我们也可以将函数作为属性保存起来。这表示我们也可以有方法；要调用一个对象特定的方法，可以通过 <code
                                  class="docutils literal"><span class="pre">funcall</span></code> 一下哈希表里的同名属性：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">funcall</span> <span class="p">(</span><span class="nb">gethash</span> <span class="ss">&#39;move</span> <span class="nv">obj</span><span class="p">)</span> <span class="nv">obj</span> <span class="mi">10</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>我们可以在这个概念上，定义一个 Smalltalk 风格的消息传递语法，</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">tell</span> <span class="p">(</span><span class="nv">obj</span> <span class="nv">message</span> <span class="k">&amp;rest</span> <span class="nv">args</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">apply</span> <span class="p">(</span><span class="nb">gethash</span> <span class="nv">message</span> <span class="nv">obj</span><span class="p">)</span> <span class="nv">obj</span> <span class="nv">args</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p>所以想要一个对象 <code class="docutils literal"><span class="pre">obj</span></code> 移动 10
                                单位，我们可以说：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nv">tell</span> <span class="nv">obj</span> <span class="ss">&#39;move</span> <span class="mi">10</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>事实上，纯 Lisp 唯一缺少的原料是继承。我们可以通过定义一个递归版本的 <code
                                  class="docutils literal"><span class="pre">gethash</span></code> 来实现一个简单版，如图 17.1
                                。现在仅用共 8 行代码，便实现了面向对象编程的 3 个基本元素。</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">rget</span> <span class="p">(</span><span class="nv">prop</span> <span class="nv">obj</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">multiple-value-bind</span> <span class="p">(</span><span class="nv">val</span> <span class="nv">in</span><span class="p">)</span> <span class="p">(</span><span class="nb">gethash</span> <span class="nv">prop</span> <span class="nv">obj</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if</span> <span class="nv">in</span>
        <span class="p">(</span><span class="nb">values</span> <span class="nv">val</span> <span class="nv">in</span><span class="p">)</span>
        <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">par</span> <span class="p">(</span><span class="nb">gethash</span> <span class="ss">:parent</span> <span class="nv">obj</span><span class="p">)))</span>
          <span class="p">(</span><span class="nb">and</span> <span class="nv">par</span> <span class="p">(</span><span class="nv">rget</span> <span class="nv">prop</span> <span class="nv">par</span><span class="p">))))))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">tell</span> <span class="p">(</span><span class="nv">obj</span> <span class="nv">message</span> <span class="k">&amp;rest</span> <span class="nv">args</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">apply</span> <span class="p">(</span><span class="nv">rget</span> <span class="nv">message</span> <span class="nv">obj</span><span class="p">)</span> <span class="nv">obj</span> <span class="nv">args</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p><strong>图 17.1：继承</strong></p>
                              <p>让我们用这段代码，来试试本来的例子。我们创建两个对象，其中一个对象是另一个的子类：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">setf</span> <span class="nv">circle-class</span> <span class="p">(</span><span class="nb">make-hash-table</span><span class="p">)</span>
        <span class="nv">our-circle</span>   <span class="p">(</span><span class="nb">make-hash-table</span><span class="p">)</span>
        <span class="p">(</span><span class="nb">gethash</span> <span class="ss">:parent</span> <span class="nv">our-circle</span><span class="p">)</span> <span class="nv">circle-class</span>
        <span class="p">(</span><span class="nb">gethash</span> <span class="ss">&#39;radius</span> <span class="nv">our-circle</span><span class="p">)</span> <span class="mi">2</span><span class="p">)</span>
<span class="mi">2</span>
</pre>
                                </div>
                              </div>
                              <p><code class="docutils literal"><span class="pre">circle-class</span></code>
                                对象会持有给所有圆形使用的 <code class="docutils literal"><span class="pre">area</span></code>
                                方法。它是接受一个参数的函数，该参数为传来原始消息的对象：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre>&gt; (setf (gethash &#39;area circle-class)
        #&#39;(lambda (x)
            (* pi (expt (rget &#39;radius x) 2))))
#&lt;Interpreted-Function BF1EF6&gt;
</pre>
                                </div>
                              </div>
                              <p>现在当我们询问 <code class="docutils literal"><span class="pre">our-circle</span></code>
                                的面积时，会根据此类所定义的方法来计算。我们使用 <code
                                  class="docutils literal"><span class="pre">rget</span></code> 来读取一个属性，用 <code
                                  class="docutils literal"><span class="pre">tell</span></code> 来调用一个方法：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">rget</span> <span class="ss">&#39;radius</span> <span class="nv">our-circle</span><span class="p">)</span>
<span class="mi">2</span>
<span class="no">T</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="nv">tell</span> <span class="nv">our-circle</span> <span class="ss">&#39;area</span><span class="p">)</span>
<span class="mf">12.566370614359173</span>
</pre>
                                </div>
                              </div>
                              <p>在开始改善这个程序之前，值得停下来想想我们到底做了什么。仅使用 8 行代码，我们使纯的、旧的、无 CLOS 的 Lisp
                                ，转变成一个面向对象语言。我们是怎么完成这项壮举的？应该用了某种秘诀，才会仅用了 8 行代码，就实现了面向对象编程。</p>
                              <p>的确有一个秘诀存在，但不是编程的奇技淫巧。这个秘诀是，Lisp
                                本来就是一个面向对象的语言了，甚至说，是种更通用的语言。我们需要做的事情，不过就是把本来就存在的抽象，再重新包装一下。</p>
                            </div>
                            <div class="section" id="multiple-inheritance">
                              <h4>17.2 多重继承 (Multiple Inheritance)<a class="headerlink" href="#multiple-inheritance"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>到目前为止我们只有单继承 ── 一个对象只可以有一个父类。但可以通过使 <code
                                  class="docutils literal"><span class="pre">parent</span></code> 属性变成一个列表来获得多重继承，并重新定义
                                <code class="docutils literal"><span class="pre">rget</span></code> ，如图 17.2 所示。
                              </p>
                              <p>
                                在只有单继承的情况下，当我们想要从对象取出某些属性，只需要递归地延著祖先的方向往上找。如果对象本身没有我们想要属性的有关信息，可以检视其父类，以此类推。有了多重继承后，我们仍想要执行同样的搜索，但这件简单的事，却被对象的祖先可形成一个图，而不再是简单的树给复杂化了。不能只使用深度优先来搜索这个图。有多个父类时，可以有如图
                                17.3 所示的层级存在： <code class="docutils literal"><span class="pre">a</span></code> 起源于 <code
                                  class="docutils literal"><span class="pre">b</span></code> 及 <code
                                  class="docutils literal"><span class="pre">c</span></code> ，而他们都是 <code
                                  class="docutils literal"><span class="pre">d</span></code> 的子孙。一个深度优先（或说高度优先）的遍历结果会是
                                <code class="docutils literal"><span class="pre">a</span></code> , <code
                                  class="docutils literal"><span class="pre">b</span></code> , <code
                                  class="docutils literal"><span class="pre">d</span></code>, <code
                                  class="docutils literal"><span class="pre">c</span></code> , <code
                                  class="docutils literal"><span class="pre">d</span></code> 。而如果我们想要的属性在 <code
                                  class="docutils literal"><span class="pre">d</span></code> 与 <code
                                  class="docutils literal"><span class="pre">c</span></code> 都有的话，我们会获得存在 <code
                                  class="docutils literal"><span class="pre">d</span></code> 的值，而不是存在 <code
                                  class="docutils literal"><span class="pre">c</span></code> 的值。这违反了子类可覆写父类提供缺省值的原则。
                              </p>
                              <p>如果我们想要实现普遍的继承概念，就不应该在检查其子孙前，先检查该对象。在这个情况下，适当的搜索顺序会是 <code
                                  class="docutils literal"><span class="pre">a</span></code> , <code
                                  class="docutils literal"><span class="pre">b</span></code> , <code
                                  class="docutils literal"><span class="pre">c</span></code> , <code
                                  class="docutils literal"><span class="pre">d</span></code>
                                。那如何保证搜索总是先搜子孙呢？最简单的方法是用一个对象，以及按正确优先顺序排序的，由祖先所构成的列表。通过调用 <code
                                  class="docutils literal"><span class="pre">traverse</span></code>
                                开始，建构一个列表，表示深度优先遍历所遇到的对象。如果任一个对象有共享的父类，则列表中会有重复元素。如果仅保存最后出现的复本，会获得一般由 CLOS
                                定义的优先级列表。（删除所有除了最后一个之外的复本，根据 183 页所描述的算法，规则三。）Common Lisp 函数 <code
                                  class="docutils literal"><span class="pre">delete-duplicates</span></code>
                                定义成如此作用的，所以我们只要在深度优先的基础上调用它，我们就会得到正确的优先级列表。一旦优先级列表创建完成， <code
                                  class="docutils literal"><span class="pre">rget</span></code> 根据需要的属性搜索第一个符合的对象。</p>
                              <p>我们可以通过利用优先级列表的优点，举例来说，一个爱国的无赖先是一个无赖，然后才是爱国者：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre>&gt; (setf scoundrel           (make-hash-table)
        patriot             (make-hash-table)
        patriotic-scoundrel (make-hash-table)
        (gethash &#39;serves scoundrel) &#39;self
        (gethash &#39;serves patriot) &#39;country
        (gethash :parents patriotic-scoundrel)
                 (list scoundrel patriot))
(#&lt;Hash-Table C41C7E&gt; #&lt;Hash-Table C41F0E&gt;)
&gt; (rget &#39;serves patriotic-scoundrel)
SELF
T
</pre>
                                </div>
                              </div>
                              <p>到目前为止，我们有一个强大的程序，但极其丑陋且低效。在一个 Lisp 程序生命周期的第二阶段，我们将这个初步框架提炼成有用的东西。</p>
                            </div>
                            <div class="section" id="defining-objects">
                              <h4>17.3 定义对象 (Defining Objects)<a class="headerlink" href="#defining-objects"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>
                                第一个我们需要改善的是，写一个用来创建对象的函数。我们程序表示对象以及其父类的方式，不需要给用户知道。如果我们定义一个函数来创建对象，用户将能够一个步骤就创建出一个对象，并指定其父类。我们可以在创建一个对象的同时，顺道构造优先级列表，而不是在每次当我们需要找一个属性或方法时，才花费庞大代价来重新构造。
                              </p>
                              <p>
                                如果我们要维护优先级列表，而不是在要用的时候再构造它们，我们需要处理列表会过时的可能性。我们的策略会是用一个列表来保存所有存在的对象，而无论何时当某些父类被改动时，重新给所有受影响的对象生成优先级列表。这代价是相当昂贵的，但由于查询比重定义父类的可能性来得高许多，我们会省下许多时间。这个改变对我们的程序的灵活性没有任何影响；我们只是将花费从频繁的操作转到不频繁的操作。
                              </p>
                              <p>图 17.4 包含了新的代码。 <a class="reference external"
                                  href="http://acl.readthedocs.org/en/latest/zhCN/notes-cn.html#notes-273">λ</a> 全局的
                                <code class="docutils literal"><span class="pre">*objs*</span></code> 会是一个包含所有当前对象的列表。函数
                                <code class="docutils literal"><span class="pre">parents</span></code> 取出一个对象的父类；相反的
                                <code
                                  class="docutils literal"><span class="pre">(setf</span> <span class="pre">parents)</span></code>
                                不仅配置一个对象的父类，也调用 <code
                                  class="docutils literal"><span class="pre">make-precedence</span></code>
                                来重新构造任何需要变动的优先级列表。这些列表与之前一样，由 <code
                                  class="docutils literal"><span class="pre">precedence</span></code> 来构造。
                              </p>
                              <p>用户现在不用调用 <code class="docutils literal"><span class="pre">make-hash-table</span></code>
                                来创建对象，调用 <code class="docutils literal"><span class="pre">obj</span></code> 来取代， <code
                                  class="docutils literal"><span class="pre">obj</span></code> 一步完成创建一个新对象及定义其父类。我们也重定义了
                                <code class="docutils literal"><span class="pre">rget</span></code> 来利用保存优先级列表的好处。
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defvar</span> <span class="vg">*objs*</span> <span class="no">nil</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">parents</span> <span class="p">(</span><span class="nv">obj</span><span class="p">)</span> <span class="p">(</span><span class="nb">gethash</span> <span class="ss">:parents</span> <span class="nv">obj</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="p">(</span><span class="nb">setf</span> <span class="nv">parents</span><span class="p">)</span> <span class="p">(</span><span class="nv">val</span> <span class="nv">obj</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">prog1</span> <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nb">gethash</span> <span class="ss">:parents</span> <span class="nv">obj</span><span class="p">)</span> <span class="nv">val</span><span class="p">)</span>
         <span class="p">(</span><span class="nv">make-precedence</span> <span class="nv">obj</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">make-precedence</span> <span class="p">(</span><span class="nv">obj</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nb">gethash</span> <span class="ss">:preclist</span> <span class="nv">obj</span><span class="p">)</span> <span class="p">(</span><span class="nv">precedence</span> <span class="nv">obj</span><span class="p">))</span>
  <span class="p">(</span><span class="nb">dolist</span> <span class="p">(</span><span class="nv">x</span> <span class="vg">*objs*</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">member</span> <span class="nv">obj</span> <span class="p">(</span><span class="nb">gethash</span> <span class="ss">:preclist</span> <span class="nv">x</span><span class="p">))</span>
        <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nb">gethash</span> <span class="ss">:preclist</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nv">precedence</span> <span class="nv">x</span><span class="p">)))))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">obj</span> <span class="p">(</span><span class="k">&amp;rest</span> <span class="nv">parents</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">obj</span> <span class="p">(</span><span class="nb">make-hash-table</span><span class="p">)))</span>
    <span class="p">(</span><span class="nb">push</span> <span class="nv">obj</span> <span class="vg">*objs*</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nv">parents</span> <span class="nv">obj</span><span class="p">)</span> <span class="nv">parents</span><span class="p">)</span>
    <span class="nv">obj</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">rget</span> <span class="p">(</span><span class="nv">prop</span> <span class="nv">obj</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">dolist</span> <span class="p">(</span><span class="nv">c</span> <span class="p">(</span><span class="nb">gethash</span> <span class="ss">:preclist</span> <span class="nv">obj</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">multiple-value-bind</span> <span class="p">(</span><span class="nv">val</span> <span class="nv">in</span><span class="p">)</span> <span class="p">(</span><span class="nb">gethash</span> <span class="nv">prop</span> <span class="nv">c</span><span class="p">)</span>
      <span class="p">(</span><span class="k">if</span> <span class="nv">in</span> <span class="p">(</span><span class="nb">return</span> <span class="p">(</span><span class="nb">values</span> <span class="nv">val</span> <span class="nv">in</span><span class="p">))))))</span>
</pre>
                                </div>
                              </div>
                              <p><strong>图 17.4：创建对象</strong></p>
                            </div>
                            <div class="section" id="functional-syntax">
                              <h4>17.4 函数式语法 (Functional Syntax)<a class="headerlink" href="#functional-syntax"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>另一个可以改善的空间是消息调用的语法。 <code class="docutils literal"><span class="pre">tell</span></code>
                                本身是无谓的杂乱不堪，这也使得动词在第三顺位才出现，同时代表著我们的程序不再可以像一般 Lisp 前序表达式那样阅读:</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nv">tell</span> <span class="p">(</span><span class="nv">tell</span> <span class="nv">obj</span> <span class="ss">&#39;find-owner</span><span class="p">)</span> <span class="ss">&#39;find-owner</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>我们可以使用图 17.5 所定义的 <code
                                  class="docutils literal"><span class="pre">defprop</span></code> 宏，通过定义作为函数的属性名称来摆脱这种
                                <code class="docutils literal"><span class="pre">tell</span></code> 语法。若选择性参数 <code
                                  class="docutils literal"><span class="pre">meth?</span></code>
                                为真的话，会将此属性视为方法。不然会将属性视为槽，而由 <code
                                  class="docutils literal"><span class="pre">rget</span></code>
                                所取回的值会直接返回。一旦我们定义了属性作为槽或方法的名字，
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defmacro</span> <span class="nv">defprop</span> <span class="p">(</span><span class="nv">name</span> <span class="k">&amp;optional</span> <span class="nv">meth?</span><span class="p">)</span>
  <span class="o">`</span><span class="p">(</span><span class="k">progn</span>
     <span class="p">(</span><span class="nb">defun</span> <span class="o">,</span><span class="nv">name</span> <span class="p">(</span><span class="nv">obj</span> <span class="k">&amp;rest</span> <span class="nv">args</span><span class="p">)</span>
       <span class="o">,</span><span class="p">(</span><span class="k">if</span> <span class="nv">meth?</span>
          <span class="o">`</span><span class="p">(</span><span class="nv">run-methods</span> <span class="nv">obj</span> <span class="ss">&#39;,name</span> <span class="nv">args</span><span class="p">)</span>
          <span class="o">`</span><span class="p">(</span><span class="nv">rget</span> <span class="ss">&#39;,name</span> <span class="nv">obj</span><span class="p">)))</span>
     <span class="p">(</span><span class="nb">defun</span> <span class="p">(</span><span class="nb">setf</span> <span class="o">,</span><span class="nv">name</span><span class="p">)</span> <span class="p">(</span><span class="nv">val</span> <span class="nv">obj</span><span class="p">)</span>
       <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nb">gethash</span> <span class="ss">&#39;,name</span> <span class="nv">obj</span><span class="p">)</span> <span class="nv">val</span><span class="p">))))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">run-methods</span> <span class="p">(</span><span class="nv">obj</span> <span class="nv">name</span> <span class="nv">args</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">meth</span> <span class="p">(</span><span class="nv">rget</span> <span class="nv">name</span> <span class="nv">obj</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">if</span> <span class="nv">meth</span>
        <span class="p">(</span><span class="nb">apply</span> <span class="nv">meth</span> <span class="nv">obj</span> <span class="nv">args</span><span class="p">)</span>
        <span class="p">(</span><span class="nb">error</span> <span class="s">&quot;No ~A method for ~A.&quot;</span> <span class="nv">name</span> <span class="nv">obj</span><span class="p">))))</span>
</pre>
                                </div>
                              </div>
                              <p><strong>图 17.5: 函数式语法</strong></p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nv">defprop</span> <span class="nv">find-owner</span> <span class="no">t</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>我们就可以在函数调用里引用它，则我们的代码读起来将会再次回到 Lisp 本来那样：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nv">find-owner</span> <span class="p">(</span><span class="nv">find-owner</span> <span class="nv">obj</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p>我们的前一个例子在某种程度上可读性变得更高了：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="k">progn</span>
    <span class="p">(</span><span class="nb">setf</span> <span class="nv">scoundrel</span>           <span class="p">(</span><span class="nv">obj</span><span class="p">)</span>
          <span class="nv">patriot</span>             <span class="p">(</span><span class="nv">obj</span><span class="p">)</span>
          <span class="nv">patriotic-scoundrel</span> <span class="p">(</span><span class="nv">obj</span> <span class="nv">scoundrel</span> <span class="nv">patriot</span><span class="p">))</span>
    <span class="p">(</span><span class="nv">defprop</span> <span class="nv">serves</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nv">serves</span> <span class="nv">scoundrel</span><span class="p">)</span> <span class="ss">&#39;self</span>
          <span class="p">(</span><span class="nv">serves</span> <span class="nv">patriot</span><span class="p">)</span> <span class="ss">&#39;country</span><span class="p">)</span>
    <span class="p">(</span><span class="nv">serves</span> <span class="nv">patriotic-scoundrel</span><span class="p">))</span>
<span class="nv">SELF</span>
<span class="no">T</span>
</pre>
                                </div>
                              </div>
                            </div>
                            <div class="section" id="defining-methods">
                              <h4>17.5 定义方法 (Defining Methods)<a class="headerlink" href="#defining-methods"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>到目前为止，我们借由叙述如下的东西来定义一个方法：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nv">defprop</span> <span class="nv">area</span> <span class="no">t</span><span class="p">)</span>

<span class="p">(</span><span class="nb">setf</span> <span class="nv">circle-class</span> <span class="p">(</span><span class="nv">obj</span><span class="p">))</span>

<span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nv">area</span> <span class="nv">circle-class</span><span class="p">)</span>
      <span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">c</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">pi</span> <span class="p">(</span><span class="nb">expt</span> <span class="p">(</span><span class="nv">radius</span> <span class="nv">c</span><span class="p">)</span> <span class="mi">2</span><span class="p">))))</span>
</pre>
                                </div>
                              </div>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defmacro</span> <span class="nv">defmeth</span> <span class="p">(</span><span class="nv">name</span> <span class="nv">obj</span> <span class="nv">parms</span> <span class="k">&amp;rest</span> <span class="nv">body</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">gobj</span> <span class="p">(</span><span class="nb">gensym</span><span class="p">)))</span>
    <span class="o">`</span><span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="o">,</span><span class="nv">gobj</span> <span class="o">,</span><span class="nv">obj</span><span class="p">))</span>
       <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nb">gethash</span> <span class="ss">&#39;,name</span> <span class="o">,</span><span class="nv">gobj</span><span class="p">)</span>
             <span class="p">(</span><span class="k">labels</span> <span class="p">((</span><span class="nv">next</span> <span class="p">()</span> <span class="p">(</span><span class="nv">get-next</span> <span class="o">,</span><span class="nv">gobj</span> <span class="ss">&#39;,name</span><span class="p">)))</span>
               <span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="o">,</span><span class="nv">parms</span> <span class="o">,@</span><span class="nv">body</span><span class="p">))))))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">get-next</span> <span class="p">(</span><span class="nv">obj</span> <span class="nv">name</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">some</span> <span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">gethash</span> <span class="nv">name</span> <span class="nv">x</span><span class="p">))</span>
        <span class="p">(</span><span class="nb">cdr</span> <span class="p">(</span><span class="nb">gethash</span> <span class="ss">:preclist</span> <span class="nv">obj</span><span class="p">))))</span>
</pre>
                                </div>
                              </div>
                              <p><strong>图 17.6 定义方法。</strong></p>
                              <p>在一个方法里，我们可以通过给对象的 <code
                                  class="docutils literal"><span class="pre">:preclist</span></code> 的 <code
                                  class="docutils literal"><span class="pre">cdr</span></code> 获得如内置 <code
                                  class="docutils literal"><span class="pre">call-next-method</span></code>
                                方法的效果。所以举例来说，若我们想要定义一个特殊的圆形，这个圆形在返回面积的过程中印出某个东西，我们可以说：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">setf</span> <span class="nv">grumpt-circle</span> <span class="p">(</span><span class="nv">obj</span> <span class="nv">circle-class</span><span class="p">))</span>

<span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nv">area</span> <span class="nv">grumpt-circle</span><span class="p">)</span>
      <span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">c</span><span class="p">)</span>
          <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;How dare you stereotype me!~%&quot;</span><span class="p">)</span>
          <span class="p">(</span><span class="nb">funcall</span> <span class="p">(</span><span class="nb">some</span> <span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">gethash</span> <span class="ss">&#39;area</span> <span class="nv">x</span><span class="p">))</span>
                         <span class="p">(</span><span class="nb">cdr</span> <span class="p">(</span><span class="nb">gethash</span> <span class="ss">:preclist</span> <span class="nv">c</span><span class="p">)))</span>
                   <span class="nv">c</span><span class="p">)))</span>
</pre>
                                </div>
                              </div>
                              <p>这里 <code class="docutils literal"><span class="pre">funcall</span></code> 等同于一个 <code
                                  class="docutils literal"><span class="pre">call-next-method</span></code> 调用，但他..</p>
                              <p>图 17.6 的 <code class="docutils literal"><span class="pre">defmeth</span></code>
                                宏提供了一个便捷方式来定义方法，并使得调用下个方法变得简单。一个 <code
                                  class="docutils literal"><span class="pre">defmeth</span></code> 的调用会展开成一个 <code
                                  class="docutils literal"><span class="pre">setf</span></code> 表达式，但 <code
                                  class="docutils literal"><span class="pre">setf</span></code> 在一個 <code
                                  class="docutils literal"><span class="pre">labels</span></code> 表达式里定义了 <code
                                  class="docutils literal"><span class="pre">next</span></code> 作为取出下个方法的函数。这个函数与 <code
                                  class="docutils literal"><span class="pre">next-method-p</span></code> 类似（第 188 页「譯註:
                                11.7 節」），但返回的是我们可以调用的东西，同時作為 <code
                                  class="docutils literal"><span class="pre">call-next-method</span></code> 。 <a
                                  class="reference external"
                                  href="http://acl.readthedocs.org/en/latest/zhCN/notes-cn.html#notes-273">λ</a>
                                前述两个方法可以被定义成：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nv">defmeth</span> <span class="nv">area</span> <span class="nv">circle-class</span> <span class="p">(</span><span class="nv">c</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">*</span> <span class="nv">pi</span> <span class="p">(</span><span class="nb">expt</span> <span class="p">(</span><span class="nv">radius</span> <span class="nv">c</span><span class="p">)</span> <span class="mi">2</span><span class="p">)))</span>

<span class="p">(</span><span class="nv">defmeth</span> <span class="nv">area</span> <span class="nv">grumpy-circle</span> <span class="p">(</span><span class="nv">c</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;How dare you stereotype me!~%&quot;</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">funcall</span> <span class="p">(</span><span class="nv">next</span><span class="p">)</span> <span class="nv">c</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p>顺道一提，注意 <code class="docutils literal"><span class="pre">defmeth</span></code>
                                的定义也利用到了符号捕捉。方法的主体被插入至函数 <code
                                  class="docutils literal"><span class="pre">next</span></code> 是局部定义的一个上下文里。</p>
                            </div>
                            <div class="section" id="instances">
                              <h4>17.6 实例 (Instances)<a class="headerlink" href="#instances"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>
                                到目前为止，我们还没有将类别与实例做区别。我们使用了一个术语来表示两者，<em>对象</em>(<em>object</em>)。将所有的对象视为一体是优雅且灵活的，但这非常没效率。在许多面向对象应用里，继承图的底部会是复杂的。举例来说，模拟一个交通情况，我们可能有少于十个对象来表示车子的种类，但会有上百个对象来表示特定的车子。由于后者会全部共享少数的优先级列表，创建它们是浪费时间的，并且浪费空间来保存它们。
                              </p>
                              <p>图 17.7 定义一个宏 <code class="docutils literal"><span class="pre">inst</span></code>
                                ，用来创建实例。实例就像其他对象一样（现在也可称为类别），有区别的是只有一个父类且不需维护优先级列表。它们也没有包含在列表 <code
                                  class="docutils literal"><span class="pre">*objs**</span></code> 里。在前述例子里，我们可以说：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">setf</span> <span class="nv">grumpy-circle</span> <span class="p">(</span><span class="nv">inst</span> <span class="nv">circle-class</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p>由于某些对象不再有优先级列表，函数 <code class="docutils literal"><span class="pre">rget</span></code>
                                以及 <code class="docutils literal"><span class="pre">get-next</span></code>
                                现在被重新定义，检查这些对象的父类来取代。获得的效率不用拿灵活性交换。我们可以对一个实例做任何我们可以给其它种对象做的事，包括创建一个实例以及重定义其父类。在后面的情况里，
                                <code
                                  class="docutils literal"><span class="pre">(setf</span> <span class="pre">parents)</span></code>
                                会有效地将对象转换成一个“类别”。
                              </p>
                            </div>
                            <div class="section" id="new-implementation">
                              <h4>17.7 新的实现 (New Implementation)<a class="headerlink" href="#new-implementation"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>我们到目前为止所做的改善都是牺牲灵活性交换而来。在这个系统的开发后期，一个 Lisp
                                程序通常可以牺牲些许灵活性来获得好处，这里也不例外。目前为止我们使用哈希表来表示所有的对象。这给我们带来了超乎我们所需的灵活性，以及超乎我们所想的花费。在这个小节里，我们会重写我们的程序，用简单向量来表示对象。
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">inst</span> <span class="p">(</span><span class="nv">parent</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">obj</span> <span class="p">(</span><span class="nb">make-hash-table</span><span class="p">)))</span>
    <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nb">gethash</span> <span class="ss">:parents</span> <span class="nv">obj</span><span class="p">)</span> <span class="nv">parent</span><span class="p">)</span>
    <span class="nv">obj</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">rget</span> <span class="p">(</span><span class="nv">prop</span> <span class="nv">obj</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">prec</span> <span class="p">(</span><span class="nb">gethash</span> <span class="ss">:preclist</span> <span class="nv">obj</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">if</span> <span class="nv">prec</span>
        <span class="p">(</span><span class="nb">dolist</span> <span class="p">(</span><span class="nv">c</span> <span class="nv">prec</span><span class="p">)</span>
          <span class="p">(</span><span class="nb">multiple-value-bind</span> <span class="p">(</span><span class="nv">val</span> <span class="nv">in</span><span class="p">)</span> <span class="p">(</span><span class="nb">gethash</span> <span class="nv">prop</span> <span class="nv">c</span><span class="p">)</span>
            <span class="p">(</span><span class="k">if</span> <span class="nv">in</span> <span class="p">(</span><span class="nb">return</span> <span class="p">(</span><span class="nb">values</span> <span class="nv">val</span> <span class="nv">in</span><span class="p">)))))</span>
      <span class="p">(</span><span class="nb">multiple-value-bind</span> <span class="p">(</span><span class="nv">val</span> <span class="nv">in</span><span class="p">)</span> <span class="p">(</span><span class="nb">gethash</span> <span class="nv">prop</span> <span class="nv">obj</span><span class="p">)</span>
        <span class="p">(</span><span class="k">if</span> <span class="nv">in</span>
            <span class="p">(</span><span class="nb">values</span> <span class="nv">val</span> <span class="nv">in</span><span class="p">)</span>
            <span class="p">(</span><span class="nv">rget</span> <span class="nv">prop</span> <span class="p">(</span><span class="nb">gethash</span> <span class="ss">:parents</span> <span class="nv">obj</span><span class="p">)))))))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">get-next</span> <span class="p">(</span><span class="nv">obj</span> <span class="nv">name</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">prec</span> <span class="p">(</span><span class="nb">gethash</span> <span class="ss">:preclist</span> <span class="nv">obj</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">if</span> <span class="nv">prec</span>
        <span class="p">(</span><span class="nb">some</span> <span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">gethash</span> <span class="nv">name</span> <span class="nv">x</span><span class="p">))</span>
              <span class="p">(</span><span class="nb">cdr</span> <span class="nv">prec</span><span class="p">))</span>
      <span class="p">(</span><span class="nv">get-next</span> <span class="p">(</span><span class="nb">gethash</span> <span class="nv">obj</span> <span class="ss">:parents</span><span class="p">)</span> <span class="nv">name</span><span class="p">))))</span>
</pre>
                                </div>
                              </div>
                              <p><strong>图 17.7: 定义实例</strong></p>
                              <p>
                                这个改变意味著放弃动态定义新属性的可能性。目前我们可通过引用任何对象，给它定义一个属性。现在当一个类别被创建时，我们会需要给出一个列表，列出该类有的新属性，而当实例被创建时，他们会恰好有他们所继承的属性。
                              </p>
                              <p>
                                在先前的实现里，类别与实例没有实际区别。一个实例只是一个恰好有一个父类的类别。如果我们改动一个实例的父类，它就变成了一个类别。在新的实现里，类别与实例有实际区别；它使得将实例转成类别不再可能。
                              </p>
                              <p>在图 17.8-17.10 的代码是一个完整的新实现。图片 17.8
                                给创建类别与实例定义了新的操作符。类别与实例用向量来表示。表示类别与实例的向量的前三个元素包含程序自身要用到的信息，而图 17.8 的前三个宏是用来引用这些元素的：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defmacro</span> <span class="nv">parents</span> <span class="p">(</span><span class="nv">v</span><span class="p">)</span> <span class="o">`</span><span class="p">(</span><span class="nb">svref</span> <span class="o">,</span><span class="nv">v</span> <span class="mi">0</span><span class="p">))</span>
<span class="p">(</span><span class="nb">defmacro</span> <span class="nv">layout</span> <span class="p">(</span><span class="nv">v</span><span class="p">)</span> <span class="o">`</span><span class="p">(</span><span class="k">the</span> <span class="kt">simple-vector</span> <span class="p">(</span><span class="nb">svref</span> <span class="o">,</span><span class="nv">v</span> <span class="mi">1</span><span class="p">)))</span>
<span class="p">(</span><span class="nb">defmacro</span> <span class="nv">preclist</span> <span class="p">(</span><span class="nv">v</span><span class="p">)</span> <span class="o">`</span><span class="p">(</span><span class="nb">svref</span> <span class="o">,</span><span class="nv">v</span> <span class="mi">2</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defmacro</span> <span class="nc">class</span> <span class="p">(</span><span class="k">&amp;optional</span> <span class="nv">parents</span> <span class="k">&amp;rest</span> <span class="nv">props</span><span class="p">)</span>
  <span class="o">`</span><span class="p">(</span><span class="nv">class-fn</span> <span class="p">(</span><span class="nb">list</span> <span class="o">,@</span><span class="nv">parents</span><span class="p">)</span> <span class="ss">&#39;,props</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">class-fn</span> <span class="p">(</span><span class="nv">parents</span> <span class="nv">props</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let*</span> <span class="p">((</span><span class="nv">all</span> <span class="p">(</span><span class="nb">union</span> <span class="p">(</span><span class="nv">inherit-props</span> <span class="nv">parents</span><span class="p">)</span> <span class="nv">props</span><span class="p">))</span>
         <span class="p">(</span><span class="nv">obj</span> <span class="p">(</span><span class="nb">make-array</span> <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nb">length</span> <span class="nv">all</span><span class="p">)</span> <span class="mi">3</span><span class="p">)</span>
                          <span class="ss">:initial-element</span> <span class="ss">:nil</span><span class="p">)))</span>
    <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nv">parents</span> <span class="nv">obj</span><span class="p">)</span>  <span class="nv">parents</span>
          <span class="p">(</span><span class="nv">layout</span> <span class="nv">obj</span><span class="p">)</span>   <span class="p">(</span><span class="nb">coerce</span> <span class="nv">all</span> <span class="ss">&#39;simple-vector</span><span class="p">)</span>
          <span class="p">(</span><span class="nv">preclist</span> <span class="nv">obj</span><span class="p">)</span> <span class="p">(</span><span class="nv">precedence</span> <span class="nv">obj</span><span class="p">))</span>
    <span class="nv">obj</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">inherit-props</span> <span class="p">(</span><span class="nv">classes</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">delete-duplicates</span>
    <span class="p">(</span><span class="nb">mapcan</span> <span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">c</span><span class="p">)</span>
                <span class="p">(</span><span class="nb">nconc</span> <span class="p">(</span><span class="nb">coerce</span> <span class="p">(</span><span class="nv">layout</span> <span class="nv">c</span><span class="p">)</span> <span class="ss">&#39;list</span><span class="p">)</span>
                       <span class="p">(</span><span class="nv">inherit-props</span> <span class="p">(</span><span class="nv">parents</span> <span class="nv">c</span><span class="p">))))</span>
            <span class="nv">classes</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">precedence</span> <span class="p">(</span><span class="nv">obj</span><span class="p">)</span>
  <span class="p">(</span><span class="k">labels</span> <span class="p">((</span><span class="nv">traverse</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span>
             <span class="p">(</span><span class="nb">cons</span> <span class="nv">x</span>
                   <span class="p">(</span><span class="nb">mapcan</span> <span class="nf">#&#39;</span><span class="nv">traverse</span> <span class="p">(</span><span class="nv">parents</span> <span class="nv">x</span><span class="p">)))))</span>
    <span class="p">(</span><span class="nb">delete-duplicates</span> <span class="p">(</span><span class="nv">traverse</span> <span class="nv">obj</span><span class="p">))))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">inst</span> <span class="p">(</span><span class="nv">parent</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">obj</span> <span class="p">(</span><span class="nb">copy-seq</span> <span class="nv">parent</span><span class="p">)))</span>
    <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nv">parents</span> <span class="nv">obj</span><span class="p">)</span>  <span class="nv">parent</span>
          <span class="p">(</span><span class="nv">preclist</span> <span class="nv">obj</span><span class="p">)</span> <span class="no">nil</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">fill</span> <span class="nv">obj</span> <span class="ss">:nil</span> <span class="ss">:start</span> <span class="mi">3</span><span class="p">)</span>
    <span class="nv">obj</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p><strong>图 17.8: 向量实现：创建</strong></p>
                              <ol class="arabic simple">
                                <li><code class="docutils literal"><span class="pre">parents</span></code>
                                  字段取代旧实现中，哈希表条目里 <code
                                    class="docutils literal"><span class="pre">:parents</span></code> 的位置。在一个类别里， <code
                                    class="docutils literal"><span class="pre">parents</span></code> 会是一个列出父类的列表。在一个实例里，
                                  <code class="docutils literal"><span class="pre">parents</span></code> 会是一个单一的父类。
                                </li>
                                <li><code class="docutils literal"><span class="pre">layout</span></code>
                                  字段是一个包含属性名字的向量，指出类别或实例的从第四个元素开始的设计 (layout)。</li>
                                <li><code class="docutils literal"><span class="pre">preclist</span></code>
                                  字段取代旧实现中，哈希表条目里 <code
                                    class="docutils literal"><span class="pre">:preclist</span></code>
                                  的位置。它会是一个类别的优先级列表，实例的话就是一个空表。</li>
                              </ol>
                              <p>因为这些操作符是宏，他们全都可以被 <code class="docutils literal"><span class="pre">setf</span></code>
                                的第一个参数使用（参考 10.6 节）。</p>
                              <p><code class="docutils literal"><span class="pre">class</span></code>
                                宏用来创建类别。它接受一个含有其基类的选择性列表，伴随著零个或多个属性名称。它返回一个代表类别的对象。新的类别会同时有自己本身的属性名，以及从所有基类继承而来的属性。</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre>&gt; (setf *print-array* nil
        gemo-class (class nil area)
        circle-class (class (geom-class) radius))
#&lt;Simple-Vector T 5 C6205E&gt;
</pre>
                                </div>
                              </div>
                              <p>这里我们创建了两个类别： <code class="docutils literal"><span class="pre">geom-class</span></code>
                                没有基类，且只有一个属性， <code class="docutils literal"><span class="pre">area</span></code> ；
                                <code class="docutils literal"><span class="pre">circle-class</span></code> 是 <code
                                  class="docutils literal"><span class="pre">gemo-class</span></code> 的子类，并添加了一个属性，
                                <code class="docutils literal"><span class="pre">radius</span></code> 。 <a
                                  class="footnote-reference" href="#id8" id="id4">[1]</a> <code
                                  class="docutils literal"><span class="pre">circle-class</span></code> 类的设计
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">coerce</span> <span class="p">(</span><span class="nv">layout</span> <span class="nv">circle-class</span><span class="p">)</span> <span class="ss">&#39;list</span><span class="p">)</span>
<span class="p">(</span><span class="nv">AREA</span> <span class="nv">RADIUS</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>显示了五个字段里，最后两个的名称。 <a class="footnote-reference" href="#id9" id="id5">[2]</a></p>
                              <p><code class="docutils literal"><span class="pre">class</span></code> 宏只是一个 <code
                                  class="docutils literal"><span class="pre">class-fn</span></code> 的介面，而 <code
                                  class="docutils literal"><span class="pre">class-fn</span></code> 做了实际的工作。它调用 <code
                                  class="docutils literal"><span class="pre">inherit-props</span></code>
                                来汇整所有新对象的父类，汇整成一个列表，创建一个正确长度的向量，并适当地配置前三个字段。（ <code
                                  class="docutils literal"><span class="pre">preclist</span></code> 由 <code
                                  class="docutils literal"><span class="pre">precedence</span></code> 创建，本质上 <code
                                  class="docutils literal"><span class="pre">precedence</span></code> 没什么改变。）类别余下的字段设置为
                                <code class="docutils literal"><span class="pre">:nil</span></code> 来指出它们尚未初始化。要检视 <code
                                  class="docutils literal"><span class="pre">circle-class</span></code> 的 <code
                                  class="docutils literal"><span class="pre">area</span></code> 属性，我们可以：
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">svref</span> <span class="nv">circle-class</span>
         <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nb">position</span> <span class="ss">&#39;area</span> <span class="p">(</span><span class="nv">layout</span> <span class="nv">circle-class</span><span class="p">))</span> <span class="mi">3</span><span class="p">))</span>
<span class="ss">:NIL</span>
</pre>
                                </div>
                              </div>
                              <p>稍后我们会定义存取函数来自动办到这件事。</p>
                              <p>最后，函数 <code class="docutils literal"><span class="pre">inst</span></code>
                                用来创建实例。它不需要是一个宏，因为它仅接受一个参数：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre>&gt; (setf our-circle (inst circle-class))
#&lt;Simple-Vector T 5 C6464E&gt;
</pre>
                                </div>
                              </div>
                              <p>比较 <code class="docutils literal"><span class="pre">inst</span></code> 与 <code
                                  class="docutils literal"><span class="pre">class-fn</span></code>
                                是有益学习的，它们做了差不多的事。因为实例仅有一个父类，不需要决定它继承什么属性。实例可以仅拷贝其父类的设计。它也不需要构造一个优先级列表，因为实例没有优先级列表。创建实例因此与创建类别比起来来得快许多，因为创建实例在多数应用里比创建类别更常见。
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">declaim</span> <span class="p">(</span><span class="k">inline</span> <span class="nv">lookup</span> <span class="p">(</span><span class="nb">setf</span> <span class="nv">lookup</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">rget</span> <span class="p">(</span><span class="nv">prop</span> <span class="nv">obj</span> <span class="nv">next?</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">prec</span> <span class="p">(</span><span class="nv">preclist</span> <span class="nv">obj</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">if</span> <span class="nv">prec</span>
        <span class="p">(</span><span class="nb">dolist</span> <span class="p">(</span><span class="nv">c</span> <span class="p">(</span><span class="k">if</span> <span class="nv">next?</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">prec</span><span class="p">)</span> <span class="nv">prec</span><span class="p">)</span> <span class="ss">:nil</span><span class="p">)</span>
          <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">val</span> <span class="p">(</span><span class="nv">lookup</span> <span class="nv">prop</span> <span class="nv">c</span><span class="p">)))</span>
            <span class="p">(</span><span class="nb">unless</span> <span class="p">(</span><span class="nb">eq</span> <span class="nv">val</span> <span class="ss">:nil</span><span class="p">)</span> <span class="p">(</span><span class="nb">return</span> <span class="nv">val</span><span class="p">))))</span>
        <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">val</span> <span class="p">(</span><span class="nv">lookup</span> <span class="nv">prop</span> <span class="nv">obj</span><span class="p">)))</span>
          <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">eq</span> <span class="nv">val</span> <span class="ss">:nil</span><span class="p">)</span>
              <span class="p">(</span><span class="nv">rget</span> <span class="nv">prop</span> <span class="p">(</span><span class="nv">parents</span> <span class="nv">obj</span><span class="p">)</span> <span class="no">nil</span><span class="p">)</span>
              <span class="nv">val</span><span class="p">)))))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">lookup</span> <span class="p">(</span><span class="nv">prop</span> <span class="nv">obj</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">off</span> <span class="p">(</span><span class="nb">position</span> <span class="nv">prop</span> <span class="p">(</span><span class="nv">layout</span> <span class="nv">obj</span><span class="p">)</span> <span class="ss">:test</span> <span class="nf">#&#39;</span><span class="nb">eq</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">if</span> <span class="nv">off</span> <span class="p">(</span><span class="nb">svref</span> <span class="nv">obj</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">off</span> <span class="mi">3</span><span class="p">))</span> <span class="ss">:nil</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="p">(</span><span class="nb">setf</span> <span class="nv">lookup</span><span class="p">)</span> <span class="p">(</span><span class="nv">val</span> <span class="nv">prop</span> <span class="nv">obj</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">off</span> <span class="p">(</span><span class="nb">position</span> <span class="nv">prop</span> <span class="p">(</span><span class="nv">layout</span> <span class="nv">obj</span><span class="p">)</span> <span class="ss">:test</span> <span class="nf">#&#39;</span><span class="nb">eq</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">if</span> <span class="nv">off</span>
        <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nb">svref</span> <span class="nv">obj</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">off</span> <span class="mi">3</span><span class="p">))</span> <span class="nv">val</span><span class="p">)</span>
        <span class="p">(</span><span class="nb">error</span> <span class="s">&quot;Can&#39;t set ~A of ~A.&quot;</span> <span class="nv">val</span> <span class="nv">obj</span><span class="p">))))</span>
</pre>
                                </div>
                              </div>
                              <p><strong>图 17.9: 向量实现：存取</strong></p>
                              <p>现在我们可以创建所需的类别层级及实例，以及需要的函数来读写它们的属性。图 17.9 的第一个函数是 <code
                                  class="docutils literal"><span class="pre">rget</span></code> 的新定义。它的形状与图 17.7 的 <code
                                  class="docutils literal"><span class="pre">rget</span></code> 相似。条件式的两个分支，分别处理类别与实例。
                              </p>
                              <ol class="arabic simple">
                                <li>若对象是一个类别，我们遍历其优先级列表，直到我们找到一个对象，其中欲找的属性不是 <code
                                    class="docutils literal"><span class="pre">:nil</span></code> 。如果没有找到，返回 <code
                                    class="docutils literal"><span class="pre">:nil</span></code> 。</li>
                                <li>若对象是一个实例，我们直接查找属性，并在没找到时递回地调用 <code
                                    class="docutils literal"><span class="pre">rget</span></code> 。</li>
                              </ol>
                              <p><code class="docutils literal"><span class="pre">rget</span></code> 与 <code
                                  class="docutils literal"><span class="pre">next?</span></code> 新的第三个参数稍后解释。现在只要了解如果是
                                <code class="docutils literal"><span class="pre">nil</span></code> ， <code
                                  class="docutils literal"><span class="pre">rget</span></code> 会像平常那样工作。
                              </p>
                              <p>函数 <code class="docutils literal"><span class="pre">lookup</span></code> 及其反相扮演著先前
                                <code class="docutils literal"><span class="pre">rget</span></code> 函数里 <code
                                  class="docutils literal"><span class="pre">gethash</span></code> 的角色。它们使用一个对象的 <code
                                  class="docutils literal"><span class="pre">layout</span></code>
                                ，来取出或设置一个给定名称的属性。这条查询是先前的一个复本：
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">lookup</span> <span class="ss">&#39;area</span> <span class="nv">circle-class</span><span class="p">)</span>
<span class="ss">:NIL</span>
</pre>
                                </div>
                              </div>
                              <p>由于 <code class="docutils literal"><span class="pre">lookup</span></code> 的 <code
                                  class="docutils literal"><span class="pre">setf</span></code> 也定义了，我们可以给 <code
                                  class="docutils literal"><span class="pre">circle-class</span></code> 定义一个 <code
                                  class="docutils literal"><span class="pre">area</span></code> 方法，通过：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nv">lookup</span> <span class="ss">&#39;area</span> <span class="nv">circle-class</span><span class="p">)</span>
      <span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">c</span><span class="p">)</span>
          <span class="p">(</span><span class="nb">*</span> <span class="nv">pi</span> <span class="p">(</span><span class="nb">expt</span> <span class="p">(</span><span class="nv">rget</span> <span class="ss">&#39;radius</span> <span class="nv">c</span> <span class="no">nil</span><span class="p">)</span> <span class="mi">2</span><span class="p">))))</span>
</pre>
                                </div>
                              </div>
                              <p>在这个程序里，和先前的版本一样，没有特别区别出方法与槽。一个“方法”只是一个字段，里面有着一个函数。这将很快会被一个更方便的前端所隐藏起来。</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">declaim</span> <span class="p">(</span><span class="k">inline</span> <span class="nv">run-methods</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defmacro</span> <span class="nv">defprop</span> <span class="p">(</span><span class="nv">name</span> <span class="k">&amp;optional</span> <span class="nv">meth?</span><span class="p">)</span>
  <span class="o">`</span><span class="p">(</span><span class="k">progn</span>
     <span class="p">(</span><span class="nb">defun</span> <span class="o">,</span><span class="nv">name</span> <span class="p">(</span><span class="nv">obj</span> <span class="k">&amp;rest</span> <span class="nv">args</span><span class="p">)</span>
       <span class="o">,</span><span class="p">(</span><span class="k">if</span> <span class="nv">meth?</span>
            <span class="o">`</span><span class="p">(</span><span class="nv">run-methods</span> <span class="nv">obj</span> <span class="ss">&#39;,name</span> <span class="nv">args</span><span class="p">)</span>
            <span class="o">`</span><span class="p">(</span><span class="nv">rget</span> <span class="ss">&#39;,name</span> <span class="nv">obj</span> <span class="no">nil</span><span class="p">)))</span>
     <span class="p">(</span><span class="nb">defun</span> <span class="p">(</span><span class="nb">setf</span> <span class="o">,</span><span class="nv">name</span><span class="p">)</span> <span class="p">(</span><span class="nv">val</span> <span class="nv">obj</span><span class="p">)</span>
       <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nv">lookup</span> <span class="ss">&#39;,name</span> <span class="nv">obj</span><span class="p">)</span> <span class="nv">val</span><span class="p">))))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">run-methods</span> <span class="p">(</span><span class="nv">obj</span> <span class="nv">name</span> <span class="nv">args</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">meth</span> <span class="p">(</span><span class="nv">rget</span> <span class="nv">name</span> <span class="nv">obj</span> <span class="no">nil</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">not</span> <span class="p">(</span><span class="nb">eq</span> <span class="nv">meth</span> <span class="ss">:nil</span><span class="p">))</span>
        <span class="p">(</span><span class="nb">apply</span> <span class="nv">meth</span> <span class="nv">obj</span> <span class="nv">args</span><span class="p">)</span>
        <span class="p">(</span><span class="nb">error</span> <span class="s">&quot;No ~A method for ~A.&quot;</span> <span class="nv">name</span> <span class="nv">obj</span><span class="p">))))</span>

<span class="p">(</span><span class="nb">defmacro</span> <span class="nv">defmeth</span> <span class="p">(</span><span class="nv">name</span> <span class="nv">obj</span> <span class="nv">parms</span> <span class="k">&amp;rest</span> <span class="nv">body</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">gobj</span> <span class="p">(</span><span class="nb">gensym</span><span class="p">)))</span>
    <span class="o">`</span><span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="o">,</span><span class="nv">gobj</span> <span class="o">,</span><span class="nv">obj</span><span class="p">))</span>
       <span class="p">(</span><span class="nv">defprop</span> <span class="o">,</span><span class="nv">name</span> <span class="no">t</span><span class="p">)</span>
       <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nv">lookup</span> <span class="ss">&#39;,name</span> <span class="o">,</span><span class="nv">gobj</span><span class="p">)</span>
             <span class="p">(</span><span class="k">labels</span> <span class="p">((</span><span class="nv">next</span> <span class="p">()</span> <span class="p">(</span><span class="nv">rget</span> <span class="o">,</span><span class="nv">gobj</span> <span class="ss">&#39;,name</span> <span class="no">t</span><span class="p">)))</span>
               <span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="o">,</span><span class="nv">parms</span> <span class="o">,@</span><span class="nv">body</span><span class="p">))))))</span>
</pre>
                                </div>
                              </div>
                              <p><strong>图 17.10: 向量实现：宏介面</strong></p>
                              <p>图 17.10 包含了新的实现的最后部分。这个代码没有给程序加入任何威力，但使程序更容易使用。宏 <code
                                  class="docutils literal"><span class="pre">defprop</span></code> 本质上没有改变；现在仅调用 <code
                                  class="docutils literal"><span class="pre">lookup</span></code> 而不是 <code
                                  class="docutils literal"><span class="pre">gethash</span></code>
                                。与先前相同，它允许我们用函数式的语法来引用属性：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">defprop</span> <span class="nv">radius</span><span class="p">)</span>
<span class="p">(</span><span class="nv">SETF</span> <span class="nv">RADIUS</span><span class="p">)</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="nv">radius</span> <span class="nv">our-circle</span><span class="p">)</span>
<span class="ss">:NIL</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nv">radius</span> <span class="nv">our-circle</span><span class="p">)</span> <span class="mi">2</span><span class="p">)</span>
<span class="mi">2</span>
</pre>
                                </div>
                              </div>
                              <p>如果 <code class="docutils literal"><span class="pre">defprop</span></code>
                                的第二个选择性参数为真的话，它展开成一个 <code
                                  class="docutils literal"><span class="pre">run-methods</span></code> 调用，基本上也没什么改变。</p>
                              <p>最后，函数 <code class="docutils literal"><span class="pre">defmeth</span></code>
                                提供了一个便捷方式来定义方法。这个版本有三件新的事情：它隐含了 <code
                                  class="docutils literal"><span class="pre">defprop</span></code> ，它调用 <code
                                  class="docutils literal"><span class="pre">lookup</span></code> 而不是 <code
                                  class="docutils literal"><span class="pre">gethash</span></code> ，且它调用 <code
                                  class="docutils literal"><span class="pre">regt</span></code> 而不是 278 页的 <code
                                  class="docutils literal"><span class="pre">get-next</span></code> (译注: 图 17.7 的 <code
                                  class="docutils literal"><span class="pre">get-next</span></code> )来获得下个方法。现在我们理解给
                                <code class="docutils literal"><span class="pre">rget</span></code> 添加额外参数的理由。它与 <code
                                  class="docutils literal"><span class="pre">get-next</span></code>
                                非常相似，我们同样通过添加一个额外参数，在一个函数里实现。若这额外参数为真时， <code
                                  class="docutils literal"><span class="pre">rget</span></code> 取代 <code
                                  class="docutils literal"><span class="pre">get-next</span></code> 的位置。
                              </p>
                              <p>现在我们可以达到先前方法定义所有的效果，但更加清晰：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nv">defmeth</span> <span class="nv">area</span> <span class="nv">circle-class</span> <span class="p">(</span><span class="nv">c</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">*</span> <span class="nv">pi</span> <span class="p">(</span><span class="nb">expt</span> <span class="p">(</span><span class="nv">radius</span> <span class="nv">c</span><span class="p">)</span> <span class="mi">2</span><span class="p">)))</span>
</pre>
                                </div>
                              </div>
                              <p>注意我们可以直接调用 <code class="docutils literal"><span class="pre">radius</span></code> 而无须调用
                                <code class="docutils literal"><span class="pre">rget</span></code> ，因为我们使用 <code
                                  class="docutils literal"><span class="pre">defprop</span></code> 将它定义成一个函数。因为隐含的 <code
                                  class="docutils literal"><span class="pre">defprop</span></code> 由 <code
                                  class="docutils literal"><span class="pre">defmeth</span></code> 实现，我们也可以调用 <code
                                  class="docutils literal"><span class="pre">area</span></code> 来获得 <code
                                  class="docutils literal"><span class="pre">our-circle</span></code> 的面积：
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">area</span> <span class="nv">our-circle</span><span class="p">)</span>
<span class="mf">12.566370614359173</span>
</pre>
                                </div>
                              </div>
                            </div>
                            <div class="section" id="analysis">
                              <h4>17.8 分析 (Analysis)<a class="headerlink" href="#analysis"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>
                                我们现在有了一个适合撰写实际面向对象程序的嵌入式语言。它很简单，但就大小来说相当强大。而在典型应用里，它也会是快速的。在一个典型的应用里，操作实例应比操作类别更常见。我们重新设计的重点在于如何使得操作实例的花费降低。
                              </p>
                              <p>
                                在我们的程序里，创建类别既慢且产生了许多垃圾。如果类别不是在速度为关键考量时创建，这还是可以接受的。会需要速度的是存取函数以及创建实例。这个程序里的没有做编译优化的存取函数大约与我们预期的一样快。
                                <a class="reference external"
                                  href="http://acl.readthedocs.org/en/latest/zhCN/notes-cn.html#notes-284">λ</a>
                                而创建实例也是如此。且两个操作都没有用到构造
                                (consing)。除了用来表达实例的向量例外。会自然的以为这应该是动态地配置才对。但我们甚至可以避免动态配置实例，如果我们使用像是 13.4 节所提出的策略。
                              </p>
                              <p>我们的嵌入式语言是 Lisp 编程的一个典型例子。只不过是一个嵌入式语言就可以是一个例子了。但 Lisp
                                的特性是它如何从一个小的、受限版本的程序，进化成一个强大但低效的版本，最终演化成快速但稍微受限的版本。</p>
                              <p>Lisp 恶名昭彰的缓慢不是 Lisp 本身导致（Lisp 编译器早在 1980 年代就可以产生出与 C
                                编译器一样快的代码），而是由于许多程序员在第二个阶段就放弃的事实。如同 Richard Gabriel 所写的，</p>
                              <blockquote>
                                <div>要在 Lisp 撰写出性能极差的程序相当简单；而在 C 这几乎是不可能的。 <a class="reference external"
                                    href="http://acl.readthedocs.org/en/latest/zhCN/notes-cn.html#notes-284-2">λ</a>
                                </div>
                              </blockquote>
                              <p>这完全是一个真的论述，但也可以解读为赞扬或贬低 Lisp 的论点：</p>
                              <ol class="arabic simple">
                                <li>通过牺牲灵活性换取速度，你可以在 Lisp 里轻松地写出程序；在 C 语言里，你没有这个选择。</li>
                                <li>除非你优化你的 Lisp 代码，不然要写出缓慢的软件根本易如反掌。</li>
                              </ol>
                              <p>你的程序属于哪一种解读完全取决于你。但至少在开发初期，Lisp 使你有牺牲执行速度来换取时间的选择。</p>
                              <p>有一件我们示例程序没有做的很好的事是，它不是一个称职的 CLOS 模型（除了可能没有说明难以理解的 <code
                                  class="docutils literal"><span class="pre">call-next-method</span></code>
                                如何工作是件好事例外）。如大象般庞大的 CLOS 与这个如蚊子般微小的 70
                                行程序之间，存在多少的相似性呢？当然，这两者的差别是出自于教育性，而不是探讨有多相似。首先，这使我们理解到“面向对象”的广度。我们的程序比任何被称为是面向对象的都来得强大，而这只不过是
                                CLOS 的一小部分威力。</p>
                              <p>我们程序与 CLOS 不同的地方是，方法是属于某个对象的。这个方法的概念使它们与对第一个参数做派发的函数相同。而当我们使用函数式语法来调用方法时，这看起来就跟 Lisp
                                的函数一样。相反地，一个 CLOS
                                的通用函数，可以派发它的任何参数。一个通用函数的组件称为方法，而若你将它们定义成只对第一个参数特化，你可以制造出它们是某个类或实例的方法的错觉。但用面向对象编程的消息传递模型来思考
                                CLOS 最终只会使你困惑，因为 CLOS 凌驾在面向对象编程之上。</p>
                              <p>CLOS 的缺点之一是它太庞大了，并且 CLOS 费煞苦心的隐藏了面向对象编程，其实只不过是改写 Lisp
                                的这个事实。本章的例子至少阐明了这一点。如果我们满足于旧的消息传递模型，我们可以用一页多一点的代码来实现。面向对象编程不过是 Lisp
                                可以做的小事之一而已。更发人深省的问题是，Lisp 除此之外还能做些什么？</p>
                              <p class="rubric">脚注</p>
                              <table class="docutils footnote" frame="void" id="id8" rules="none">
                                <colgroup>
                                  <col class="label" />
                                  <col />
                                </colgroup>
                                <tbody valign="top">
                                  <tr>
                                    <td class="label"><a class="fn-backref" href="#id4">[1]</a></td>
                                    <td>当类别被显示时， <code
                                        class="docutils literal"><span class="pre">*print-array*</span></code> 应当是 <code
                                        class="docutils literal"><span class="pre">nil</span></code> 。 任何类别的 <code
                                        class="docutils literal"><span class="pre">preclist</span></code>
                                      的第一个元素都是类别本身，所以试图显示类别的内部结构会导致一个无限循环。</td>
                                  </tr>
                                </tbody>
                              </table>
                              <table class="docutils footnote" frame="void" id="id9" rules="none">
                                <colgroup>
                                  <col class="label" />
                                  <col />
                                </colgroup>
                                <tbody valign="top">
                                  <tr>
                                    <td class="label"><a class="fn-backref" href="#id5">[2]</a></td>
                                    <td>这个向量被 coerced 成一个列表，只是为了看看里面有什么。有了 <code
                                        class="docutils literal"><span class="pre">*print-array*</span></code> 被设成 <code
                                        class="docutils literal"><span class="pre">nil</span></code> ，一个向量的内容应该不会显示出来。
                                    </td>
                                  </tr>
                                </tbody>
                              </table>
                            </div>
                          </div>
                          <div class="section" id="a">
                            <h3 id="a">附录 A：调试</h3>
                            <p>这个附录演示了如何调试 Lisp 程序，并给出你可能会遇到的常见错误。</p>
                            <div class="section" id="breakloop">
                              <h4>中断循环 (Breakloop)<a class="headerlink" href="#breakloop"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>如果你要求 Lisp
                                做些它不能做的事，求值过程会被一个错误讯息中断，而你会发现你位于一个称为中断循环的地方。中断循环工作的方式取决于不同的实现，但通常它至少会显示三件事：一个错误信息，一组选项，以及一个特别的提示符。
                              </p>
                              <p>
                                在中断循环里，你也可以像在顶层那样给表达式求值。在中断循环里，你或许能够找出错误的起因，甚至是修正它，并继续你程序的求值过程。然而，在一个中断循环里，你想做的最常见的事是跳出去。多数的错误起因于打错字或是小疏忽，所以通常你只会想终止程序并返回顶层。在下面这个假定的实现里，我们输入
                                <code class="docutils literal"><span class="pre">:abort</span></code> 来回到顶层。
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">/</span> <span class="mi">1</span> <span class="mi">0</span><span class="p">)</span>
<span class="nv">Error:</span> <span class="nv">Division</span> <span class="nv">by</span> <span class="nv">zero.</span>
       <span class="nv">Options:</span> <span class="ss">:abort,</span> <span class="ss">:backtrace</span>
<span class="nv">&gt;&gt;</span> <span class="ss">:abort</span>
<span class="nb">&gt;</span>
</pre>
                                </div>
                              </div>
                              <p>在这些情况里，实际上的输入取决于实现。</p>
                              <p>当你在中断循环里，如果一个错误发生的话，你会到另一个中断循环。多数的 Lisp 会指出你是在第几层的中断循环，要嘛通过印出多个提示符，不然就是在提示符前印出数字：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nv">&gt;&gt;</span> <span class="p">(</span><span class="nb">/</span> <span class="mi">2</span> <span class="mi">0</span><span class="p">)</span>
<span class="nv">Error:</span> <span class="nv">Division</span> <span class="nv">by</span> <span class="nv">zero.</span>
       <span class="nv">Options:</span> <span class="ss">:abort,</span> <span class="ss">:backtrace,</span> <span class="ss">:previous</span>
<span class="nv">&gt;&gt;&gt;</span>
</pre>
                                </div>
                              </div>
                              <p>现在我们位于两层深的中断循环。此时我们可以选择回到前一个中断循环，或是直接返回顶层。</p>
                            </div>
                            <div class="section" id="traces-and-backtraces">
                              <h4>追踪与回溯 (Traces and Backtraces)<a class="headerlink" href="#traces-and-backtraces"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>当你的程序不如你预期的那样工作时，有时候第一件该解决的事情是，它在做什么？如果你输入 <code
                                  class="docutils literal"><span class="pre">(trace</span> <span class="pre">foo)</span></code>
                                ，则 Lisp 会在每次调用或返回 <code class="docutils literal"><span class="pre">foo</span></code>
                                时显示一个信息，显示传给 <code class="docutils literal"><span class="pre">foo</span></code> 的参数，或是
                                <code class="docutils literal"><span class="pre">foo</span></code> 返回的值。你可以追踪任何自己定义的
                                (user-defined)函数。
                              </p>
                              <p>一个追踪通常会根据调用树来缩进。在一个做遍历的函数，像下面这个函数，它给一个树的每一个非空元素加上 1，</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">tree1+</span> <span class="p">(</span><span class="nv">tr</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nb">null</span> <span class="nv">tr</span><span class="p">)</span> <span class="no">nil</span><span class="p">)</span>
        <span class="p">((</span><span class="nb">atom</span> <span class="nv">tr</span><span class="p">)</span> <span class="p">(</span><span class="nb">1+</span> <span class="nv">tr</span><span class="p">))</span>
        <span class="p">(</span><span class="no">t</span> <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nv">treel+</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">tr</span><span class="p">))</span>
                 <span class="p">(</span><span class="nv">treel+</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">tr</span><span class="p">))))))</span>
</pre>
                                </div>
                              </div>
                              <p>一个树的形状会因此反映出它被遍历时的数据结构：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">trace</span> <span class="nv">tree1+</span><span class="p">)</span>
<span class="p">(</span><span class="nv">tree1+</span><span class="p">)</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="nv">tree1+</span> <span class="o">&#39;</span><span class="p">((</span><span class="mi">1</span> <span class="o">.</span> <span class="mi">3</span><span class="p">)</span> <span class="mi">5</span> <span class="o">.</span> <span class="mi">7</span><span class="p">))</span>
<span class="mi">1</span> <span class="nv">Enter</span> <span class="nv">TREE1+</span> <span class="p">((</span><span class="mi">1</span> <span class="o">.</span> <span class="mi">3</span><span class="p">)</span> <span class="mi">5</span> <span class="o">.</span> <span class="mi">7</span><span class="p">)</span>
  <span class="mi">2</span> <span class="nv">Enter</span> <span class="nv">TREE1+</span> <span class="p">(</span><span class="mf">1.3</span><span class="p">)</span>
    <span class="mi">3</span> <span class="nv">Enter</span> <span class="nv">TREE1+</span> <span class="mi">1</span>
    <span class="mi">3</span> <span class="nv">Exit</span> <span class="nv">TREE1+</span> <span class="mi">2</span>
    <span class="mi">3</span> <span class="nv">Enter</span> <span class="nv">TREE1+</span> <span class="mi">3</span>
    <span class="mi">3</span> <span class="nv">Exit</span> <span class="nv">TREE1+</span> <span class="mi">4</span>
  <span class="mi">2</span> <span class="nv">Exit</span> <span class="nv">TREE1+</span> <span class="p">(</span><span class="mi">2</span> <span class="o">.</span> <span class="mi">4</span><span class="p">)</span>
  <span class="mi">2</span> <span class="nv">Enter</span> <span class="nv">TREE1+</span> <span class="p">(</span><span class="mi">5</span> <span class="o">.</span> <span class="mi">7</span><span class="p">)</span>
    <span class="mi">3</span> <span class="nv">Enter</span> <span class="nv">TREE1+</span> <span class="mi">5</span>
    <span class="mi">3</span> <span class="nv">Exit</span> <span class="nv">TREE1+</span> <span class="mi">6</span>
    <span class="mi">3</span> <span class="nv">Enter</span> <span class="nv">TREE1+</span> <span class="mi">7</span>
    <span class="mi">3</span> <span class="nv">Exit</span> <span class="nv">TREE1+</span> <span class="mi">8</span>
  <span class="mi">2</span> <span class="nv">Exit</span> <span class="nv">TREE1+</span> <span class="p">(</span><span class="mi">6</span> <span class="o">.</span> <span class="mi">8</span><span class="p">)</span>
<span class="mi">1</span> <span class="nv">Exit</span> <span class="nv">TREE1+</span> <span class="p">((</span><span class="mi">2</span> <span class="o">.</span> <span class="mi">4</span><span class="p">)</span> <span class="mi">6</span> <span class="o">.</span> <span class="mi">8</span><span class="p">)</span>
<span class="p">((</span><span class="mi">2</span> <span class="o">.</span> <span class="mi">4</span><span class="p">)</span> <span class="mi">6</span> <span class="o">.</span> <span class="mi">8</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>要关掉 <code class="docutils literal"><span class="pre">foo</span></code> 的追踪，输入 <code
                                  class="docutils literal"><span class="pre">(untrace</span> <span class="pre">foo)</span></code>
                                ；要关掉所有正在追踪的函数，只要输入 <code
                                  class="docutils literal"><span class="pre">(untrace)</span></code> 就好。</p>
                              <p>
                                一个更灵活的追踪办法是在你的代码里插入诊断性的打印语句。如果已经知道结果了，这个经典的方法大概会与复杂的调适工具一样被使用数十次。这也是为什么可以互动地重定义函数式多么有用的原因。
                              </p>
                              <p>一个回溯
                                (<em>backtrace</em>)是一个当前存在栈的调用的列表，当一个错误中止求值时，会由一个中断循环生成此列表。如果追踪像是&#8221;让我看看你在做什么&#8221;，一个回溯像是询问&#8221;我们是怎么到达这里的？&#8221;
                                在某方面上，追踪与回溯是互补的。一个追踪会显示在一个程序的调用树里，选定函数的调用。一个回溯会显示在一个程序部分的调用树里，所有函数的调用（路径为从顶层调用到发生错误的地方）。
                              </p>
                              <p>在一个典型的实现里，我们可通过在中断循环里输入 <code
                                  class="docutils literal"><span class="pre">:backtrace</span></code>
                                来获得一个回溯，看起来可能像下面这样：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre>&gt; (tree1+ &#39; ( ( 1 . 3) 5 . A))
Error: A is not a valid argument to 1+.
       Options: :abort, :backtrace
» :backtrace
(1+ A)
(TREE1+ A)
(TREE1+ (5 . A))
(TREE1+ ((1 . 3) 5 . A))
</pre>
                                </div>
                              </div>
                              <p>出现在回溯里的臭虫较容易被发现。你可以仅往回检查调用链，直到你找到第一个不该发生的事情。另一个函数式编程 (2.12
                                节)的好处是所有的臭虫都会在回溯里出现。在纯函数式代码里，每一个可能出错的调用，在错误发生时，一定会在栈出现。</p>
                              <p>
                                一个回溯每个实现所提供的信息量都不同。某些实现会完整显示一个所有待调用的历史，并显示参数。其他实现可能仅显示调用历史。一般来说，追踪与回溯解释型的代码会得到较多的信息，这也是为什么你要在确定你的程序可以工作之后，再来编译。
                              </p>
                              <p>传统上我们在解释器里调试代码，且只在工作的情况下才编译。但这个观点也是可以改变的：至少有两个 Common Lisp 实现没有包含解释器。</p>
                            </div>
                            <div class="section" id="when-noting-happens">
                              <h4>当什么事都没发生时 (When Noting Happens)<a class="headerlink" href="#when-noting-happens"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>不是所有的 bug 都会打断求值过程。另一个常见并可能更危险的情况是，当 Lisp 好像不鸟你一样。通常这是程序进入无穷循环的徵兆。</p>
                              <p>如果你怀疑你进入了无穷循环，解决方法是中止执行，并跳出中断循环。</p>
                              <p>如果循环是用迭代写成的代码，Lisp 会开心地执行到天荒地老。但若是用递归写成的代码（没有做尾递归优化），你最终会获得一个信息，信息说 Lisp 把栈的空间给用光了：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">defun</span> <span class="nv">blow-stack</span> <span class="p">()</span> <span class="p">(</span><span class="nb">1+</span> <span class="p">(</span><span class="nv">blow-stack</span><span class="p">)))</span>
<span class="nv">BLOW-STACK</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="nv">blow-stack</span><span class="p">)</span>
<span class="nv">Error:</span> <span class="nv">Stack</span> <span class="nv">Overflow</span>
</pre>
                                </div>
                              </div>
                              <p>在这两个情况里，如果你怀疑进入了无穷循环，解决办法是中断执行，并跳出由于中断所产生的中断循环。</p>
                              <p>有时候程序在处理一个非常庞大的问题时，就算没有进入无穷循环，也会把栈的空间用光。虽然这很少见。通常把栈空间用光是编程错误的徵兆。</p>
                              <p>递归函数最常见的错误是忘记了基本用例 (base case)。用英语来描述递归，通常会忽略基本用例。不严谨地说，我们可能说“obj
                                是列表的成员，如果它是列表的第一个元素，或是剩余列表的成员” 严格上来讲，应该添加一句“若列表为空，则 obj 不是列表的成员”。不然我们描述的就是个无穷递归了。</p>
                              <p>在 Common Lisp 里，如果给入 <code class="docutils literal"><span class="pre">nil</span></code>
                                作为参数， <code class="docutils literal"><span class="pre">car</span></code> 与 <code
                                  class="docutils literal"><span class="pre">cdr</span></code> 皆返回 <code
                                  class="docutils literal"><span class="pre">nil</span></code> ：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">car</span> <span class="no">nil</span><span class="p">)</span>
<span class="no">NIL</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="nb">cdr</span> <span class="no">nil</span><span class="p">)</span>
<span class="no">NIL</span>
</pre>
                                </div>
                              </div>
                              <p>所以若我们在 <code class="docutils literal"><span class="pre">member</span></code>
                                函数里忽略了基本用例：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">our-member</span> <span class="p">(</span><span class="nv">obj</span> <span class="nv">lst</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">eql</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">lst</span><span class="p">)</span> <span class="nv">obj</span><span class="p">)</span>
      <span class="nv">lst</span>
      <span class="p">(</span><span class="nv">our-member</span> <span class="nv">obj</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">lst</span><span class="p">))))</span>
</pre>
                                </div>
                              </div>
                              <p>要是我们找的对象不在列表里的话，则会陷入无穷循环。当我们到达列表底端而无所获时，递归调用会等价于：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nv">our-member</span> <span class="nv">obj</span> <span class="no">nil</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>在正确的定义中（第十六页「译注: 2.7 节」），基本用例在此时会停止递归，并返回 <code
                                  class="docutils literal"><span class="pre">nil</span></code> 。但在上面错误的定义里，函数愚昧地寻找 <code
                                  class="docutils literal"><span class="pre">nil</span></code> 的 <code
                                  class="docutils literal"><span class="pre">car</span></code> ，是 <code
                                  class="docutils literal"><span class="pre">nil</span></code> ，并将 <code
                                  class="docutils literal"><span class="pre">nil</span></code> 拿去跟我们寻找的对象比较。除非我们要找的对象刚好是
                                <code class="docutils literal"><span class="pre">nil</span></code> ，不然函数会继续在 <code
                                  class="docutils literal"><span class="pre">nil</span></code> 的 <code
                                  class="docutils literal"><span class="pre">cdr</span></code> 里寻找，刚好也是 <code
                                  class="docutils literal"><span class="pre">nil</span></code> ── 整个过程又重来了。
                              </p>
                              <p>如果一个无穷循环的起因不是那么直观，可能可以通过看看追踪或回溯来诊断出来。无穷循环有两种。简单发现的那种是依赖程序结构的那种。一个追踪或回溯会即刻演示出，我们的 <code
                                  class="docutils literal"><span class="pre">our-member</span></code> 究竟哪里出错了。</p>
                              <p>比较难发现的那种，是因为数据结构有缺陷才发生的无穷循环。如果你无意中创建了环状结构（见 199页「12.3 节」，遍历结构的代码可能会掉入无穷循环里。这些 bug
                                很难发现，因为不在后面不会发生，看起来像没有错误的代码一样。最佳的解决办法是预防，如同 199
                                页所描述的：避免使用破坏性操作，直到程序已经正常工作，且你已准备好要调优代码来获得效率。</p>
                              <p>如果 Lisp
                                有不鸟你的倾向，也有可能是等待你完成输入什么。在多数系统里，按下回车是没有效果的，直到你输入了一个完整的表达式。这个方法的好事是它允许你输入多行的表达式。坏事是如果你无意中少了一个闭括号，或是一个闭引号，Lisp
                                会一直等你，直到你真正完成输入完整的表达式：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre>&gt; (format t &quot;for example ~A~% &#39;this)
</pre>
                                </div>
                              </div>
                              <p>这里我们在控制字符串的最后忽略了闭引号。在此时按下回车是没用的，因为 Lisp 认为我们还在输入一个字符串。</p>
                              <p>在某些实现里，你可以回到上一行，并插入闭引号。在不允许你回到前行的系统，最佳办法通常是中断执行，并从中断循环回到顶层。</p>
                            </div>
                            <div class="section" id="no-value-unbound">
                              <h4>没有值或未绑定 (No Value/Unbound)<a class="headerlink" href="#no-value-unbound"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>一个你最常听到 Lisp 的抱怨是一个符号没有值或未绑定。数种不同的问题都用这种方式呈现。</p>
                              <p>局部变量，如 <code class="docutils literal"><span class="pre">let</span></code> 与 <code
                                  class="docutils literal"><span class="pre">defun</span></code>
                                设置的那些，只在创建它们的表达式主体里合法。所以要是我们试著在 创建变量的 <code
                                  class="docutils literal"><span class="pre">let</span></code> 外部引用它，</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="k">progn</span>
    <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">x</span> <span class="mi">10</span><span class="p">))</span>
      <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;Here x = ~A. ~%&quot;</span> <span class="nv">x</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;But now it&#39;s gone...~%&quot;</span><span class="p">)</span>
    <span class="nv">x</span><span class="p">)</span>
<span class="nv">Here</span> <span class="nv">x</span> <span class="nb">=</span> <span class="mi">10.</span>
<span class="nv">But</span> <span class="nv">now</span> <span class="nv">it</span><span class="ss">&#39;s</span> <span class="nv">gone...</span>
<span class="nv">Error:</span> <span class="nv">X</span> <span class="nv">has</span> <span class="nv">no</span> <span class="nv">value.</span>
</pre>
                                </div>
                              </div>
                              <p>我们获得一个错误。当 Lisp 抱怨某些东西没有值或未绑定时，它的意思通常是你无意间引用了一个不存在的变量。因为没有叫做 <code
                                  class="docutils literal"><span class="pre">x</span></code> 的局部变量，Lisp
                                假定我们要引用一个有着这个名字的全局变量或常量。错误会发生是因为当 Lisp 试著要查找它的值的时候，却发现根本没有给值。打错变量的名字通常会给出同样的结果。</p>
                              <p>一个类似的问题发生在我们无意间将函数引用成变量。举例来说：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="nb">defun</span> <span class="nv">foo</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="mi">1</span><span class="p">))</span>
<span class="nv">Error:</span> <span class="nv">DEFUN</span> <span class="nv">has</span> <span class="nv">no</span> <span class="nv">value</span>
</pre>
                                </div>
                              </div>
                              <p>这在第一次发生时可能会感到疑惑： <code class="docutils literal"><span class="pre">defun</span></code>
                                怎么可能会没有值？问题的症结点在于我们忽略了最初的左括号，导致 Lisp 把符号 <code
                                  class="docutils literal"><span class="pre">defun</span></code> 解读错误，将它视为一个全局变量的引用。</p>
                              <p>有可能你真的忘记初始化某个全局变量。如果你没有给 <code
                                  class="docutils literal"><span class="pre">defvar</span></code>
                                第二个参数，你的全局变量会被宣告出来，但没有初始化；这可能是问题的根源。</p>
                            </div>
                            <div class="section" id="nil-unexpected-nils">
                              <h4>意料之外的 Nil (Unexpected Nils)<a class="headerlink" href="#nil-unexpected-nils"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>当函数抱怨传入 <code class="docutils literal"><span class="pre">nil</span></code>
                                作为参数时，通常是程序先前出错的徵兆。数个内置操作符返回 <code
                                  class="docutils literal"><span class="pre">nil</span></code> 来指出失败。但由于 <code
                                  class="docutils literal"><span class="pre">nil</span></code> 是一个合法的 Lisp
                                对象，问题可能之后才发生，在程序某部分试著要使用这个信以为真的返回值时。</p>
                              <p>举例来说，返回一个月有多少天的函数有一个 bug；假设我们忘记十月份了：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">month-length</span> <span class="p">(</span><span class="nv">mon</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">case</span> <span class="nv">mon</span>
    <span class="p">((</span><span class="nv">jan</span> <span class="nv">mar</span> <span class="nv">may</span> <span class="nv">jul</span> <span class="nv">aug</span> <span class="nv">dec</span><span class="p">)</span> <span class="mi">31</span><span class="p">)</span>
    <span class="p">((</span><span class="nv">apr</span> <span class="nv">jun</span> <span class="nv">sept</span> <span class="nv">nov</span><span class="p">)</span> <span class="mi">30</span><span class="p">)</span>
    <span class="p">(</span><span class="nv">feb</span> <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nv">leap-year</span><span class="p">)</span> <span class="mi">29</span> <span class="mi">28</span><span class="p">))))</span>
</pre>
                                </div>
                              </div>
                              <p>如果有另一个函数，企图想计算出一个月当中有几个礼拜，</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">month-weeks</span> <span class="p">(</span><span class="nv">mon</span><span class="p">)</span> <span class="p">(</span><span class="nb">/</span> <span class="p">(</span><span class="nv">month-length</span> <span class="nv">mon</span><span class="p">)</span> <span class="mf">7.0</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p>则会发生下面的情形：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">month-weeks</span> <span class="ss">&#39;oct</span><span class="p">)</span>
<span class="nv">Error:</span> <span class="no">NIL</span> <span class="nv">is</span> <span class="nb">not</span> <span class="nv">a</span> <span class="nv">valud</span> <span class="nv">argument</span> <span class="nv">to</span> <span class="nv">/.</span>
</pre>
                                </div>
                              </div>
                              <p>问题发生的原因是因为 <code class="docutils literal"><span class="pre">month-length</span></code>
                                在 <code class="docutils literal"><span class="pre">case</span></code> 找不到匹配 。当这个情形发生时，
                                <code class="docutils literal"><span class="pre">case</span></code> 返回 <code
                                  class="docutils literal"><span class="pre">nil</span></code> 。然后 <code
                                  class="docutils literal"><span class="pre">month-weeks</span></code> ，认为获得了一个数字，将值传给
                                <code class="docutils literal"><span class="pre">/</span></code> ，<code
                                  class="docutils literal"><span class="pre">/</span></code> 就抱怨了。
                              </p>
                              <p>在这里最起码 bug 与 bug 的临床表现是挨著发生的。这样的 bug 在它们相距很远时很难找到。要避免这个可能性，某些 Lisp 方言让跑完 <code
                                  class="docutils literal"><span class="pre">case</span></code> 或 <code
                                  class="docutils literal"><span class="pre">cond</span></code> 又没匹配的情形，产生一个错误。在 Common
                                Lisp 里，在这种情况里可以做的是使用 <code
                                  class="docutils literal"><span class="pre">ecase</span></code> ，如 14.6 节所描述的。</p>
                            </div>
                            <div class="section" id="renaming">
                              <h4>重新命名 (Renaming)<a class="headerlink" href="#renaming"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>在某些场合里（但不是全部场合），有一种特别狡猾的 bug ，起因于重新命名函数或变量，。举例来说，假设我们定义下列（低效的）
                                函数来找出双重嵌套列表的深度：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">depth</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">atom</span> <span class="nv">x</span><span class="p">)</span>
      <span class="mi">1</span>
      <span class="p">(</span><span class="nb">1+</span> <span class="p">(</span><span class="nb">apply</span> <span class="nf">#&#39;</span><span class="nb">max</span> <span class="p">(</span><span class="nb">mapcar</span> <span class="nf">#&#39;</span><span class="nv">depth</span> <span class="nv">x</span><span class="p">)))))</span>
</pre>
                                </div>
                              </div>
                              <p>测试函数时，我们发现它给我们错误的答案（应该是 1）：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">depth</span> <span class="o">&#39;</span><span class="p">((</span><span class="nv">a</span><span class="p">)))</span>
<span class="mi">3</span>
</pre>
                                </div>
                              </div>
                              <p>起初的 <code class="docutils literal"><span class="pre">1</span></code> 应该是 <code
                                  class="docutils literal"><span class="pre">0</span></code>
                                才对。如果我们修好这个错误，并给这个函数一个较不模糊的名称：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">nesting-depth</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">atom</span> <span class="nv">x</span><span class="p">)</span>
      <span class="mi">0</span>
      <span class="p">(</span><span class="nb">1+</span> <span class="p">(</span><span class="nb">apply</span> <span class="nf">#&#39;</span><span class="nb">max</span> <span class="p">(</span><span class="nb">mapcar</span> <span class="nf">#&#39;</span><span class="nv">depth</span> <span class="nv">x</span><span class="p">)))))</span>
</pre>
                                </div>
                              </div>
                              <p>当我们再测试上面的例子，它返回同样的结果：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">nesting-depth</span> <span class="o">&#39;</span><span class="p">((</span><span class="nv">a</span><span class="p">)))</span>
<span class="mi">3</span>
</pre>
                                </div>
                              </div>
                              <p>我们不是修好这个函数了吗？没错，但答案不是来自我们修好的代码。我们忘记也改掉递归调用中的名称。在递归用例里，我们的新函数仍调用先前的 <code
                                  class="docutils literal"><span class="pre">depth</span></code> ，这当然是不对的。</p>
                            </div>
                            <div class="section" id="keywords-as-optional-parameters">
                              <h4>作为选择性参数的关键字 (Keywords as Optional Parameters)<a class="headerlink"
                                  href="#keywords-as-optional-parameters" title="Permalink to this headline">¶</a></h4>
                              <p>若函数同时接受关键字与选择性参数，这通常是个错误，无心地提供了关键字作为选择性参数。举例来说，函数 <code
                                  class="docutils literal"><span class="pre">read-from-string</span></code> 有着下列的参数列表：
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">read-from-string</span> <span class="nb">string</span> <span class="k">&amp;optional</span> <span class="nv">eof-error</span> <span class="nv">eof-value</span>
                         <span class="k">&amp;key</span> <span class="nv">start</span> <span class="nv">end</span> <span class="nv">preserve-whitespace</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>这样一个函数你需要依序提供值，给所有的选择性参数，再来才是关键字参数。如果你忘记了选择性参数，看看下面这个例子，</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">read-from-string</span> <span class="s">&quot;abcd&quot;</span> <span class="ss">:start</span> <span class="mi">2</span><span class="p">)</span>
<span class="nv">ABCD</span>
<span class="mi">4</span>
</pre>
                                </div>
                              </div>
                              <p>则 <code class="docutils literal"><span class="pre">:start</span></code> 与 <code
                                  class="docutils literal"><span class="pre">2</span></code> 会成为前两个选择性参数的值。若我们想要 <code
                                  class="docutils literal"><span class="pre">read</span></code> 从第二个字符开始读取，我们应该这么说：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">read-from-string</span> <span class="s">&quot;abcd&quot;</span> <span class="no">nil</span> <span class="no">nil</span> <span class="ss">:start</span> <span class="mi">2</span><span class="p">)</span>
<span class="nv">CD</span>
<span class="mi">4</span>
</pre>
                                </div>
                              </div>
                            </div>
                            <div class="section" id="misdeclarations">
                              <h4>错误声明 (Misdeclarations)<a class="headerlink" href="#misdeclarations"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>第十三章解释了如何给变量及数据结构做类型声明。通过给变量做类型声明，你保证变量只会包含某种类型的值。当产生代码时，Lisp
                                编译器会依赖这个假定。举例来说，这个函数的两个参数都声明为 <code
                                  class="docutils literal"><span class="pre">double-floats</span></code> ，</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">df*</span> <span class="p">(</span><span class="nv">a</span> <span class="nv">b</span><span class="p">)</span>
  <span class="p">(</span><span class="k">declare</span> <span class="p">(</span><span class="kt">double-float</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">))</span>
  <span class="p">(</span><span class="nb">*</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p>因此编译器在产生代码时，被授权直接将浮点乘法直接硬连接 (hard-wire)到代码里。</p>
                              <p>如果调用 <code class="docutils literal"><span class="pre">df*</span></code>
                                的参数不是声明的类型时，可能会捕捉一个错误，或单纯地返回垃圾。在某个实现里，如果我们传入两个定长数，我们获得一个硬体中断：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">df*</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span>
<span class="nv">Error:</span> <span class="nv">Interrupt.</span>
</pre>
                                </div>
                              </div>
                              <p>如果获得这样严重的错误，通常是由于数值不是先前声明的类型。</p>
                            </div>
                            <div class="section" id="warnings">
                              <h4>警告 (Warnings)<a class="headerlink" href="#warnings"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>有些时候 Lisp 会抱怨一下，但不会中断求值过程。许多这样的警告是错误的警钟。一种最常见的可能是由编译器所产生的，关于未宣告或未使用的变量。举例来说，在 66 页「译注:
                                6.4 节」， <code class="docutils literal"><span class="pre">map-int</span></code>
                                的第二个调用，有一个 <code class="docutils literal"><span class="pre">x</span></code>
                                变量没有使用到。如果想要编译器在每次编译程序时，停止通知你这些事，使用一个忽略声明：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nv">map-int</span> <span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span>
             <span class="p">(</span><span class="k">declare</span> <span class="p">(</span><span class="k">ignore</span> <span class="nv">x</span><span class="p">))</span>
             <span class="p">(</span><span class="nb">random</span> <span class="mi">100</span><span class="p">))</span>
         <span class="mi">10</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                            </div>
                          </div>
                          <div class="section">
                            <h3 id="b">附录 B：Lisp in Lisp</h3>
                            <p>这个附录包含了 58 个最常用的 Common Lisp 操作符。因为如此多的 Lisp 是（或可以）用 Lisp 所写成，而由于 Lisp
                              程序（或可以）相当精简，这是一种方便解释语言的方式。</p>
                            <p>这个练习也证明了，概念上 Common Lisp 不像看起来那样庞大。许多 Common Lisp
                              操作符是有用的函式库；要写出所有其它的东西，你所需要的操作符相当少。在这个附录的这些定义只需要:</p>
                            <p><code class="docutils literal"><span class="pre">apply</span></code> <code
                                class="docutils literal"><span class="pre">aref</span></code> <code
                                class="docutils literal"><span class="pre">backquote</span></code> <code
                                class="docutils literal"><span class="pre">block</span></code> <code
                                class="docutils literal"><span class="pre">car</span></code> <code
                                class="docutils literal"><span class="pre">cdr</span></code> <code
                                class="docutils literal"><span class="pre">ceiling</span></code> <code
                                class="docutils literal"><span class="pre">char=</span></code> <code
                                class="docutils literal"><span class="pre">cons</span></code> <code
                                class="docutils literal"><span class="pre">defmacro</span></code> <code
                                class="docutils literal"><span class="pre">documentation</span></code> <code
                                class="docutils literal"><span class="pre">eq</span></code> <code
                                class="docutils literal"><span class="pre">error</span></code> <code
                                class="docutils literal"><span class="pre">expt</span></code> <code
                                class="docutils literal"><span class="pre">fdefinition</span></code> <code
                                class="docutils literal"><span class="pre">function</span></code> <code
                                class="docutils literal"><span class="pre">floor</span></code> <code
                                class="docutils literal"><span class="pre">gensym</span></code> <code
                                class="docutils literal"><span class="pre">get-setf-expansion</span></code> <code
                                class="docutils literal"><span class="pre">if</span></code> <code
                                class="docutils literal"><span class="pre">imagpart</span></code> <code
                                class="docutils literal"><span class="pre">labels</span></code> <code
                                class="docutils literal"><span class="pre">length</span></code> <code
                                class="docutils literal"><span class="pre">multiple-value-bind</span></code> <code
                                class="docutils literal"><span class="pre">nth-value</span></code> <code
                                class="docutils literal"><span class="pre">quote</span></code> <code
                                class="docutils literal"><span class="pre">realpart</span></code> <code
                                class="docutils literal"><span class="pre">symbol-function</span></code> <code
                                class="docutils literal"><span class="pre">tagbody</span></code> <code
                                class="docutils literal"><span class="pre">type-of</span></code> <code
                                class="docutils literal"><span class="pre">typep</span></code> <code
                                class="docutils literal"><span class="pre">=</span></code> <code
                                class="docutils literal"><span class="pre">+</span></code> <code
                                class="docutils literal"><span class="pre">-</span></code> <code
                                class="docutils literal"><span class="pre">/</span></code> <code
                                class="docutils literal"><span class="pre">&lt;</span></code> <code
                                class="docutils literal"><span class="pre">&gt;</span></code></p>
                            <p>这里给出的代码作为一种解释 Common Lisp
                              的方式，而不是实现它的方式。在实际的实现上，这些操作符可以更高效，也会做更多的错误检查。为了方便参找，这些操作符本身按字母顺序排列。如果你真的想要这样定义
                              Lisp，每个宏的定义需要在任何调用它们的代码之前。</p>
                            <div class="highlight-cl">
                              <div class="highlight">
                                <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">-abs</span> <span class="p">(</span><span class="nv">n</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">typep</span> <span class="nv">n</span> <span class="ss">&#39;complex</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">sqrt</span> <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nb">expt</span> <span class="p">(</span><span class="nb">realpart</span> <span class="nv">n</span><span class="p">)</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="nb">expt</span> <span class="p">(</span><span class="nb">imagpart</span> <span class="nv">n</span><span class="p">)</span> <span class="mi">2</span><span class="p">)))</span>
      <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">&lt;</span> <span class="nv">n</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">n</span><span class="p">)</span> <span class="nv">n</span><span class="p">)))</span>
</pre>
                              </div>
                            </div>
                            <div class="highlight-cl">
                              <div class="highlight">
                                <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">-adjoin</span> <span class="p">(</span><span class="nv">obj</span> <span class="nv">lst</span> <span class="k">&amp;rest</span> <span class="nv">args</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">apply</span> <span class="nf">#&#39;</span><span class="nb">member</span> <span class="nv">obj</span> <span class="nv">lst</span> <span class="nv">args</span><span class="p">)</span> <span class="nv">lst</span> <span class="p">(</span><span class="nb">cons</span> <span class="nv">obj</span> <span class="nv">lst</span><span class="p">)))</span>
</pre>
                              </div>
                            </div>
                            <div class="highlight-cl">
                              <div class="highlight">
                                <pre><span class="p">(</span><span class="nb">defmacro</span> <span class="nv">-and</span> <span class="p">(</span><span class="k">&amp;rest</span> <span class="nv">args</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nb">null</span> <span class="nv">args</span><span class="p">)</span> <span class="no">t</span><span class="p">)</span>
        <span class="p">((</span><span class="nb">cdr</span> <span class="nv">args</span><span class="p">)</span>  <span class="o">`</span><span class="p">(</span><span class="k">if</span> <span class="o">,</span><span class="p">(</span><span class="nb">car</span> <span class="nv">args</span><span class="p">)</span> <span class="p">(</span><span class="nv">-and</span> <span class="o">,@</span><span class="p">(</span><span class="nb">cdr</span> <span class="nv">args</span><span class="p">))))</span>
        <span class="p">(</span><span class="no">t</span>           <span class="p">(</span><span class="nb">car</span> <span class="nv">args</span><span class="p">))))</span>
</pre>
                              </div>
                            </div>
                            <div class="highlight-cl">
                              <div class="highlight">
                                <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">-append</span> <span class="p">(</span><span class="k">&amp;optional</span> <span class="nb">first</span> <span class="k">&amp;rest</span> <span class="nb">rest</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">null</span> <span class="nb">rest</span><span class="p">)</span>
      <span class="nb">first</span>
      <span class="p">(</span><span class="nb">nconc</span> <span class="p">(</span><span class="nb">copy-list</span> <span class="nb">first</span><span class="p">)</span> <span class="p">(</span><span class="nb">apply</span> <span class="nf">#&#39;</span><span class="nv">-append</span> <span class="nb">rest</span><span class="p">))))</span>
</pre>
                              </div>
                            </div>
                            <div class="highlight-cl">
                              <div class="highlight">
                                <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">-atom</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">not</span> <span class="p">(</span><span class="nb">consp</span> <span class="nv">x</span><span class="p">)))</span>
</pre>
                              </div>
                            </div>
                            <div class="highlight-cl">
                              <div class="highlight">
                                <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">-butlast</span> <span class="p">(</span><span class="nv">lst</span> <span class="k">&amp;optional</span> <span class="p">(</span><span class="nv">n</span> <span class="mi">1</span><span class="p">))</span>
  <span class="p">(</span><span class="nb">nreverse</span> <span class="p">(</span><span class="nb">nthcdr</span> <span class="nv">n</span> <span class="p">(</span><span class="nb">reverse</span> <span class="nv">lst</span><span class="p">))))</span>
</pre>
                              </div>
                            </div>
                            <div class="highlight-cl">
                              <div class="highlight">
                                <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">-cadr</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">car</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">x</span><span class="p">)))</span>
</pre>
                              </div>
                            </div>
                            <div class="highlight-cl">
                              <div class="highlight">
                                <pre><span class="p">(</span><span class="nb">defmacro</span> <span class="nv">-case</span> <span class="p">(</span><span class="nv">arg</span> <span class="k">&amp;rest</span> <span class="nv">clauses</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">g</span> <span class="p">(</span><span class="nb">gensym</span><span class="p">)))</span>
    <span class="o">`</span><span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="o">,</span><span class="nv">g</span> <span class="o">,</span><span class="nv">arg</span><span class="p">))</span>
       <span class="p">(</span><span class="nb">cond</span> <span class="o">,@</span><span class="p">(</span><span class="nb">mapcar</span> <span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">cl</span><span class="p">)</span>
                           <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">k</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">cl</span><span class="p">)))</span>
                             <span class="o">`</span><span class="p">(</span><span class="o">,</span><span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nb">member</span> <span class="nv">k</span> <span class="o">&#39;</span><span class="p">(</span><span class="no">t</span> <span class="nv">otherwise</span><span class="p">))</span>
                                       <span class="no">t</span><span class="p">)</span>
                                      <span class="p">((</span><span class="nb">consp</span> <span class="nv">k</span><span class="p">)</span>
                                       <span class="o">`</span><span class="p">(</span><span class="nb">member</span> <span class="o">,</span><span class="nv">g</span> <span class="ss">&#39;,k</span><span class="p">))</span>
                                      <span class="p">(</span><span class="no">t</span> <span class="o">`</span><span class="p">(</span><span class="nb">eql</span> <span class="o">,</span><span class="nv">g</span> <span class="ss">&#39;,k</span><span class="p">)))</span>
                               <span class="p">(</span><span class="k">progn</span> <span class="o">,@</span><span class="p">(</span><span class="nb">cdr</span> <span class="nv">cl</span><span class="p">)))))</span>
                       <span class="nv">clauses</span><span class="p">)))))</span>
</pre>
                              </div>
                            </div>
                            <div class="highlight-cl">
                              <div class="highlight">
                                <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">-cddr</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">x</span><span class="p">)))</span>
</pre>
                              </div>
                            </div>
                            <div class="highlight-cl">
                              <div class="highlight">
                                <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">-complement</span> <span class="p">(</span><span class="nv">fn</span><span class="p">)</span>
  <span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="k">&amp;rest</span> <span class="nv">args</span><span class="p">)</span> <span class="p">(</span><span class="nb">not</span> <span class="p">(</span><span class="nb">apply</span> <span class="nv">fn</span> <span class="nv">args</span><span class="p">))))</span>
</pre>
                              </div>
                            </div>
                            <div class="highlight-cl">
                              <div class="highlight">
                                <pre><span class="p">(</span><span class="nb">defmacro</span> <span class="nv">-cond</span> <span class="p">(</span><span class="k">&amp;rest</span> <span class="nv">args</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">null</span> <span class="nv">args</span><span class="p">)</span>
      <span class="no">nil</span>
      <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">clause</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">args</span><span class="p">)))</span>
        <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">clause</span><span class="p">)</span>
            <span class="o">`</span><span class="p">(</span><span class="k">if</span> <span class="o">,</span><span class="p">(</span><span class="nb">car</span> <span class="nv">clause</span><span class="p">)</span>
                 <span class="p">(</span><span class="k">progn</span> <span class="o">,@</span><span class="p">(</span><span class="nb">cdr</span> <span class="nv">clause</span><span class="p">))</span>
                 <span class="p">(</span><span class="nv">-cond</span> <span class="o">,@</span><span class="p">(</span><span class="nb">cdr</span> <span class="nv">args</span><span class="p">)))</span>
            <span class="o">`</span><span class="p">(</span><span class="nb">or</span> <span class="o">,</span><span class="p">(</span><span class="nb">car</span> <span class="nv">clause</span><span class="p">)</span>
                 <span class="p">(</span><span class="nv">-cond</span> <span class="o">,@</span><span class="p">(</span><span class="nb">cdr</span> <span class="nv">args</span><span class="p">)))))))</span>
</pre>
                              </div>
                            </div>
                            <div class="highlight-cl">
                              <div class="highlight">
                                <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">-consp</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">typep</span> <span class="nv">x</span> <span class="ss">&#39;cons</span><span class="p">))</span>
</pre>
                              </div>
                            </div>
                            <div class="highlight-cl">
                              <div class="highlight">
                                <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">-constantly</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span> <span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="k">&amp;rest</span> <span class="nv">args</span><span class="p">)</span> <span class="nv">x</span><span class="p">))</span>
</pre>
                              </div>
                            </div>
                            <div class="highlight-cl">
                              <div class="highlight">
                                <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">-copy-list</span> <span class="p">(</span><span class="nv">lst</span><span class="p">)</span>
  <span class="p">(</span><span class="k">labels</span> <span class="p">((</span><span class="nv">cl</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span>
             <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">atom</span> <span class="nv">x</span><span class="p">)</span>
                 <span class="nv">x</span>
                 <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">x</span><span class="p">)</span>
                       <span class="p">(</span><span class="nv">cl</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">x</span><span class="p">))))))</span>
    <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">lst</span><span class="p">)</span>
          <span class="p">(</span><span class="nv">cl</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">lst</span><span class="p">)))))</span>
</pre>
                              </div>
                            </div>
                            <div class="highlight-cl">
                              <div class="highlight">
                                <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">-copy-tree</span> <span class="p">(</span><span class="nv">tr</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">atom</span> <span class="nv">tr</span><span class="p">)</span>
      <span class="nv">tr</span>
      <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nv">-copy-tree</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">tr</span><span class="p">))</span>
            <span class="p">(</span><span class="nv">-copy-tree</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">tr</span><span class="p">)))))</span>
</pre>
                              </div>
                            </div>
                            <div class="highlight-cl">
                              <div class="highlight">
                                <pre><span class="p">(</span><span class="nb">defmacro</span> <span class="nv">-defun</span> <span class="p">(</span><span class="nv">name</span> <span class="nv">parms</span> <span class="k">&amp;rest</span> <span class="nv">body</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">multiple-value-bind</span> <span class="p">(</span><span class="nv">dec</span> <span class="nv">doc</span> <span class="nv">bod</span><span class="p">)</span> <span class="p">(</span><span class="nv">analyze-body</span> <span class="nv">body</span><span class="p">)</span>
    <span class="o">`</span><span class="p">(</span><span class="k">progn</span>
       <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nb">fdefinition</span> <span class="ss">&#39;,name</span><span class="p">)</span>
             <span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="o">,</span><span class="nv">parms</span>
                 <span class="o">,@</span><span class="nv">dec</span>
                 <span class="p">(</span><span class="k">block</span> <span class="o">,</span><span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">atom</span> <span class="nv">name</span><span class="p">)</span> <span class="nv">name</span> <span class="p">(</span><span class="nb">second</span> <span class="nv">name</span><span class="p">))</span>
                   <span class="o">,@</span><span class="nv">bod</span><span class="p">))</span>
             <span class="p">(</span><span class="nb">documentation</span> <span class="ss">&#39;,name</span> <span class="ss">&#39;function</span><span class="p">)</span>
             <span class="o">,</span><span class="nv">doc</span><span class="p">)</span>
       <span class="ss">&#39;,name</span><span class="p">)))</span>
</pre>
                              </div>
                            </div>
                            <div class="highlight-cl">
                              <div class="highlight">
                                <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">analyze-body</span> <span class="p">(</span><span class="nv">body</span> <span class="k">&amp;optional</span> <span class="nv">dec</span> <span class="nv">doc</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">expr</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">body</span><span class="p">)))</span>
    <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nb">and</span> <span class="p">(</span><span class="nb">consp</span> <span class="nv">expr</span><span class="p">)</span> <span class="p">(</span><span class="nb">eq</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">expr</span><span class="p">)</span> <span class="ss">&#39;declare</span><span class="p">))</span>
           <span class="p">(</span><span class="nv">analyze-body</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">body</span><span class="p">)</span> <span class="p">(</span><span class="nb">cons</span> <span class="nv">expr</span> <span class="nv">dec</span><span class="p">)</span> <span class="nv">doc</span><span class="p">))</span>
          <span class="p">((</span><span class="nb">and</span> <span class="p">(</span><span class="nb">stringp</span> <span class="nv">expr</span><span class="p">)</span> <span class="p">(</span><span class="nb">not</span> <span class="nv">doc</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">body</span><span class="p">))</span>
           <span class="p">(</span><span class="k">if</span> <span class="nv">dec</span>
               <span class="p">(</span><span class="nb">values</span> <span class="nv">dec</span> <span class="nv">expr</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">body</span><span class="p">))</span>
               <span class="p">(</span><span class="nv">analyze-body</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">body</span><span class="p">)</span> <span class="nv">dec</span> <span class="nv">expr</span><span class="p">)))</span>
          <span class="p">(</span><span class="no">t</span> <span class="p">(</span><span class="nb">values</span> <span class="nv">dec</span> <span class="nv">doc</span> <span class="nv">body</span><span class="p">)))))</span>
</pre>
                              </div>
                            </div>
                            <p>这个定义不完全正确，参见 <code class="docutils literal"><span class="pre">let</span></code></p>
                            <div class="highlight-cl">
                              <div class="highlight">
                                <pre><span class="p">(</span><span class="nb">defmacro</span> <span class="nv">-do</span> <span class="p">(</span><span class="nv">binds</span> <span class="p">(</span><span class="nv">test</span> <span class="k">&amp;rest</span> <span class="nv">result</span><span class="p">)</span> <span class="k">&amp;rest</span> <span class="nv">body</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">fn</span> <span class="p">(</span><span class="nb">gensym</span><span class="p">)))</span>
    <span class="o">`</span><span class="p">(</span><span class="k">block</span> <span class="no">nil</span>
       <span class="p">(</span><span class="k">labels</span> <span class="p">((</span><span class="o">,</span><span class="nv">fn</span> <span class="o">,</span><span class="p">(</span><span class="nb">mapcar</span> <span class="nf">#&#39;</span><span class="nb">car</span> <span class="nv">binds</span><span class="p">)</span>
                   <span class="p">(</span><span class="nb">cond</span> <span class="p">(</span><span class="o">,</span><span class="nv">test</span> <span class="o">,@</span><span class="nv">result</span><span class="p">)</span>
                         <span class="p">(</span><span class="no">t</span> <span class="p">(</span><span class="k">tagbody</span> <span class="o">,@</span><span class="nv">body</span><span class="p">)</span>
                            <span class="p">(</span><span class="o">,</span><span class="nv">fn</span> <span class="o">,@</span><span class="p">(</span><span class="nb">mapcar</span> <span class="nf">#&#39;</span><span class="nb">third</span> <span class="nv">binds</span><span class="p">))))))</span>
         <span class="p">(</span><span class="o">,</span><span class="nv">fn</span> <span class="o">,@</span><span class="p">(</span><span class="nb">mapcar</span> <span class="nf">#&#39;</span><span class="nb">second</span> <span class="nv">binds</span><span class="p">))))))</span>
</pre>
                              </div>
                            </div>
                            <div class="highlight-cl">
                              <div class="highlight">
                                <pre><span class="p">(</span><span class="nb">defmacro</span> <span class="nv">-dolist</span> <span class="p">((</span><span class="nv">var</span> <span class="nv">lst</span> <span class="k">&amp;optional</span> <span class="nv">result</span><span class="p">)</span> <span class="k">&amp;rest</span> <span class="nv">body</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">g</span> <span class="p">(</span><span class="nb">gensym</span><span class="p">)))</span>
    <span class="o">`</span><span class="p">(</span><span class="nb">do</span> <span class="p">((</span><span class="o">,</span><span class="nv">g</span> <span class="o">,</span><span class="nv">lst</span> <span class="p">(</span><span class="nb">cdr</span> <span class="o">,</span><span class="nv">g</span><span class="p">)))</span>
         <span class="p">((</span><span class="nb">atom</span> <span class="o">,</span><span class="nv">g</span><span class="p">)</span> <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="o">,</span><span class="nv">var</span> <span class="no">nil</span><span class="p">))</span> <span class="o">,</span><span class="nv">result</span><span class="p">))</span>
       <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="o">,</span><span class="nv">var</span> <span class="p">(</span><span class="nb">car</span> <span class="o">,</span><span class="nv">g</span><span class="p">)))</span>
         <span class="o">,@</span><span class="nv">body</span><span class="p">))))</span>
</pre>
                              </div>
                            </div>
                            <div class="highlight-cl">
                              <div class="highlight">
                                <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">-eql</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">typecase</span> <span class="nv">x</span>
    <span class="p">(</span><span class="nb">character</span> <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nb">typep</span> <span class="nv">y</span> <span class="ss">&#39;character</span><span class="p">)</span> <span class="p">(</span><span class="nb">char=</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)))</span>
    <span class="p">(</span><span class="nc">number</span>    <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nb">eq</span> <span class="p">(</span><span class="nb">type-of</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">type-of</span> <span class="nv">y</span><span class="p">))</span>
                    <span class="p">(</span><span class="nb">=</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)))</span>
    <span class="p">(</span><span class="no">t</span>         <span class="p">(</span><span class="nb">eq</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">))))</span>
</pre>
                              </div>
                            </div>
                            <div class="highlight-cl">
                              <div class="highlight">
                                <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">-evenp</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">typecase</span> <span class="nv">x</span>
    <span class="p">(</span><span class="nc">integer</span> <span class="p">(</span><span class="nb">=</span> <span class="mi">0</span> <span class="p">(</span><span class="nb">mod</span> <span class="nv">x</span> <span class="mi">2</span><span class="p">)))</span>
    <span class="p">(</span><span class="no">t</span>       <span class="p">(</span><span class="nb">error</span> <span class="s">&quot;non-integer argument&quot;</span><span class="p">))))</span>
</pre>
                              </div>
                            </div>
                            <div class="highlight-cl">
                              <div class="highlight">
                                <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">-funcall</span> <span class="p">(</span><span class="nv">fn</span> <span class="k">&amp;rest</span> <span class="nv">args</span><span class="p">)</span> <span class="p">(</span><span class="nb">apply</span> <span class="nv">fn</span> <span class="nv">args</span><span class="p">))</span>
</pre>
                              </div>
                            </div>
                            <div class="highlight-cl">
                              <div class="highlight">
                                <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">-identity</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span> <span class="nv">x</span><span class="p">)</span>
</pre>
                              </div>
                            </div>
                            <p>这个定义不完全正确：表达式 <code
                                class="docutils literal"><span class="pre">(let</span> <span class="pre">((&amp;key</span> <span class="pre">1)</span> <span class="pre">(&amp;optional</span> <span class="pre">2)))</span></code>
                              是合法的，但它产生的表达式不合法。</p>
                            <div class="highlight-cl">
                              <div class="highlight">
                                <pre><span class="p">(</span><span class="nb">defmacro</span> <span class="nv">-let</span> <span class="p">(</span><span class="nv">parms</span> <span class="k">&amp;rest</span> <span class="nv">body</span><span class="p">)</span>
  <span class="o">`</span><span class="p">((</span><span class="k">lambda</span> <span class="o">,</span><span class="p">(</span><span class="nb">mapcar</span> <span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span>
                         <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">atom</span> <span class="nv">x</span><span class="p">)</span> <span class="nv">x</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">x</span><span class="p">)))</span>
                     <span class="nv">parms</span><span class="p">)</span>
      <span class="o">,@</span><span class="nv">body</span><span class="p">)</span>
    <span class="o">,@</span><span class="p">(</span><span class="nb">mapcar</span> <span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span>
                  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">atom</span> <span class="nv">x</span><span class="p">)</span> <span class="no">nil</span> <span class="p">(</span><span class="nb">cadr</span> <span class="nv">x</span><span class="p">)))</span>
              <span class="nv">parms</span><span class="p">)))</span>
</pre>
                              </div>
                            </div>
                            <div class="highlight-cl">
                              <div class="highlight">
                                <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">-list</span> <span class="p">(</span><span class="k">&amp;rest</span> <span class="nv">elts</span><span class="p">)</span> <span class="p">(</span><span class="nb">copy-list</span> <span class="nv">elts</span><span class="p">))</span>
</pre>
                              </div>
                            </div>
                            <div class="highlight-cl">
                              <div class="highlight">
                                <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">-listp</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">or</span> <span class="p">(</span><span class="nb">consp</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">null</span> <span class="nv">x</span><span class="p">)))</span>
</pre>
                              </div>
                            </div>
                            <div class="highlight-cl">
                              <div class="highlight">
                                <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">-mapcan</span> <span class="p">(</span><span class="nv">fn</span> <span class="k">&amp;rest</span> <span class="nv">lsts</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">apply</span> <span class="nf">#&#39;</span><span class="nb">nconc</span> <span class="p">(</span><span class="nb">apply</span> <span class="nf">#&#39;</span><span class="nb">mapcar</span> <span class="nv">fn</span> <span class="nv">lsts</span><span class="p">)))</span>
</pre>
                              </div>
                            </div>
                            <div class="highlight-cl">
                              <div class="highlight">
                                <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">-mapcar</span> <span class="p">(</span><span class="nv">fn</span> <span class="k">&amp;rest</span> <span class="nv">lsts</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nb">member</span> <span class="no">nil</span> <span class="nv">lsts</span><span class="p">)</span> <span class="no">nil</span><span class="p">)</span>
        <span class="p">((</span><span class="nb">null</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">lsts</span><span class="p">))</span>
         <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">lst</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">lsts</span><span class="p">)))</span>
           <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nb">funcall</span> <span class="nv">fn</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">lst</span><span class="p">))</span>
                 <span class="p">(</span><span class="nv">-mapcar</span> <span class="nv">fn</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">lst</span><span class="p">)))))</span>
        <span class="p">(</span><span class="no">t</span>
         <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nb">apply</span> <span class="nv">fn</span> <span class="p">(</span><span class="nv">-mapcar</span> <span class="nf">#&#39;</span><span class="nb">car</span> <span class="nv">lsts</span><span class="p">))</span>
               <span class="p">(</span><span class="nb">apply</span> <span class="nf">#&#39;</span><span class="nv">-mapcar</span> <span class="nv">fn</span>
                      <span class="p">(</span><span class="nv">-mapcar</span> <span class="nf">#&#39;</span><span class="nb">cdr</span> <span class="nv">lsts</span><span class="p">))))))</span>
</pre>
                              </div>
                            </div>
                            <div class="highlight-cl">
                              <div class="highlight">
                                <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">-member</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">lst</span> <span class="k">&amp;key</span> <span class="nv">test</span> <span class="nv">test-not</span> <span class="nv">key</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">fn</span> <span class="p">(</span><span class="nb">or</span> <span class="nv">test</span>
                <span class="p">(</span><span class="k">if</span> <span class="nv">test-not</span>
                    <span class="p">(</span><span class="nb">complement</span> <span class="nv">test-not</span><span class="p">))</span>
                    <span class="nf">#&#39;</span><span class="nb">eql</span><span class="p">)))</span>
    <span class="p">(</span><span class="nb">member-if</span> <span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">y</span><span class="p">)</span>
                   <span class="p">(</span><span class="nb">funcall</span> <span class="nv">fn</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">))</span>
               <span class="nv">lst</span>
               <span class="ss">:key</span> <span class="nv">key</span><span class="p">)))</span>
</pre>
                              </div>
                            </div>
                            <div class="highlight-cl">
                              <div class="highlight">
                                <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">-member-if</span> <span class="p">(</span><span class="nv">fn</span> <span class="nv">lst</span> <span class="k">&amp;key</span> <span class="p">(</span><span class="nv">key</span> <span class="nf">#&#39;</span><span class="nb">identity</span><span class="p">))</span>
  <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nb">atom</span> <span class="nv">lst</span><span class="p">)</span> <span class="no">nil</span><span class="p">)</span>
        <span class="p">((</span><span class="nb">funcall</span> <span class="nv">fn</span> <span class="p">(</span><span class="nb">funcall</span> <span class="nv">key</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">lst</span><span class="p">)))</span> <span class="nv">lst</span><span class="p">)</span>
        <span class="p">(</span><span class="no">t</span> <span class="p">(</span><span class="nv">-member-if</span> <span class="nv">fn</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">lst</span><span class="p">)</span> <span class="ss">:key</span> <span class="nv">key</span><span class="p">))))</span>
</pre>
                              </div>
                            </div>
                            <div class="highlight-cl">
                              <div class="highlight">
                                <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">-mod</span> <span class="p">(</span><span class="nv">n</span> <span class="nv">m</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">nth-value</span> <span class="mi">1</span> <span class="p">(</span><span class="nb">floor</span> <span class="nv">n</span> <span class="nv">m</span><span class="p">)))</span>
</pre>
                              </div>
                            </div>
                            <div class="highlight-cl">
                              <div class="highlight">
                                <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">-nconc</span> <span class="p">(</span><span class="k">&amp;optional</span> <span class="nv">lst</span> <span class="k">&amp;rest</span> <span class="nb">rest</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="nb">rest</span>
      <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">rest-conc</span> <span class="p">(</span><span class="nb">apply</span> <span class="nf">#&#39;</span><span class="nv">-nconc</span> <span class="nb">rest</span><span class="p">)))</span>
        <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">consp</span> <span class="nv">lst</span><span class="p">)</span>
            <span class="p">(</span><span class="k">progn</span> <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nb">cdr</span> <span class="p">(</span><span class="nb">last</span> <span class="nv">lst</span><span class="p">))</span> <span class="nv">rest-conc</span><span class="p">)</span>
                   <span class="nv">lst</span><span class="p">)</span>
            <span class="nv">rest-conc</span><span class="p">))</span>
      <span class="nv">lst</span><span class="p">))</span>
</pre>
                              </div>
                            </div>
                            <div class="highlight-cl">
                              <div class="highlight">
                                <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">-not</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">eq</span> <span class="nv">x</span> <span class="no">nil</span><span class="p">))</span>
<span class="p">(</span><span class="nb">defun</span> <span class="nv">-nreverse</span> <span class="p">(</span><span class="nv">seq</span><span class="p">)</span>
  <span class="p">(</span><span class="k">labels</span> <span class="p">((</span><span class="nv">nrl</span> <span class="p">(</span><span class="nv">lst</span><span class="p">)</span>
             <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">prev</span> <span class="no">nil</span><span class="p">))</span>
               <span class="p">(</span><span class="nb">do</span> <span class="p">()</span>
                   <span class="p">((</span><span class="nb">null</span> <span class="nv">lst</span><span class="p">)</span> <span class="nv">prev</span><span class="p">)</span>
                 <span class="p">(</span><span class="nb">psetf</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">lst</span><span class="p">)</span> <span class="nv">prev</span>
                        <span class="nv">prev</span>      <span class="nv">lst</span>
                        <span class="nv">lst</span>       <span class="p">(</span><span class="nb">cdr</span> <span class="nv">lst</span><span class="p">)))))</span>
           <span class="p">(</span><span class="nv">nrv</span> <span class="p">(</span><span class="nv">vec</span><span class="p">)</span>
             <span class="p">(</span><span class="k">let*</span> <span class="p">((</span><span class="nv">len</span> <span class="p">(</span><span class="nb">length</span> <span class="nv">vec</span><span class="p">))</span>
                    <span class="p">(</span><span class="nv">ilimit</span> <span class="p">(</span><span class="nb">truncate</span> <span class="p">(</span><span class="nb">/</span> <span class="nv">len</span> <span class="mi">2</span><span class="p">))))</span>
               <span class="p">(</span><span class="nb">do</span> <span class="p">((</span><span class="nv">i</span> <span class="mi">0</span> <span class="p">(</span><span class="nb">1+</span> <span class="nv">i</span><span class="p">))</span>
                    <span class="p">(</span><span class="nv">j</span> <span class="p">(</span><span class="nb">1-</span> <span class="nv">len</span><span class="p">)</span> <span class="p">(</span><span class="nb">1-</span> <span class="nv">j</span><span class="p">)))</span>
                   <span class="p">((</span><span class="nb">&gt;=</span> <span class="nv">i</span> <span class="nv">ilimit</span><span class="p">)</span> <span class="nv">vec</span><span class="p">)</span>
                 <span class="p">(</span><span class="nb">rotatef</span> <span class="p">(</span><span class="nb">aref</span> <span class="nv">vec</span> <span class="nv">i</span><span class="p">)</span> <span class="p">(</span><span class="nb">aref</span> <span class="nv">vec</span> <span class="nv">j</span><span class="p">))))))</span>
    <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">typep</span> <span class="nv">seq</span> <span class="ss">&#39;vector</span><span class="p">)</span>
        <span class="p">(</span><span class="nv">nrv</span> <span class="nv">seq</span><span class="p">)</span>
        <span class="p">(</span><span class="nv">nrl</span> <span class="nv">seq</span><span class="p">))))</span>
</pre>
                              </div>
                            </div>
                            <div class="highlight-cl">
                              <div class="highlight">
                                <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">-null</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">eq</span> <span class="nv">x</span> <span class="no">nil</span><span class="p">))</span>
</pre>
                              </div>
                            </div>
                            <div class="highlight-cl">
                              <div class="highlight">
                                <pre><span class="p">(</span><span class="nb">defmacro</span> <span class="nv">-or</span> <span class="p">(</span><span class="k">&amp;optional</span> <span class="nb">first</span> <span class="k">&amp;rest</span> <span class="nb">rest</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">null</span> <span class="nb">rest</span><span class="p">)</span>
      <span class="nb">first</span>
      <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">g</span> <span class="p">(</span><span class="nb">gensym</span><span class="p">)))</span>
        <span class="o">`</span><span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="o">,</span><span class="nv">g</span> <span class="o">,</span><span class="nb">first</span><span class="p">))</span>
           <span class="p">(</span><span class="k">if</span> <span class="o">,</span><span class="nv">g</span>
               <span class="o">,</span><span class="nv">g</span>
               <span class="p">(</span><span class="nv">-or</span> <span class="o">,@</span><span class="nb">rest</span><span class="p">))))))</span>
</pre>
                              </div>
                            </div>
                            <p>这两个 Common Lisp 没有，但这里有几的定义会需要用到。</p>
                            <div class="highlight-cl">
                              <div class="highlight">
                                <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">pair</span> <span class="p">(</span><span class="nv">lst</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">null</span> <span class="nv">lst</span><span class="p">)</span>
      <span class="no">nil</span>
      <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">lst</span><span class="p">)</span> <span class="p">(</span><span class="nb">cadr</span> <span class="nv">lst</span><span class="p">))</span>
            <span class="p">(</span><span class="nv">pair</span> <span class="p">(</span><span class="nb">cddr</span> <span class="nv">lst</span><span class="p">)))))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">-pairlis</span> <span class="p">(</span><span class="nv">keys</span> <span class="nv">vals</span> <span class="k">&amp;optional</span> <span class="nv">alist</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">unless</span> <span class="p">(</span><span class="nb">=</span> <span class="p">(</span><span class="nb">length</span> <span class="nv">keys</span><span class="p">)</span> <span class="p">(</span><span class="nb">length</span> <span class="nv">vals</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">error</span> <span class="s">&quot;mismatched lengths&quot;</span><span class="p">))</span>
  <span class="p">(</span><span class="nb">nconc</span> <span class="p">(</span><span class="nb">mapcar</span> <span class="nf">#&#39;</span><span class="nb">cons</span> <span class="nv">keys</span> <span class="nv">vals</span><span class="p">)</span> <span class="nv">alist</span><span class="p">))</span>
</pre>
                              </div>
                            </div>
                            <div class="highlight-cl">
                              <div class="highlight">
                                <pre><span class="p">(</span><span class="nb">defmacro</span> <span class="nv">-pop</span> <span class="p">(</span><span class="nv">place</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">multiple-value-bind</span> <span class="p">(</span><span class="nv">vars</span> <span class="nv">forms</span> <span class="nv">var</span> <span class="nb">set</span> <span class="nv">access</span><span class="p">)</span>
                       <span class="p">(</span><span class="nb">get-setf-expansion</span> <span class="nv">place</span><span class="p">)</span>
    <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">g</span> <span class="p">(</span><span class="nb">gensym</span><span class="p">)))</span>
      <span class="o">`</span><span class="p">(</span><span class="k">let*</span> <span class="p">(</span><span class="o">,@</span><span class="p">(</span><span class="nb">mapcar</span> <span class="nf">#&#39;</span><span class="nb">list</span> <span class="nv">vars</span> <span class="nv">forms</span><span class="p">)</span>
              <span class="p">(</span><span class="o">,</span><span class="nv">g</span> <span class="o">,</span><span class="nv">access</span><span class="p">)</span>
              <span class="p">(</span><span class="o">,</span><span class="p">(</span><span class="nb">car</span> <span class="nv">var</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr</span> <span class="o">,</span><span class="nv">g</span><span class="p">)))</span>
         <span class="p">(</span><span class="nb">prog1</span> <span class="p">(</span><span class="nb">car</span> <span class="o">,</span><span class="nv">g</span><span class="p">)</span>
                <span class="o">,</span><span class="nb">set</span><span class="p">)))))</span>
</pre>
                              </div>
                            </div>
                            <div class="highlight-cl">
                              <div class="highlight">
                                <pre><span class="p">(</span><span class="nb">defmacro</span> <span class="nv">-prog1</span> <span class="p">(</span><span class="nv">arg1</span> <span class="k">&amp;rest</span> <span class="nv">args</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">g</span> <span class="p">(</span><span class="nb">gensym</span><span class="p">)))</span>
    <span class="o">`</span><span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="o">,</span><span class="nv">g</span> <span class="o">,</span><span class="nv">arg1</span><span class="p">))</span>
       <span class="o">,@</span><span class="nv">args</span>
       <span class="o">,</span><span class="nv">g</span><span class="p">)))</span>
</pre>
                              </div>
                            </div>
                            <div class="highlight-cl">
                              <div class="highlight">
                                <pre><span class="p">(</span><span class="nb">defmacro</span> <span class="nv">-prog2</span> <span class="p">(</span><span class="nv">arg1</span> <span class="nv">arg2</span> <span class="k">&amp;rest</span> <span class="nv">args</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">g</span> <span class="p">(</span><span class="nb">gensym</span><span class="p">)))</span>
    <span class="o">`</span><span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="o">,</span><span class="nv">g</span> <span class="p">(</span><span class="k">progn</span> <span class="o">,</span><span class="nv">arg1</span> <span class="o">,</span><span class="nv">arg2</span><span class="p">)))</span>
       <span class="o">,@</span><span class="nv">args</span>
       <span class="o">,</span><span class="nv">g</span><span class="p">)))</span>
</pre>
                              </div>
                            </div>
                            <div class="highlight-cl">
                              <div class="highlight">
                                <pre><span class="p">(</span><span class="nb">defmacro</span> <span class="nv">-progn</span> <span class="p">(</span><span class="k">&amp;rest</span> <span class="nv">args</span><span class="p">)</span> <span class="o">`</span><span class="p">(</span><span class="k">let</span> <span class="no">nil</span> <span class="o">,@</span><span class="nv">args</span><span class="p">))</span>
</pre>
                              </div>
                            </div>
                            <div class="highlight-cl">
                              <div class="highlight">
                                <pre><span class="p">(</span><span class="nb">defmacro</span> <span class="nv">-psetf</span> <span class="p">(</span><span class="k">&amp;rest</span> <span class="nv">args</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">unless</span> <span class="p">(</span><span class="nb">evenp</span> <span class="p">(</span><span class="nb">length</span> <span class="nv">args</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">error</span> <span class="s">&quot;odd number of arguments&quot;</span><span class="p">))</span>
  <span class="p">(</span><span class="k">let*</span> <span class="p">((</span><span class="nv">pairs</span> <span class="p">(</span><span class="nv">pair</span> <span class="nv">args</span><span class="p">))</span>
         <span class="p">(</span><span class="nv">syms</span> <span class="p">(</span><span class="nb">mapcar</span> <span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">gensym</span><span class="p">))</span>
                       <span class="nv">pairs</span><span class="p">)))</span>
    <span class="o">`</span><span class="p">(</span><span class="k">let</span> <span class="o">,</span><span class="p">(</span><span class="nb">mapcar</span> <span class="nf">#&#39;</span><span class="nb">list</span>
                   <span class="nv">syms</span>
                   <span class="p">(</span><span class="nb">mapcar</span> <span class="nf">#&#39;</span><span class="nb">cdr</span> <span class="nv">pairs</span><span class="p">))</span>
       <span class="p">(</span><span class="nb">setf</span> <span class="o">,@</span><span class="p">(</span><span class="nb">mapcan</span> <span class="nf">#&#39;</span><span class="nb">list</span>
                       <span class="p">(</span><span class="nb">mapcar</span> <span class="nf">#&#39;</span><span class="nb">car</span> <span class="nv">pairs</span><span class="p">)</span>
                       <span class="nv">syms</span><span class="p">)))))</span>
</pre>
                              </div>
                            </div>
                            <div class="highlight-cl">
                              <div class="highlight">
                                <pre><span class="p">(</span><span class="nb">defmacro</span> <span class="nv">-push</span> <span class="p">(</span><span class="nv">obj</span> <span class="nv">place</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">multiple-value-bind</span> <span class="p">(</span><span class="nv">vars</span> <span class="nv">forms</span> <span class="nv">var</span> <span class="nb">set</span> <span class="nv">access</span><span class="p">)</span>
                       <span class="p">(</span><span class="nb">get-setf-expansion</span> <span class="nv">place</span><span class="p">)</span>
    <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">g</span> <span class="p">(</span><span class="nb">gensym</span><span class="p">)))</span>
      <span class="o">`</span><span class="p">(</span><span class="k">let*</span> <span class="p">((</span><span class="o">,</span><span class="nv">g</span> <span class="o">,</span><span class="nv">obj</span><span class="p">)</span>
              <span class="o">,@</span><span class="p">(</span><span class="nb">mapcar</span> <span class="nf">#&#39;</span><span class="nb">list</span> <span class="nv">vars</span> <span class="nv">forms</span><span class="p">)</span>
              <span class="p">(</span><span class="o">,</span><span class="p">(</span><span class="nb">car</span> <span class="nv">var</span><span class="p">)</span> <span class="p">(</span><span class="nb">cons</span> <span class="o">,</span><span class="nv">g</span> <span class="o">,</span><span class="nv">access</span><span class="p">)))</span>
         <span class="o">,</span><span class="nb">set</span><span class="p">))))</span>
</pre>
                              </div>
                            </div>
                            <div class="highlight-cl">
                              <div class="highlight">
                                <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">-rem</span> <span class="p">(</span><span class="nv">n</span> <span class="nv">m</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">nth-value</span> <span class="mi">1</span> <span class="p">(</span><span class="nb">truncate</span> <span class="nv">n</span> <span class="nv">m</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defmacro</span> <span class="nv">-rotatef</span> <span class="p">(</span><span class="k">&amp;rest</span> <span class="nv">args</span><span class="p">)</span>
  <span class="o">`</span><span class="p">(</span><span class="nb">psetf</span> <span class="o">,@</span><span class="p">(</span><span class="nb">mapcan</span> <span class="nf">#&#39;</span><span class="nb">list</span>
                    <span class="nv">args</span>
                    <span class="p">(</span><span class="nb">append</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">args</span><span class="p">)</span>
                            <span class="p">(</span><span class="nb">list</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">args</span><span class="p">))))))</span>
</pre>
                              </div>
                            </div>
                            <div class="highlight-cl">
                              <div class="highlight">
                                <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">-second</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">cadr</span> <span class="nv">x</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defmacro</span> <span class="nv">-setf</span> <span class="p">(</span><span class="k">&amp;rest</span> <span class="nv">args</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">null</span> <span class="nv">args</span><span class="p">)</span>
      <span class="no">nil</span>
      <span class="o">`</span><span class="p">(</span><span class="nv">setf2</span> <span class="o">,@</span><span class="nv">args</span><span class="p">)))</span>
</pre>
                              </div>
                            </div>
                            <div class="highlight-cl">
                              <div class="highlight">
                                <pre><span class="p">(</span><span class="nb">defmacro</span> <span class="nv">setf2</span> <span class="p">(</span><span class="nv">place</span> <span class="nv">val</span> <span class="k">&amp;rest</span> <span class="nv">args</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">multiple-value-bind</span> <span class="p">(</span><span class="nv">vars</span> <span class="nv">forms</span> <span class="nv">var</span> <span class="nb">set</span><span class="p">)</span>
                       <span class="p">(</span><span class="nb">get-setf-expansion</span> <span class="nv">place</span><span class="p">)</span>
    <span class="o">`</span><span class="p">(</span><span class="k">progn</span>
       <span class="p">(</span><span class="k">let*</span> <span class="p">(</span><span class="o">,@</span><span class="p">(</span><span class="nb">mapcar</span> <span class="nf">#&#39;</span><span class="nb">list</span> <span class="nv">vars</span> <span class="nv">forms</span><span class="p">)</span>
              <span class="p">(</span><span class="o">,</span><span class="p">(</span><span class="nb">car</span> <span class="nv">var</span><span class="p">)</span> <span class="o">,</span><span class="nv">val</span><span class="p">))</span>
         <span class="o">,</span><span class="nb">set</span><span class="p">)</span>
       <span class="o">,@</span><span class="p">(</span><span class="k">if</span> <span class="nv">args</span> <span class="o">`</span><span class="p">((</span><span class="nv">setf2</span> <span class="o">,@</span><span class="nv">args</span><span class="p">))</span> <span class="no">nil</span><span class="p">))))</span>
</pre>
                              </div>
                            </div>
                            <div class="highlight-cl">
                              <div class="highlight">
                                <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">-signum</span> <span class="p">(</span><span class="nv">n</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">zerop</span> <span class="nv">n</span><span class="p">)</span> <span class="mi">0</span> <span class="p">(</span><span class="nb">/</span> <span class="nv">n</span> <span class="p">(</span><span class="nb">abs</span> <span class="nv">n</span><span class="p">))))</span>
</pre>
                              </div>
                            </div>
                            <div class="highlight-cl">
                              <div class="highlight">
                                <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">-stringp</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">typep</span> <span class="nv">x</span> <span class="ss">&#39;string</span><span class="p">))</span>
</pre>
                              </div>
                            </div>
                            <div class="highlight-cl">
                              <div class="highlight">
                                <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">-tailp</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">or</span> <span class="p">(</span><span class="nb">eql</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nb">consp</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="nv">-tailp</span> <span class="nv">x</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">y</span><span class="p">)))))</span>
</pre>
                              </div>
                            </div>
                            <div class="highlight-cl">
                              <div class="highlight">
                                <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">-third</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">car</span> <span class="p">(</span><span class="nb">cdr</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">x</span><span class="p">))))</span>
</pre>
                              </div>
                            </div>
                            <div class="highlight-cl">
                              <div class="highlight">
                                <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">-truncate</span> <span class="p">(</span><span class="nv">n</span> <span class="k">&amp;optional</span> <span class="p">(</span><span class="nv">d</span> <span class="mi">1</span><span class="p">))</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">&gt;</span> <span class="nv">n</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nb">floor</span> <span class="nv">n</span> <span class="nv">d</span><span class="p">)</span> <span class="p">(</span><span class="nb">ceiling</span> <span class="nv">n</span> <span class="nv">d</span><span class="p">)))</span>
</pre>
                              </div>
                            </div>
                            <div class="highlight-cl">
                              <div class="highlight">
                                <pre><span class="p">(</span><span class="nb">defmacro</span> <span class="nv">-typecase</span> <span class="p">(</span><span class="nv">arg</span> <span class="k">&amp;rest</span> <span class="nv">clauses</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">g</span> <span class="p">(</span><span class="nb">gensym</span><span class="p">)))</span>
    <span class="o">`</span><span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="o">,</span><span class="nv">g</span> <span class="o">,</span><span class="nv">arg</span><span class="p">))</span>
       <span class="p">(</span><span class="nb">cond</span> <span class="o">,@</span><span class="p">(</span><span class="nb">mapcar</span> <span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">cl</span><span class="p">)</span>
                           <span class="o">`</span><span class="p">((</span><span class="nb">typep</span> <span class="o">,</span><span class="nv">g</span> <span class="ss">&#39;,</span><span class="p">(</span><span class="nb">car</span> <span class="nv">cl</span><span class="p">))</span>
                             <span class="p">(</span><span class="k">progn</span> <span class="o">,@</span><span class="p">(</span><span class="nb">cdr</span> <span class="nv">cl</span><span class="p">))))</span>
                       <span class="nv">clauses</span><span class="p">)))))</span>
</pre>
                              </div>
                            </div>
                            <div class="highlight-cl">
                              <div class="highlight">
                                <pre><span class="p">(</span><span class="nb">defmacro</span> <span class="nv">-unless</span> <span class="p">(</span><span class="nv">arg</span> <span class="k">&amp;rest</span> <span class="nv">body</span><span class="p">)</span>
  <span class="o">`</span><span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">not</span> <span class="o">,</span><span class="nv">arg</span><span class="p">)</span>
       <span class="p">(</span><span class="k">progn</span> <span class="o">,@</span><span class="nv">body</span><span class="p">)))</span>
</pre>
                              </div>
                            </div>
                            <div class="highlight-cl">
                              <div class="highlight">
                                <pre><span class="p">(</span><span class="nb">defmacro</span> <span class="nv">-when</span> <span class="p">(</span><span class="nv">arg</span> <span class="k">&amp;rest</span> <span class="nv">body</span><span class="p">)</span>
  <span class="o">`</span><span class="p">(</span><span class="k">if</span> <span class="o">,</span><span class="nv">arg</span> <span class="p">(</span><span class="k">progn</span> <span class="o">,@</span><span class="nv">body</span><span class="p">)))</span>
</pre>
                              </div>
                            </div>
                            <div class="highlight-cl">
                              <div class="highlight">
                                <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">-1+</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="mi">1</span><span class="p">))</span>
</pre>
                              </div>
                            </div>
                            <div class="highlight-cl">
                              <div class="highlight">
                                <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">-1-</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">x</span> <span class="mi">1</span><span class="p">))</span>
</pre>
                              </div>
                            </div>
                            <div class="highlight-cl">
                              <div class="highlight">
                                <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">-&gt;=</span> <span class="p">(</span><span class="nb">first</span> <span class="k">&amp;rest</span> <span class="nb">rest</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">or</span> <span class="p">(</span><span class="nb">null</span> <span class="nb">rest</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nb">or</span> <span class="p">(</span><span class="nb">&gt;</span> <span class="nb">first</span> <span class="p">(</span><span class="nb">car</span> <span class="nb">rest</span><span class="p">))</span> <span class="p">(</span><span class="nb">=</span> <span class="nb">first</span> <span class="p">(</span><span class="nb">car</span> <span class="nb">rest</span><span class="p">)))</span>
           <span class="p">(</span><span class="nb">apply</span> <span class="nf">#&#39;</span><span class="nv">-&gt;=</span> <span class="nb">rest</span><span class="p">))))</span>
</pre>
                              </div>
                            </div>
                          </div>
                          <div class="section" id="c-common-lisp">
                            <h3 id="c">附录 C：Common Lisp 的改变</h3>
                            <p>目前的 ANSI Common Lisp 与 1984 年由 Guy Steele 一书 <em>Common Lisp: the Language</em> 所定义的
                              Common Lisp 有着本质上的不同。同时也与 1990 年该书的第二版大不相同，虽然差别比较小。本附录总结了重大的改变。1990年之后的改变独自列在最后一节。</p>
                          </div>
                          <div class="section" id="d">
                            <h3 id="d">附录 D：语言参考手册</h3>
                          </div>
                          <div class="section">
                            <h3>备注</h3>
                            <p>本节既是备注亦作为参考文献。所有列于此的书籍与论文皆值得阅读。</p>
                            <p><strong>译注: 备注后面跟随的数字即书中的页码</strong></p>
                            <div class="section" id="viii-notes-viii">
                              <h4>备注 viii (Notes viii)<a class="headerlink" href="#viii-notes-viii"
                                  title="Permalink to this headline">¶</a></h4>
                              <p><a class="reference external"
                                  href="http://en.wikipedia.org/wiki/Guy_L._Steele,_Jr.">Steele, Guy L., Jr.</a>, <a
                                  class="reference external" href="http://en.wikipedia.org/wiki/Scott_Fahlman">Scott E.
                                  Fahlman</a>, <a class="reference external"
                                  href="http://en.wikipedia.org/wiki/Richard_P._Gabriel">Richard P. Gabriel</a>, <a
                                  class="reference external" href="http://en.wikipedia.org/wiki/David_Moon">David A.
                                  Moon</a>, <a class="reference external"
                                  href="http://en.wikipedia.org/wiki/Daniel_Weinreb">Daniel L. Weinreb</a> , <a
                                  class="reference external" href="http://en.wikipedia.org/wiki/Daniel_G._Bobrow">Daniel
                                  G. Bobrow</a>, <a class="reference external"
                                  href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/d/DeMichiel:Linda_G=.html">Linda
                                  G. DeMichiel</a>, <a class="reference external"
                                  href="http://www.amazon.com/Sonya-E.-Keene/e/B001ITVL6O">Sonya E. Keene</a>, <a
                                  class="reference external" href="http://en.wikipedia.org/wiki/Gregor_Kiczales">Gregor
                                  Kiczales</a>, <a class="reference external"
                                  href="http://perdues.com/CrisPerdueResume.html">Crispin Perdue</a>, <a
                                  class="reference external" href="http://en.wikipedia.org/wiki/Kent_Pitman">Kent M.
                                  Pitman</a>, <a class="reference external" href="http://www.rcwaters.org/">Richard C.
                                  Waters</a>, 以及 John L White。 <a class="reference external"
                                  href="http://www.cs.cmu.edu/Groups/AI/html/cltl/cltl2.html">Common Lisp: the Language,
                                  2nd Edition.</a> Digital Press, Bedford (MA), 1990.</p>
                            </div>
                            <div class="section" id="notes-1">
                              <h4>备注 1 (Notes 1)<a class="headerlink" href="#notes-1"
                                  title="Permalink to this headline">¶</a></h4>
                              <p><a class="reference external"
                                  href="http://en.wikipedia.org/wiki/John_McCarthy_(computer_scientist)">McCarthy,
                                  John.</a> <a class="reference external"
                                  href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.91.4527&amp;rep=rep1&amp;type=pdf">Recursive
                                  Functions of Symbolic Expressions and their Computation by Machine, Part I.</a> CACM,
                                3:4 (April 1960), pp. 184-195.</p>
                              <p><a class="reference external"
                                  href="http://en.wikipedia.org/wiki/John_McCarthy_(computer_scientist)">McCarthy,
                                  John.</a> <a class="reference external"
                                  href="http://www-formal.stanford.edu/jmc/history/lisp/lisp.html">History of Lisp.</a>
                                In <a class="reference external"
                                  href="http://en.wikipedia.org/wiki/Richard_Wexelblat">Wexelblat, Richard L.</a> (Ed.)
                                <a class="reference external"
                                  href="http://cs305.com/book/programming_languages/Conf-01/HOPLII/frontmatter.pdf">Histroy
                                  of Programming Languages.</a> Academic Press, New York, 1981, pp. 173-197.
                              </p>
                            </div>
                            <div class="section" id="notes-3">
                              <h4>备注 3 (Notes 3)<a class="headerlink" href="#notes-3"
                                  title="Permalink to this headline">¶</a></h4>
                              <p><a class="reference external"
                                  href="http://en.wikipedia.org/wiki/Frederick_Brooks">Brooks, Frederick P</a>. <a
                                  class="reference external"
                                  href="http://www.amazon.com/Mythical-Man-Month-Software-Engineering-Anniversary/dp/0201835959">The
                                  Mythical Man-Month</a>. Addison-Wesley, Reading (MA), 1975, p. 16.</p>
                              <p>Rapid prototyping is not just a way to write programs faster or better. It is a way to
                                write programs that otherwise might not get written at all.
                                Even the most ambitious people shrink from big undertakings. It&#8217;s easier to start
                                something if one can convince oneself (however speciously) that it won&#8217;t be too
                                much work. That&#8217;s why so many big things have begun as small things. Rapid
                                prototyping lets us start small.</p>
                            </div>
                            <div class="section" id="notes-4">
                              <h4>备注 4 (Notes 4)<a class="headerlink" href="#notes-4"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>同上， 第 i 页。</p>
                            </div>
                            <div class="section" id="notes-5">
                              <h4>备注 5 (Notes 5)<a class="headerlink" href="#notes-5"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>Murray, Peter and Linda. <a class="reference external"
                                  href="http://www.amazon.com/Art-Renaissance-World/dp/0500200084">The Art of the
                                  Renaissance</a>. Thames and Hudson, London, 1963, p.85.</p>
                            </div>
                            <div class="section" id="notes-5-2">
                              <h4>备注 5-2 (Notes 5-2)<a class="headerlink" href="#notes-5-2"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>Janson, W.J. <a class="reference external"
                                  href="http://www.amazon.com/History-Art-H-W-Janson/dp/0810934019/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1365042074&amp;sr=1-1&amp;keywords=History+of+Art">History
                                  of Art</a>, 3rd Edition. Abrams, New York, 1986, p. 374.</p>
                              <p>The analogy applies, of course, only to paintings done on panels and later on canvases.
                                Well-paintings continued to be done in fresco. Nor do I mean to suggest that painting
                                styles were driven by technological change; the opposite seems more nearly true.</p>
                            </div>
                            <div class="section" id="notes-12">
                              <h4>备注 12 (Notes 12)<a class="headerlink" href="#notes-12"
                                  title="Permalink to this headline">¶</a></h4>
                              <p><code class="docutils literal"><span class="pre">car</span></code> 与 <code
                                  class="docutils literal"><span class="pre">cdr</span></code> 的名字来自最早的 Lisp
                                实现里，列表内部的表示法：car 代表“寄存器位址部分的内容”、cdr 代表“寄存器递减部分的内容”。</p>
                            </div>
                            <div class="section" id="notes-17">
                              <h4>备注 17 (Notes 17)<a class="headerlink" href="#notes-17"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>对递归概念有困扰的读者，可以查阅下列的书籍：</p>
                              <p>Touretzky, David S. <a class="reference external"
                                  href="http://www.amazon.com/Common-Lisp-Introduction-Computation-Benjamin-Cummings/dp/B008T1B8WQ/ref=sr_1_3?s=books&amp;ie=UTF8&amp;qid=1365042108&amp;sr=1-3&amp;keywords=A+Gentle+Introduction+to+Symbolic+Computation">Common
                                  Lisp: A Gentle Introduction to Symbolic Computation</a>. Benjamin/Cummings, Redwood
                                City (CA), 1990, Chapter 8.</p>
                              <p>Friedman, Daniel P., and Matthias Felleisen. The Little Lisper. MIT Press, Cambridge,
                                1987.</p>
                              <p>譯註：這本書有再版，可在<a class="reference external"
                                  href="http://www.amazon.com/Common-LISP-Introduction-Symbolic-Computation/dp/0486498204/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1365042108&amp;sr=1-1&amp;keywords=A+Gentle+Introduction+to+Symbolic+Computation">這裡</a>找到。
                              </p>
                            </div>
                            <div class="section" id="notes-26">
                              <h4>备注 26 (Notes 26)<a class="headerlink" href="#notes-26"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>In ANSI Common Lisp there is also a <code
                                  class="docutils literal"><span class="pre">lambda</span></code> macro that allows you
                                to write <code
                                  class="docutils literal"><span class="pre">(lambda</span> <span class="pre">(x)</span> <span class="pre">x)</span></code>
                                for <code
                                  class="docutils literal"><span class="pre">#'(lambda</span> <span class="pre">(x)</span> <span class="pre">x)</span></code>
                                . Since the use of this macro obscures the symmetry between lambda expressions and
                                symbolic function names (where you still have to use sharp-quote), it yields a specious
                                sort of elegance at best.</p>
                            </div>
                            <div class="section" id="notes-28">
                              <h4>备注 28 (Notes 28)<a class="headerlink" href="#notes-28"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>Gabriel, Richard P. <a class="reference external"
                                  href="http://www.dreamsongs.com/Files/LispGoodNewsBadNews.pdf">Lisp Good News, Bad
                                  News, How to Win Big</a> <em>AI Expert</em>, June 1991, p.34.</p>
                            </div>
                            <div class="section" id="notes-46">
                              <h4>备注 46 (Notes 46)<a class="headerlink" href="#notes-46"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>Another thing to be aware of when using sort: it does not guarantee to preserve the
                                order of elements judged equal by the comparison function. For example, if you sort
                                <code
                                  class="docutils literal"><span class="pre">(2</span> <span class="pre">1</span> <span class="pre">1.0)</span></code>
                                by <code class="docutils literal"><span class="pre">&lt;</span></code> , a valid Common
                                Lisp implementation could return either <code
                                  class="docutils literal"><span class="pre">(1</span> <span class="pre">1.0</span> <span class="pre">2)</span></code>
                                or <code
                                  class="docutils literal"><span class="pre">(1.0</span> <span class="pre">1</span> <span class="pre">2)</span></code>
                                . To preserve as much as possible of the original order, use instead the slower <code
                                  class="docutils literal"><span class="pre">stable-sort</span></code> (also
                                destructive), which could only return the first value.
                              </p>
                            </div>
                            <div class="section" id="notes-61">
                              <h4>备注 61 (Notes 61)<a class="headerlink" href="#notes-61"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>A lot has been said about the benefits of comments, and little or nothing about their
                                cost. But they do have a cost. Good code, like good prose, comes from constant
                                rewriting. To evolve, code must be malleable and compact. Interlinear comments make
                                programs stiff and diffuse, and so inhibit the evolution of what they describe.</p>
                            </div>
                            <div class="section" id="notes-62">
                              <h4>备注 62 (Notes 62)<a class="headerlink" href="#notes-62"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>Though most implementations use the ASCII character set, the only ordering that Common
                                Lisp guarantees for characters is as follows: the 26 lowercase letters are in
                                alphabetically ascending order, as are the uppercase letters, and the digits from 0 to
                                9.</p>
                            </div>
                            <div class="section" id="notes-76">
                              <h4>备注 76 (Notes 76)<a class="headerlink" href="#notes-76"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>The standard way to implement a priority queue is to use a structure called a heap.
                                See: Sedgewick, Robert. <a class="reference external"
                                  href="http://www.amazon.com/Algorithms-4th-Robert-Sedgewick/dp/032157351X/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1365042619&amp;sr=1-1&amp;keywords=algorithms+sedgewick">Algorithms</a>.
                                Addison-Wesley, Reading (MA), 1988.</p>
                            </div>
                            <div class="section" id="notes-81">
                              <h4>备注 81 (Notes 81)<a class="headerlink" href="#notes-81"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>The definition of progn sounds a lot like the evaluation rule for Common Lisp function
                                calls (page 9). Though <code
                                  class="docutils literal"><span class="pre">progn</span></code> is a special operator,
                                we could define a similar function:</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">our-progn</span> <span class="p">(</span><span class="nv">ftrest</span> <span class="nv">args</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">car</span> <span class="p">(</span><span class="nb">last</span> <span class="nv">args</span><span class="p">)))</span>
</pre>
                                </div>
                              </div>
                              <p>This would be horribly inefficient, but functionally equivalent to the real <code
                                  class="docutils literal"><span class="pre">progn</span></code> if the last argument
                                returned exactly one value.</p>
                            </div>
                            <div class="section" id="notes-84">
                              <h4>备注 84 (Notes 84)<a class="headerlink" href="#notes-84"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>The analogy to a lambda expression breaks down if the variable names are symbols that
                                have special meanings in a parameter list. For example,</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="k">&amp;key</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="k">&amp;optional</span> <span class="mi">2</span><span class="p">)))</span>
</pre>
                                </div>
                              </div>
                              <p>is correct, but the corresponding lambda expression</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">((</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">ftkey</span> <span class="nv">ftoptional</span><span class="p">))</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>is not. The same problem arises if you try to define do in terms of <code
                                  class="docutils literal"><span class="pre">labels</span></code> . Thanks to David
                                Kuznick for pointing this out.</p>
                            </div>
                            <div class="section" id="notes-89">
                              <h4>备注 89 (Notes 89)<a class="headerlink" href="#notes-89"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>Steele, Guy L., Jr., and Richard P. Gabriel. <a class="reference external"
                                  href="http://www.dreamsongs.com/Files/HOPL2-Uncut.pdf">The Evolution of Lisp</a>. ACM
                                SIGPLANNotices 28:3 (March 1993). The example in the quoted passage was translated from
                                Scheme into Common Lisp.</p>
                            </div>
                            <div class="section" id="notes-91">
                              <h4>备注 91 (Notes 91)<a class="headerlink" href="#notes-91"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>To make the time look the way people expect, you would want to ensure that minutes and
                                seconds are represented with two digits, as in:</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">get-time-string</span> <span class="p">()</span>
  <span class="p">(</span><span class="nb">multiple-value-bind</span> <span class="p">(</span><span class="nv">s</span> <span class="nv">m</span> <span class="nv">h</span><span class="p">)</span> <span class="p">(</span><span class="nb">get-decoded-time</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">format</span> <span class="no">nil</span> <span class="s">&quot;~A:~2,,,&#39;0@A:~2,,,&#39;O@A&quot;</span> <span class="nv">h</span> <span class="nv">m</span> <span class="nv">s</span><span class="p">)))</span>
</pre>
                                </div>
                              </div>
                            </div>
                            <div class="section" id="notes-94">
                              <h4>备注 94 (Notes 94)<a class="headerlink" href="#notes-94"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>In a letter of March 18 (old style) 1751, Chesterfield writes:</p>
                              <p>“It was notorious, that the Julian Calendar was erroneous, and had overcharged the
                                solar year with eleven days. Pope Gregory the Thirteenth corrected this error [in 1582];
                                his reformed calendar was immediately received by all the Catholic powers of Europe, and
                                afterwards adopted by all the Protestant ones, except Russia, Sweden, and England. It
                                was not, in my opinion, very honourable for England to remain in a gross and avowed
                                error, especially in such company; the inconveniency of it was likewise felt by all
                                those who had foreign correspondences, whether political or mercantile. I determined,
                                therefore, to attempt the reformation; I consulted the best lawyers, and the most
                                skillful astronomers, and we cooked up a bill for that purpose. But then my difficulty
                                began; I was to bring in this bill, which was necessarily composed of law jargon and
                                astronomical calculations, to both of which I am an utter stranger. However, it was
                                absolutely necessary to make the House of Lords think that I knew something of the
                                matter; and also to make them believe that they knew something of it themselves, which
                                they do not. For my own part, I could just as soon have talked Celtic or Sclavonian to
                                them, as astronomy, and they would have understood me full as well; so I resolved to do
                                better than speak to the purpose, and to please instead of informing them. I gave them,
                                therefore, only an historical account of calendars, from the Egyptian down to the
                                Gregorian, amusing them now and then with little episodes; but I was particularly
                                attentive to the choice of my words, to the harmony and roundness of my periods, to my
                                elocution, to my action. This succeeded, and ever will succeed; they thought I informed
                                them, because I pleased them; and many of them said I had made the whole very clear to
                                them; when, God knows, I had not even attempted it.”</p>
                              <p>See: Roberts, David (Ed.) <a class="reference external"
                                  href="http://books.google.com.tw/books/about/Lord_Chesterfield_s_Letters.html?id=nFZP1WQ6XDoC&amp;redir_esc=y">Lord
                                  Chesterfield&#8217;s Letters</a>. Oxford University
                                Press, Oxford, 1992.</p>
                            </div>
                            <div class="section" id="notes-95">
                              <h4>备注 95 (Notes 95)<a class="headerlink" href="#notes-95"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>In Common Lisp, a universal time is an integer representing the number of seconds since
                                the beginning of 1900. The functions <code
                                  class="docutils literal"><span class="pre">encode-universal-time</span></code> and
                                <code class="docutils literal"><span class="pre">decode-universal-time</span></code>
                                translate dates into and out of this format. So for dates after 1900, there is a simpler
                                way to do date arithmetic in Common Lisp:
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">num-&gt;date</span> <span class="p">(</span><span class="nv">n</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">multiple-value-bind</span> <span class="p">(</span><span class="nv">ig</span> <span class="nv">no</span> <span class="nv">re</span> <span class="nv">d</span> <span class="nv">m</span> <span class="nv">y</span><span class="p">)</span>
                       <span class="p">(</span><span class="nb">decode-universal-time</span> <span class="nv">n</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">values</span> <span class="nv">d</span> <span class="nv">m</span> <span class="nv">y</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">date-&gt;num</span> <span class="p">(</span><span class="nv">d</span> <span class="nv">m</span> <span class="nv">y</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">encode-universal-time</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span> <span class="nv">d</span> <span class="nv">m</span> <span class="nv">y</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">date+</span> <span class="p">(</span><span class="nv">d</span> <span class="nv">m</span> <span class="nv">y</span> <span class="nv">n</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">num-&gt;date</span> <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nv">date-&gt;num</span> <span class="nv">d</span> <span class="nv">m</span> <span class="nv">y</span><span class="p">)</span>
                <span class="p">(</span><span class="nb">*</span> <span class="mi">60</span> <span class="mi">60</span> <span class="mi">24</span> <span class="nv">n</span><span class="p">))))</span>
</pre>
                                </div>
                              </div>
                              <p>Besides the range limit, this approach has the disadvantage that dates tend not to be
                                fixnums.</p>
                            </div>
                            <div class="section" id="notes-100">
                              <h4>备注 100 (Notes 100)<a class="headerlink" href="#notes-100"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>Although a call to <code class="docutils literal"><span class="pre">setf</span></code>
                                can usually be understood as a reference to a particular place, the underlying machinery
                                is more general. Suppose that a marble is a structure with a single field called color:
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defstruct</span> <span class="nv">marble</span>
  <span class="nv">color</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>The following function takes a list of marbles and returns their color, if they all
                                have the same color, or n i l if they have different colors:</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">uniform-color</span> <span class="p">(</span><span class="nv">1st</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">c</span> <span class="p">(</span><span class="nv">marble-color</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">1st</span><span class="p">))))</span>
    <span class="p">(</span><span class="nb">dolist</span> <span class="p">(</span><span class="nv">m</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">1st</span><span class="p">))</span>
      <span class="p">(</span><span class="nb">unless</span> <span class="p">(</span><span class="nb">eql</span> <span class="p">(</span><span class="nv">marble-color</span> <span class="nv">m</span><span class="p">)</span> <span class="nv">c</span><span class="p">)</span>
        <span class="p">(</span><span class="nb">return</span> <span class="no">nil</span><span class="p">)))</span>
    <span class="nv">c</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p>Although <code class="docutils literal"><span class="pre">uniform-color</span></code>
                                does not refer to a particular place, it is both reasonable and possible to have a call
                                to it as the first argument to <code
                                  class="docutils literal"><span class="pre">setf</span></code> . Having defined</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="p">(</span><span class="nb">setf</span> <span class="nv">uniform-color</span><span class="p">)</span> <span class="p">(</span><span class="nv">val</span> <span class="nv">1st</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">dolist</span> <span class="p">(</span><span class="nv">m</span> <span class="nv">1st</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nv">marble-color</span> <span class="nv">m</span><span class="p">)</span> <span class="nv">val</span><span class="p">)))</span>
</pre>
                                </div>
                              </div>
                              <p>we can say</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nv">uniform-color</span> <span class="vg">*marbles*</span><span class="p">)</span> <span class="ss">&#39;red</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>to make the color of each element of <code
                                  class="docutils literal"><span class="pre">*marbles*</span></code> be red.</p>
                            </div>
                            <div class="section" id="notes-100-2">
                              <h4>备注 100-2 (Notes 100-2)<a class="headerlink" href="#notes-100-2"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>In older Common Lisp implementations, you have to use <code
                                  class="docutils literal"><span class="pre">defsetf</span></code> to define how a call
                                should be treated when it appears as the first argument to setf. Be careful when
                                translating, because the parameter representing the new value comes last in the
                                definition of a function whose name is given as the second argument to <code
                                  class="docutils literal"><span class="pre">defsetf</span></code> . That is, the call
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="p">(</span><span class="nb">setf</span> <span class="nv">primo</span><span class="p">)</span> <span class="p">(</span><span class="nv">val</span> <span class="nv">1st</span><span class="p">)</span> <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">1st</span><span class="p">)</span> <span class="nv">val</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p>is equivalent to</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defsetf</span> <span class="nv">primo</span> <span class="nv">set-primo</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">set-primo</span> <span class="p">(</span><span class="nv">1st</span> <span class="nv">val</span><span class="p">)</span> <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">1st</span><span class="p">)</span> <span class="nv">val</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                            </div>
                            <div class="section" id="notes-106">
                              <h4>备注 106 (Notes 106)<a class="headerlink" href="#notes-106"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>C, for example, lets you pass a pointer to a function, but there&#8217;s less you can
                                pass in a function (because C doesn&#8217;t have closures) and less the recipient can do
                                with it (because C has no equivalent of apply). What&#8217;s more, you are in principle
                                supposed to declare the type of the return value of the function you pass a pointer to.
                                How, then, could you write <code
                                  class="docutils literal"><span class="pre">map-int</span></code> or <code
                                  class="docutils literal"><span class="pre">filter</span></code> , which work for
                                functions that return anything? You couldn&#8217;t, really. You would have to suppress
                                the type-checking of arguments and return values, which is dangerous, and even so would
                                probably only be practical for 32-bit values.</p>
                            </div>
                            <div class="section" id="notes-109">
                              <h4>备注 109 (Notes 109)<a class="headerlink" href="#notes-109"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>For many examples of the versatility of closures, see: Abelson, Harold, and Gerald Jay
                                Sussman, with Julie Sussman. <a class="reference external"
                                  href="http://mitpress.mit.edu/sicp/">Structure and Interpretation of Computer
                                  Programs</a>. MIT Press, Cambridge, 1985.</p>
                            </div>
                            <div class="section" id="notes-109-2">
                              <h4>备注 109-2 (Notes 109-2)<a class="headerlink" href="#notes-109-2"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>For more information about Dylan, see: Shalit, Andrew, with Kim Barrett, David Moon,
                                Orca Starbuck, and Steve Strassmann. <a class="reference external"
                                  href="http://jim.studt.net/dirm/interim-contents.html">Dylan Interim Reference
                                  Manual</a>. Apple Computer, 1994.</p>
                              <p>At the time of printing this document was accessible from several sites, including <a
                                  class="reference external"
                                  href="http://www.harlequin.com">http://www.harlequin.com</a> and <a
                                  class="reference external" href="http://www.apple.com">http://www.apple.com</a>.
                                Scheme is a very small, clean dialect of Lisp. It was invented by Guy L. Steele Jr. and
                                Gerald J. Sussman in 1975, and is currently defined by: Clinger, William, and Jonathan
                                A. Rees (Eds.) <span class="math">\(Revised^4\)</span> Report on the Algorithmic
                                Language Scheme. 1991.</p>
                              <p>This report, and various implementations of Scheme, were at the time of printing
                                available by anonymous FTP from swiss-ftp.ai.mit.edu:pub.</p>
                              <p>There are two especially good textbooks that use Scheme—Structure and Interpretation
                                (see preceding note) and: Springer, George and Daniel P. Friedman. <a
                                  class="reference external"
                                  href="http://www.amazon.com/Scheme-Art-Programming-George-Springer/dp/0262192888">Scheme
                                  and the Art of Programming</a>. MIT Press, Cambridge, 1989.</p>
                            </div>
                            <div class="section" id="notes-112">
                              <h4>备注 112 (Notes 112)<a class="headerlink" href="#notes-112"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>The most horrible Lisp bugs may be those involving dynamic scope. Such errors almost
                                never occur in Common Lisp, which has lexical scope by default. But since so many of the
                                Lisps used as extension languages still have dynamic scope, practicing Lisp programmers
                                should be aware of its perils.</p>
                              <p>One bug that can arise with dynamic scope is similar in spirit to variable capture
                                (page 166). You pass one function as an argument to another. The function passed as an
                                argument refers to some variable. But within the function that calls it, the variable
                                has a new and unexpected value.</p>
                              <p>Suppose, for example, that we wrote a restricted version of mapcar as follows:</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">our-mapcar</span> <span class="p">(</span><span class="nv">fn</span> <span class="nv">x</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">null</span> <span class="nv">x</span><span class="p">)</span>
      <span class="no">nil</span> <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nb">funcall</span> <span class="nv">fn</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">x</span><span class="p">))</span>
                <span class="p">(</span><span class="nv">our-mapcar</span> <span class="nv">fn</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">x</span><span class="p">)))))</span>
</pre>
                                </div>
                              </div>
                              <p>Then suppose that we used this function in another function, <code
                                  class="docutils literal"><span class="pre">add-to-all</span></code> , that would take
                                a number and add it to every element of a list:</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">add-to-all</span> <span class="p">(</span><span class="nv">1st</span> <span class="nv">x</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">our-mapcar</span> <span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">num</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">num</span> <span class="nv">x</span><span class="p">))</span>
              <span class="nv">1st</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p>In Common Lisp this code works fine, but in a Lisp with dynamic scope it would generate
                                an error. The function passed as an argument to <code
                                  class="docutils literal"><span class="pre">our-mapcar</span></code> refers to <code
                                  class="docutils literal"><span class="pre">x</span></code> . At the point where we
                                send this function to <code
                                  class="docutils literal"><span class="pre">our-mapcar</span></code> , <code
                                  class="docutils literal"><span class="pre">x</span></code> would be the number given
                                as the second argument to <code
                                  class="docutils literal"><span class="pre">add-to-all</span></code> . But where the
                                function will be called, within <code
                                  class="docutils literal"><span class="pre">our-mapcar</span></code> , <code
                                  class="docutils literal"><span class="pre">x</span></code> would be something else:
                                the list passed as the second argument to <code
                                  class="docutils literal"><span class="pre">our-mapcar</span></code> . We would get an
                                error when this list was passed as the second argument to <code
                                  class="docutils literal"><span class="pre">+</span></code> .</p>
                            </div>
                            <div class="section" id="notes-123">
                              <h4>备注 123 (Notes 123)<a class="headerlink" href="#notes-123"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>Newer implementations of Common Lisp include avariable <code
                                  class="docutils literal"><span class="pre">*read-eval*</span></code> that can be used
                                to turn off the <code class="docutils literal"><span class="pre">#</span></code> .
                                read-macro. When calling <code
                                  class="docutils literal"><span class="pre">read-from-string</span></code> on user
                                input, it is wise to bind <code
                                  class="docutils literal"><span class="pre">*read-eval*</span></code> to <code
                                  class="docutils literal"><span class="pre">nil</span></code> . Otherwise the user
                                could cause side-effects by using <code
                                  class="docutils literal"><span class="pre">#</span></code> . in the input.</p>
                            </div>
                            <div class="section" id="notes-125">
                              <h4>备注 125 (Notes 125)<a class="headerlink" href="#notes-125"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>There are a number of ingenious algorithms for fast string-matching, but
                                string-matching in text files is one of the cases where the brute-force approach is
                                still reasonably fast. For more on string-matching algorithms, see: Sedgewick, Robert.
                                <a class="reference external"
                                  href="http://www.amazon.com/Algorithms-4th-Robert-Sedgewick/dp/032157351X/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1365042619&amp;sr=1-1&amp;keywords=algorithms+sedgewick">Algorithms</a>.
                                Addison-Wesley, Reading (MA), 1988.
                              </p>
                            </div>
                            <div class="section" id="notes-141">
                              <h4>备注 141 (Notes 141)<a class="headerlink" href="#notes-141"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>In 1984 CommonLisp, reduce did not take a <code
                                  class="docutils literal"><span class="pre">:key</span></code> argument, so <code
                                  class="docutils literal"><span class="pre">random-next</span></code> would be defined:
                              </p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">random-next</span> <span class="p">(</span><span class="nv">prev</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let*</span> <span class="p">((</span><span class="nv">choices</span> <span class="p">(</span><span class="nb">gethash</span> <span class="nv">prev</span> <span class="vg">*words*</span><span class="p">))</span>
         <span class="p">(</span><span class="nv">i</span> <span class="p">(</span><span class="nb">random</span> <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">x</span> <span class="mi">0</span><span class="p">))</span>
                      <span class="p">(</span><span class="nb">dolist</span> <span class="p">(</span><span class="nv">c</span> <span class="nv">choices</span><span class="p">)</span>
                        <span class="p">(</span><span class="nb">incf</span> <span class="nv">x</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">c</span><span class="p">)))</span>
                      <span class="nv">x</span><span class="p">))))</span>
    <span class="p">(</span><span class="nb">dolist</span> <span class="p">(</span><span class="nv">pair</span> <span class="nv">choices</span><span class="p">)</span>
      <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">minusp</span> <span class="p">(</span><span class="nb">decf</span> <span class="nv">i</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">pair</span><span class="p">)))</span>
        <span class="p">(</span><span class="nb">return</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">pair</span><span class="p">))))))</span>
</pre>
                                </div>
                              </div>
                            </div>
                            <div class="section" id="notes-141-2">
                              <h4>备注 141-2 (Notes 141-2)<a class="headerlink" href="#notes-141-2"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>In 1989, a program like Henley was used to simulate netnews postings by well-known
                                flamers. The fake postings fooled a significant number of readers. Like all good hoaxes,
                                this one had an underlying point. What did it say about the content of the original
                                flames, or the attention with which they were read, that randomly generated postings
                                could be mistaken for the real thing?</p>
                              <p>One of the most valuable contributions of artificial intelligence research has been to
                                teach us which tasks are really difficult. Some tasks turn out to be trivial, and some
                                almost impossible. If artificial intelligence is concerned with the latter, the study of
                                the former might be called artificial stupidity. A silly name, perhaps, but this field
                                has real promise—it promises to yield programs that play a role like that of control
                                experiments.</p>
                              <p>Speaking with the appearance of meaning is one of the tasks that turn out to be
                                surprisingly easy. People&#8217;s predisposition to find meaning is so strong that they
                                tend to overshoot the mark. So if a speaker takes care to give his sentences a certain
                                kind of superficial coherence, and his audience are sufficiently credulous, they will
                                make sense of what he says.</p>
                              <p>This fact is probably as old as human history. But now we can give examples of
                                genuinely random text for comparison. And if our randomly generated productions are
                                difficult to distinguish from the real thing, might that not set people to thinking?</p>
                              <p>The program shown in Chapter 8 is about as simple as such a program could be, and that
                                is already enough to generate &#8220;poetry&#8221; that many people (try it on your
                                friends) will believe was written by a human being. With programs that work on the same
                                principle as this one, but which model text as more than a simple stream of words, it
                                will be possible to generate random text that has even more of the trappings of meaning.
                              </p>
                              <p>For a discussion of randomly generated poetry as a legitimate literary form, see: Low,
                                Jackson M. Poetry, Chance, Silence, Etc. In Hall, Donald (Ed.) Claims for Poetry.
                                University of Michigan Press, Ann Arbor, 1982. You bet.</p>
                              <p>Thanks to the Online Book Initiative, ASCII versions of many classics are available
                                online. At the time of printing, they could be obtained by anonymous FTP from
                                ftp.std.com:obi.</p>
                              <p>See also the Emacs Dissociated Press feature, which uses an equivalent algorithm to
                                scramble a buffer.</p>
                            </div>
                            <div class="section" id="notes-150">
                              <h4>备注 150 (Notes 150)<a class="headerlink" href="#notes-150"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>下面这个函数会显示在一个给定实现中，16 个用来标示浮点表示法的限制的全局常量：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">float-limits</span> <span class="p">()</span>
  <span class="p">(</span><span class="nb">dolist</span> <span class="p">(</span><span class="nv">m</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">most</span> <span class="nv">least</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">dolist</span> <span class="p">(</span><span class="nv">s</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">positive</span> <span class="nv">negative</span><span class="p">))</span>
      <span class="p">(</span><span class="nb">dolist</span> <span class="p">(</span><span class="nv">f</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">short</span> <span class="nv">single</span> <span class="nv">double</span> <span class="nv">long</span><span class="p">))</span>
        <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">n</span> <span class="p">(</span><span class="nb">intern</span> <span class="p">(</span><span class="nb">string-upcase</span>
                            <span class="p">(</span><span class="nb">format</span> <span class="no">nil</span> <span class="s">&quot;~A-~A-~A-float&quot;</span>
                                          <span class="nv">m</span>  <span class="nv">s</span>  <span class="nv">f</span><span class="p">)))))</span>
          <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;~30A ~A ~%&quot;</span> <span class="nv">n</span> <span class="p">(</span><span class="nb">symbol-value</span> <span class="nv">n</span><span class="p">)))))))</span>
</pre>
                                </div>
                              </div>
                            </div>
                            <div class="section" id="notes-164">
                              <h4>备注 164 (Notes 164)<a class="headerlink" href="#notes-164"
                                  title="Permalink to this headline">¶</a></h4>
                              <p><a class="reference external"
                                  href="http://zh.wikipedia.org/zh-cn/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F">快速排序演算法</a>由<a
                                  class="reference external"
                                  href="http://zh.wikipedia.org/zh-cn/%E6%9D%B1%E5%B0%BC%C2%B7%E9%9C%8D%E7%88%BE">霍尔</a>于
                                1962 年发表，并被描述在 Knuth, D. E. <em>Sorting and Searching.</em> Addison-Wesley, Reading
                                (MA), 1973.一书中。</p>
                            </div>
                            <div class="section" id="notes-173">
                              <h4>备注 173 (Notes 173)<a class="headerlink" href="#notes-173"
                                  title="Permalink to this headline">¶</a></h4>
                              <p><a class="reference external"
                                  href="http://www.informatik.uni-trier.de/~ley/db/journals/cacm/cacm34.html">Foderaro,
                                  John K. Introduction to the Special Lisp Section. CACM 34:9 (Setember 1991), p.27</a>
                              </p>
                            </div>
                            <div class="section" id="notes-176">
                              <h4>备注 176 (Notes 176)<a class="headerlink" href="#notes-176"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>关于 CLOS 更详细的信息，参考下列书目：</p>
                              <p>Keene, Sonya E. <a class="reference external"
                                  href="http://en.wikipedia.org/wiki/Object-Oriented_Programming_in_Common_Lisp:_A_Programmer's_Guide_to_CLOS">Object
                                  Oriented Programming in Common Lisp</a> , Addison-Wesley, Reading (MA), 1989</p>
                              <p>Kiczales, Gregor, Jim des Rivieres, and Daniel G. Bobrow. <a class="reference external"
                                  href="http://en.wikipedia.org/wiki/The_Art_of_the_Metaobject_Protocol">The Art of the
                                  Metaobject Protocol</a> MIT Press, Cambridge, 1991</p>
                            </div>
                            <div class="section" id="notes-178">
                              <h4>备注 178 (Notes 178)<a class="headerlink" href="#notes-178"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>让我们再回放刚刚的句子一次：<em>我们甚至不需要看程序中其他的代码一眼，就可以完成种种的改动。</em>这个想法或许对某些读者听起来担忧地熟悉。这是写出<a
                                  class="reference external"
                                  href="http://zh.wikipedia.org/wiki/%E9%9D%A2%E6%9D%A1%E5%BC%8F%E4%BB%A3%E7%A0%81">面条式代码</a>的食谱。
                              </p>
                              <p>面向对象模型使得通过一点一点的来构造程序变得简单。但这通常意味著，在实践上它提供了一种有结构的方法来写出面条式代码。这不一定是坏事，但也不会是好事。</p>
                              <p>
                                很多现实世界中的代码是面条式代码，这也许不能很快改变。针对那些终将成为面条式代码的程序来说，面向对象模型是好的：它们最起码会是有结构的面条。但针对那些也许可以避免误入崎途的程序来说，面向对象抽象只是更加危险的，而不是有用的。
                              </p>
                            </div>
                            <div class="section" id="notes-183">
                              <h4>备注 183 (Notes 183)<a class="headerlink" href="#notes-183"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>When an instance would inherit a slot with the same name from several of its
                                superclasses, the instance inherits a single slot that combines the properties of the
                                slots in the superclasses. The way combination is done varies from property to property:
                              </p>
                              <ol class="arabic simple">
                                <li>The <code class="docutils literal"><span class="pre">:allocation</span></code> ,
                                  <code class="docutils literal"><span class="pre">:initform</span></code> (if any), and
                                  <code class="docutils literal"><span class="pre">:documentation</span></code> (if
                                  any), will be those of the most specific classes.
                                </li>
                                <li>The <code class="docutils literal"><span class="pre">:initargs</span></code> will be
                                  the union of the <code
                                    class="docutils literal"><span class="pre">:initargs</span></code> of all the
                                  superclasses. So will the <code
                                    class="docutils literal"><span class="pre">:accessors</span></code> , <code
                                    class="docutils literal"><span class="pre">:readers</span></code> , and <code
                                    class="docutils literal"><span class="pre">:writers</span></code> , effectively.
                                </li>
                                <li>The <code class="docutils literal"><span class="pre">:type</span></code> will be the
                                  intersection of the <code
                                    class="docutils literal"><span class="pre">:types</span></code> of all the
                                  superclasses.</li>
                              </ol>
                            </div>
                            <div class="section" id="notes-191">
                              <h4>备注 191 (Notes 191)<a class="headerlink" href="#notes-191"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>You can avoid explicitly uninterning the names of slots that you want to be
                                encapsulated by using uninterned symbols as the names to start with:</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="k">progn</span>
  <span class="p">(</span><span class="nb">defclass</span> <span class="nv">counter</span> <span class="p">()</span> <span class="p">((</span><span class="o">#1=</span><span class="ss">#:state</span> <span class="ss">:initform</span> <span class="mi">0</span><span class="p">)))</span>

  <span class="p">(</span><span class="nb">defmethod</span> <span class="nv">increment</span> <span class="p">((</span><span class="nv">c</span> <span class="nv">counter</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">incf</span> <span class="p">(</span><span class="nb">slot-value</span> <span class="nv">c</span> <span class="o">&#39;#1#</span><span class="p">)))</span>

  <span class="p">(</span><span class="nb">defmethod</span> <span class="nv">clear</span> <span class="p">((</span><span class="nv">c</span> <span class="nv">counter</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nb">slot-value</span> <span class="nv">c</span> <span class="o">&#39;#1#</span><span class="p">)</span> <span class="mi">0</span><span class="p">)))</span>
</pre>
                                </div>
                              </div>
                              <p>The <code class="docutils literal"><span class="pre">progn</span></code> here is a
                                no-op; it is used to ensure that all the references to the uninterned symbol occur
                                within the same expression. If this were inconvenient, you could use the following
                                read-macro instead:</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defvar</span> <span class="vg">*symtab*</span> <span class="p">(</span><span class="nb">make-hash-table</span> <span class="ss">:test</span> <span class="nf">#&#39;</span><span class="nb">equal</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">pseudo-intern</span> <span class="p">(</span><span class="nv">name</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">or</span> <span class="p">(</span><span class="nb">gethash</span> <span class="nv">name</span> <span class="vg">*symtab*</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nb">gethash</span> <span class="nv">name</span> <span class="vg">*symtab*</span><span class="p">)</span> <span class="p">(</span><span class="nb">gensym</span><span class="p">))))</span>

<span class="p">(</span><span class="nb">set-dispatch-macro-character</span> <span class="sc">#\#</span> <span class="sc">#\[</span>
  <span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nc">stream</span> <span class="nv">char1</span> <span class="nv">char2</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">do</span> <span class="p">((</span><span class="nv">acc</span> <span class="no">nil</span> <span class="p">(</span><span class="nb">cons</span> <span class="nb">char</span> <span class="nv">acc</span><span class="p">))</span>
           <span class="p">(</span><span class="nb">char</span> <span class="p">(</span><span class="nb">read-char</span> <span class="nc">stream</span><span class="p">)</span> <span class="p">(</span><span class="nb">read-char</span> <span class="nc">stream</span><span class="p">)))</span>
          <span class="p">((</span><span class="nb">eql</span> <span class="nb">char</span> <span class="sc">#\]</span><span class="p">)</span> <span class="p">(</span><span class="nv">pseudo-intern</span> <span class="nv">acc</span><span class="p">)))))</span>
</pre>
                                </div>
                              </div>
                              <p>Then it would be possible to say just:</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre>(defclass counter () ((#[state] :initform 0)))

(defmethod increment ((c counter))
  (incf (slot-value c &#39;#[state])))

(defmethod clear ((c counter))
  (setf (slot-value c &#39;#[state]) 0))
</pre>
                                </div>
                              </div>
                            </div>
                            <div class="section" id="notes-204">
                              <h4>备注 204 (Notes 204)<a class="headerlink" href="#notes-204"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>下面这个宏将新元素推入二叉搜索树：</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defmacro</span> <span class="nv">bst-push</span> <span class="p">(</span><span class="nv">obj</span> <span class="nv">bst</span> <span class="nb">&lt;</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">multiple-value-bind</span> <span class="p">(</span><span class="nv">vars</span> <span class="nv">forms</span> <span class="nv">var</span> <span class="nb">set</span> <span class="nv">access</span><span class="p">)</span>
                       <span class="p">(</span><span class="nb">get-setf-expansion</span> <span class="nv">bst</span><span class="p">)</span>
    <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">g</span> <span class="p">(</span><span class="nb">gensym</span><span class="p">)))</span>
      <span class="o">`</span><span class="p">(</span><span class="k">let*</span> <span class="p">((</span><span class="o">,</span><span class="nv">g</span> <span class="o">,</span><span class="nv">obj</span><span class="p">)</span>
              <span class="o">,@</span><span class="p">(</span><span class="nb">mapcar</span> <span class="nf">#&#39;</span><span class="nb">list</span> <span class="nv">vars</span> <span class="nv">forms</span><span class="p">)</span>
              <span class="p">(</span><span class="o">,</span><span class="p">(</span><span class="nb">car</span> <span class="nv">var</span><span class="p">)</span> <span class="p">(</span><span class="nv">bst-insert!</span> <span class="o">,</span><span class="nv">g</span> <span class="o">,</span><span class="nv">access</span> <span class="o">,</span><span class="nb">&lt;</span><span class="p">)))</span>
         <span class="o">,</span><span class="nb">set</span><span class="p">))))</span>
</pre>
                                </div>
                              </div>
                            </div>
                            <div class="section" id="notes-213">
                              <h4>备注 213 (Notes 213)<a class="headerlink" href="#notes-213"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>Knuth, Donald E. <a class="reference external"
                                  href="http://sbel.wisc.edu/Courses/ME964/Literature/knuthProgramming1974.pdf">Structured
                                  Programming with goto Statements.</a> <em>Computing Surveys</em> , 6:4 (December
                                1974), pp. 261-301</p>
                            </div>
                            <div class="section" id="notes-214">
                              <h4>备注 214 (Notes 214)<a class="headerlink" href="#notes-214"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>Knuth, Donald E. <a class="reference external"
                                  href="http://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=2&amp;cad=rja&amp;ved=0CC4QFjAB&amp;url=http%3A%2F%2Fawards.acm.org%2Fimages%2Fawards%2F140%2Farticles%2F7143252.pdf&amp;ei=vl9VUIWBIOWAmQWQu4FY&amp;usg=AFQjCNHAgYS4PiHA0OfgOdiDfPU2i6HAmw&amp;sig2=zZalr-ife4DB4BR2CPORBQ">Computer
                                  Programming as an Art</a> <em>In ACM Turing Award Lectures: The First Twenty
                                  Years.</em> ACM Press, 1987</p>
                              <p>This paper and the preceding one are reprinted in: Knuth, Donald E. Literate
                                Programming. CSLI Lecture Notes #27, Stanford University Center for the Study of
                                Language and Information, Palo Alto, 1992.</p>
                            </div>
                            <div class="section" id="notes-216">
                              <h4>备注 216 (Notes 216)<a class="headerlink" href="#notes-216"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>Steele, Guy L., Jr. Debunking the “Expensive Procedure Call” Myth or, Procedural Call
                                Implementations Considered Harmful or, LAMBDA: The Ultimate GOTO. Proceedings of the
                                National Conference of the ACM, 1977, p. 157.</p>
                              <p>Tail-recursion optimization should mean that the compiler will generate the same code
                                for a tail-recursive function as it would for the equivalent <code
                                  class="docutils literal"><span class="pre">do</span></code>. The unfortunate reality,
                                at least at the time of printing, is that many compilers generate slightly faster code
                                for <code class="docutils literal"><span class="pre">do</span></code>s.</p>
                            </div>
                            <div class="section" id="notes-217">
                              <h4>备注 217 (Notes 217)<a class="headerlink" href="#notes-217"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>For some examples of calls to disassemble on various processors, see: Norvig, Peter.
                                Paradigms ofArtificial Intelligence Programming: Case Studies in Common Lisp. Morgan
                                Kaufmann, San Mateo (CA), 1992.</p>
                            </div>
                            <div class="section" id="notes-218">
                              <h4>备注 218 (Notes 218)<a class="headerlink" href="#notes-218"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>A lot of the increased popularity of object-oriented programming is more specifically
                                the increased popularity of C++, and this in turn has a lot to do with typing. C++ gives
                                you something that seems like a miracle in the conceptual world of C: the ability to
                                define operators that work for different types of arguments. But you don&#8217;t need an
                                object-oriented language to do this—all you need is run-time typing. And indeed, if you
                                look at the way people use C++, the class hierarchies tend to be flat. C++ has become so
                                popular not because people need to write programs in terms of classes and methods, but
                                because people need a way around the restrictions imposed by C&#8217;s approach to
                                typing.</p>
                            </div>
                            <div class="section" id="notes-219">
                              <h4>备注 219 (Notes 219)<a class="headerlink" href="#notes-219"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>Macros can make declarations easier. The following macro expects a type name and an
                                expression (probably numeric), and expands the expression so that all arguments, and all
                                intermediate results, are declared to be of that type. If you wanted to ensure that an
                                expression e was evaluated using only fixnum arithmetic, you could say <code
                                  class="docutils literal"><span class="pre">(with-type</span> <span class="pre">fixnum</span> <span class="pre">e)</span></code>
                                .</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defmacro</span> <span class="nv">with-type</span> <span class="p">(</span><span class="k">type</span> <span class="nv">expr</span><span class="p">)</span>
  <span class="o">`</span><span class="p">(</span><span class="k">the</span> <span class="o">,</span><span class="k">type</span> <span class="o">,</span><span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">atom</span> <span class="nv">expr</span><span class="p">)</span>
                   <span class="nv">expr</span>
                 <span class="p">(</span><span class="nv">expand-call</span> <span class="k">type</span> <span class="p">(</span><span class="nv">binarize</span> <span class="nv">expr</span><span class="p">)))))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">expand-call</span> <span class="p">(</span><span class="k">type</span> <span class="nv">expr</span><span class="p">)</span>
  <span class="o">`</span><span class="p">(</span><span class="o">,</span><span class="p">(</span><span class="nb">car</span> <span class="nv">expr</span><span class="p">)</span> <span class="o">,@</span><span class="p">(</span><span class="nb">mapcar</span> <span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">a</span><span class="p">)</span>
                              <span class="o">`</span><span class="p">(</span><span class="nv">with-type</span> <span class="o">,</span><span class="k">type</span> <span class="o">,</span><span class="nv">a</span><span class="p">))</span>
                          <span class="p">(</span><span class="nb">cdr</span> <span class="nv">expr</span><span class="p">))))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">binarize</span> <span class="p">(</span><span class="nv">expr</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nb">nthcdr</span> <span class="mi">3</span> <span class="nv">expr</span><span class="p">)</span>
           <span class="p">(</span><span class="nb">member</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">expr</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">(</span><span class="nb">+</span> <span class="nb">-</span> <span class="nb">*</span> <span class="nb">/</span><span class="p">)))</span>
      <span class="p">(</span><span class="nb">destructuring-bind</span> <span class="p">(</span><span class="nv">op</span> <span class="nv">a1</span> <span class="nv">a2</span> <span class="o">.</span> <span class="nb">rest</span><span class="p">)</span> <span class="nv">expr</span>
        <span class="p">(</span><span class="nv">binarize</span> <span class="o">`</span><span class="p">(</span><span class="o">,</span><span class="nv">op</span> <span class="p">(</span><span class="o">,</span><span class="nv">op</span> <span class="o">,</span><span class="nv">a1</span> <span class="o">,</span><span class="nv">a2</span><span class="p">)</span> <span class="o">,@</span><span class="nb">rest</span><span class="p">)))</span>
    <span class="nv">expr</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p>The call to binarize ensures that no arithmetic operator is called with more than two
                                arguments. As the Lucid reference manual points out, a call like</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="k">the</span> <span class="kt">fixnum</span> <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="k">the</span> <span class="kt">fixnum</span> <span class="nv">a</span><span class="p">)</span>
               <span class="p">(</span><span class="k">the</span> <span class="kt">fixnum</span> <span class="nv">b</span><span class="p">)</span>
               <span class="p">(</span><span class="k">the</span> <span class="kt">fixnum</span> <span class="nv">c</span><span class="p">)))</span>
</pre>
                                </div>
                              </div>
                              <p>still cannot be compiled into fixnum additions, because the intermediate results (e.g.
                                a + b) might not be fixnums.</p>
                              <p>Using <code class="docutils literal"><span class="pre">with-type</span></code> , we
                                could duplicate the fully declared version of <code
                                  class="docutils literal"><span class="pre">poly</span></code> on page 219 with:</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">poly</span> <span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">x</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">with-type</span> <span class="kt">fixnum</span> <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">a</span> <span class="p">(</span><span class="nb">expt</span> <span class="nv">x</span> <span class="mi">2</span><span class="p">))</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">b</span> <span class="nv">x</span><span class="p">))))</span>
</pre>
                                </div>
                              </div>
                              <p>If you wanted to do a lot of fixnum arithmetic, you might even want to define a
                                read-macro that would expand into a <code
                                  class="docutils literal"><span class="pre">(with-type</span> <span class="pre">fixnum</span> <span class="pre">...)</span></code>
                                .</p>
                            </div>
                            <div class="section" id="notes-224">
                              <h4>备注 224 (Notes 224)<a class="headerlink" href="#notes-224"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>在许多 Unix 系统里， <code
                                  class="docutils literal"><span class="pre">/usr/dict/words</span></code> 是个合适的单词文件。
                              </p>
                            </div>
                            <div class="section" id="notes-229">
                              <h4>备注 226 (Notes 229)<a class="headerlink" href="#notes-229"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>T is a dialect of Scheme with many useful additions, including support for pools. For
                                more on T, see: Rees, Jonathan A., Norman I. Adams, and James R. Meehan. The T Manual,
                                5th Edition. Yale University Computer Science Department, New Haven, 1988.</p>
                              <p>The T manual, and T itself, were at the time of printing available by anonymous FTP
                                from hing.lcs.mit.edu:pub/t3.1 .</p>
                            </div>
                            <div class="section" id="id8">
                              <h4>备注 229 (Notes 229)<a class="headerlink" href="#id8"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>The difference between specifications and programs is a difference in degree, not a
                                difference in kind. Once we realize this, it seems strange to require that one write
                                specifications for a program before beginning to implement it. If the program has to be
                                written in a low-level language, then it would be reasonable to require that it be
                                described in high-level terms first. But as the programming language becomes more
                                abstract, the need for specifications begins to evaporate. Or rather, the implementation
                                and the specifications can become the same thing.</p>
                              <p>If the high-level program is going to be re-implemented in a lower-level language, it
                                starts to look even more like specifications. What Section 13.7 is saying, in other
                                words, is that the specifications for C programs could be written in Lisp.</p>
                            </div>
                            <div class="section" id="notes-230">
                              <h4>备注 230 (Notes 230)<a class="headerlink" href="#notes-230"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>Benvenuto Cellini&#8217;s story of the casting of his Perseus is probably the most
                                famous (and the funniest) account of traditional bronze-casting: Cellini, Benvenuto.
                                Autobiography. Translated by George Bull, Penguin Books, Harmondsworth, 1956.</p>
                            </div>
                            <div class="section" id="notes-239">
                              <h4>备注 239 (Notes 239)<a class="headerlink" href="#notes-239"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>Even experienced Lisp hackers find packages confusing. Is it because packages are
                                gross, or because we are not used to thinking about what happens at read-time?</p>
                              <p>There is a similar kind of uncertainty about def macro, and there it does seem that the
                                difficulty is in the mind of the beholder. A good deal of work has gone into finding a
                                more abstract alternative to def macro. But def macro is only gross if you approach it
                                with the preconception (common enough) that defining a macro is like defining a
                                function. Then it seems shocking that you suddenly have to worry about variable capture.
                                When you think of macros as what they are, transformations on source code, then dealing
                                with variable capture is no more of a problem than dealing with division by zero at
                                run-time.</p>
                              <p>So perhaps packages will turn out to be a reasonable way of providing modularity. It is
                                prima facie evidence on their side that they resemble the techniques that programmers
                                naturally use in the absence of a formal module system.</p>
                            </div>
                            <div class="section" id="notes-242">
                              <h4>备注 242 (Notes 242)<a class="headerlink" href="#notes-242"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>It might be argued that <code
                                  class="docutils literal"><span class="pre">loop</span></code> is more general, and
                                that we should not define many operators to do what we can do with one. But it&#8217;s
                                only in a very legalistic sense that loop is one operator. In that sense, <code
                                  class="docutils literal"><span class="pre">eval</span></code> is one operator too.
                                Judged by the conceptual burden it places on the user, <code
                                  class="docutils literal"><span class="pre">loop</span></code> is at least as many
                                operators as it has clauses. What&#8217;s more, these operators are not available
                                separately, like real Lisp operators: you can&#8217;t break off a piece of loop and pass
                                it as an argument to another function, as you could <code
                                  class="docutils literal"><span class="pre">map-int</span></code> .</p>
                            </div>
                            <div class="section" id="notes-248">
                              <h4>备注 248 (Notes 248)<a class="headerlink" href="#notes-248"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>关于更深入讲述逻辑推论的资料，参见：<a class="reference external"
                                  href="http://www.cs.berkeley.edu/~russell/">Stuart Russell</a> 及 <a
                                  class="reference external" href="http://www.norvig.com/">Peter Norvig</a> 所著的 <a
                                  class="reference external" href="http://aima.cs.berkeley.edu/">Artificial
                                  Intelligence: A Modern Approach</a>。</p>
                            </div>
                            <div class="section" id="notes-273">
                              <h4>备注 273 (Notes 273)<a class="headerlink" href="#notes-273"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>Because the program in Chapter 17 takes advantage of the possibility of having a <code
                                  class="docutils literal"><span class="pre">setf</span></code> form as the first
                                argument to <code class="docutils literal"><span class="pre">defun</span></code> , it
                                will only work in more recent Common Lisp implementations. If you want to use it in an
                                older implementation, substitute the following code in the final version:</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">proclaim</span> <span class="o">&#39;</span><span class="p">(</span><span class="k">inline</span> <span class="nv">lookup</span> <span class="nv">set-lookup</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defsetf</span> <span class="nv">lookup</span> <span class="nv">set-lookup</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">set-lookup</span> <span class="p">(</span><span class="nv">prop</span> <span class="nv">obj</span> <span class="nv">val</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">off</span> <span class="p">(</span><span class="nb">position</span> <span class="nv">prop</span> <span class="p">(</span><span class="nv">layout</span> <span class="nv">obj</span><span class="p">)</span> <span class="ss">:test</span> <span class="nf">#&#39;</span><span class="nb">eq</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">if</span> <span class="nv">off</span>
        <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nb">svref</span> <span class="nv">obj</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">off</span> <span class="mi">3</span><span class="p">))</span> <span class="nv">val</span><span class="p">)</span>
        <span class="p">(</span><span class="nb">error</span> <span class="s">&quot;Can&#39;t set ~A of ~A.&quot;</span> <span class="nv">val</span> <span class="nv">obj</span><span class="p">))))</span>

<span class="p">(</span><span class="nb">defmacro</span> <span class="nv">defprop</span> <span class="p">(</span><span class="nv">name</span> <span class="nv">&amp;optioanl</span> <span class="nv">meth?</span><span class="p">)</span>
  <span class="o">`</span><span class="p">(</span><span class="k">progn</span>
     <span class="p">(</span><span class="nb">defun</span> <span class="o">,</span><span class="nv">name</span> <span class="p">(</span><span class="nv">obj</span> <span class="k">&amp;rest</span> <span class="nv">args</span><span class="p">)</span>
       <span class="o">,</span><span class="p">(</span><span class="k">if</span> <span class="nv">meth?</span>
          <span class="o">`</span><span class="p">(</span><span class="nv">run-methods</span> <span class="nv">obj</span> <span class="ss">&#39;,name</span> <span class="nv">args</span><span class="p">)</span>
          <span class="o">`</span><span class="p">(</span><span class="nv">rget</span> <span class="ss">&#39;,name</span> <span class="nv">obj</span> <span class="no">nil</span><span class="p">)))</span>
     <span class="p">(</span><span class="nb">defsetf</span> <span class="o">,</span><span class="nv">name</span> <span class="p">(</span><span class="nv">obj</span><span class="p">)</span> <span class="p">(</span><span class="nv">val</span><span class="p">)</span>
       <span class="o">`</span><span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nv">lookip</span> <span class="ss">&#39;,&#39;,name</span> <span class="o">,</span><span class="nv">obj</span><span class="p">)</span> <span class="o">,</span><span class="nv">val</span><span class="p">))))</span>
</pre>
                                </div>
                              </div>
                            </div>
                            <div class="section" id="notes-276">
                              <h4>备注 276 (Notes 276)<a class="headerlink" href="#notes-276"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>If <code class="docutils literal"><span class="pre">defmeth</span></code> were defined
                                as</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defmacro</span> <span class="nv">defmeth</span> <span class="p">(</span><span class="nv">name</span> <span class="nv">obj</span> <span class="nv">parms</span> <span class="k">&amp;rest</span> <span class="nv">body</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">gobj</span> <span class="p">(</span><span class="nb">gensym</span><span class="p">)))</span>
    <span class="o">`</span><span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="o">,</span><span class="nv">gobj</span> <span class="o">,</span><span class="nv">obj</span><span class="p">))</span>
       <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nb">gethash</span> <span class="ss">&#39;,name</span> <span class="o">,</span><span class="nv">gobj</span><span class="p">)</span>
             <span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="o">,</span><span class="nv">parms</span>
                 <span class="p">(</span><span class="k">labels</span> <span class="p">((</span><span class="nv">next</span> <span class="p">()</span>
                            <span class="p">(</span><span class="nb">funcall</span> <span class="p">(</span><span class="nv">get-next</span> <span class="o">,</span><span class="nv">gobj</span> <span class="ss">&#39;,name</span><span class="p">)</span>
                                     <span class="o">,@</span><span class="nv">parms</span><span class="p">)))</span>
                   <span class="o">,@</span><span class="nv">body</span><span class="p">))))))</span>
</pre>
                                </div>
                              </div>
                              <p>then it would be possible to invoke the next method simply by calling <code
                                  class="docutils literal"><span class="pre">next</span></code> :</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nv">defmeth</span> <span class="nv">area</span> <span class="nv">grumpy-circle</span> <span class="p">(</span><span class="nv">c</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;How dare you stereotype me!&quot;&quot;/,&quot;</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">next</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                            </div>
                            <div class="section" id="notes-284">
                              <h4>备注 284 (Notes 284)<a class="headerlink" href="#notes-284"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>For really fast access to slots we would use the following macro:</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defmacro</span> <span class="nv">with-slotref</span> <span class="p">((</span><span class="nv">name</span> <span class="nv">prop</span> <span class="nc">class</span><span class="p">)</span> <span class="k">&amp;rest</span> <span class="nv">body</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">g</span> <span class="p">(</span><span class="nb">gensym</span><span class="p">)))</span>
    <span class="o">`</span><span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="o">,</span><span class="nv">g</span> <span class="p">(</span><span class="nb">+</span> <span class="mi">3</span> <span class="p">(</span><span class="nb">position</span> <span class="o">,</span><span class="nv">prop</span> <span class="p">(</span><span class="nv">layout</span> <span class="o">,</span><span class="nc">class</span><span class="p">)</span>
                              <span class="ss">:test</span> <span class="nf">#&#39;</span><span class="nb">eq</span><span class="p">))))</span>
       <span class="p">(</span><span class="k">macrolet</span> <span class="p">((</span><span class="o">,</span><span class="nv">name</span> <span class="p">(</span><span class="nv">obj</span><span class="p">)</span> <span class="o">`</span><span class="p">(</span><span class="nb">svref</span> <span class="o">,</span><span class="nv">obj</span> <span class="o">,</span><span class="ss">&#39;,g</span><span class="p">)))</span>
         <span class="o">,@</span><span class="nv">body</span><span class="p">))))</span>
</pre>
                                </div>
                              </div>
                              <p>It defines a local macro that refers directly to the vector element corresponding to a
                                slot. If in some segment of code you wanted to refer to the same slot in many instances
                                of the same class, with this macro the slot references would be straight <code
                                  class="docutils literal"><span class="pre">svref</span></code>s.</p>
                              <p>For example, if the balloon class is defined as follows,</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">setf</span> <span class="nv">balloon-class</span> <span class="p">(</span><span class="nc">class</span> <span class="no">nil</span> <span class="nv">size</span><span class="p">))</span>
</pre>
                                </div>
                              </div>
                              <p>then this function pops (in the old sense) a list of ballons:</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">popem</span> <span class="p">(</span><span class="nv">ballons</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">with-slotref</span> <span class="p">(</span><span class="nv">bsize</span> <span class="ss">&#39;size</span> <span class="nv">balloon-class</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">dolist</span> <span class="p">(</span><span class="nv">b</span> <span class="nv">ballons</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nv">bsize</span> <span class="nv">b</span><span class="p">)</span> <span class="mi">0</span><span class="p">))))</span>
</pre>
                                </div>
                              </div>
                            </div>
                            <div class="section" id="notes-284-2">
                              <h4>备注 284-2 (Notes 284-2)<a class="headerlink" href="#notes-284-2"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>Gabriel, Richard P. <a class="reference external"
                                  href="http://www.dreamsongs.com/Files/LispGoodNewsBadNews.pdf">Lisp Good News, Bad
                                  News, How to Win Big</a> <em>AI Expert</em>, June 1991, p.35.</p>
                              <p>早在 1973 年， <a class="reference external"
                                  href="http://en.wikipedia.org/wiki/Richard_Fateman">Richard Fateman</a> 已经能证明在 <a
                                  class="reference external" href="http://en.wikipedia.org/wiki/PDP-10">PDP-10</a> 主机上，
                                <a class="reference external" href="http://en.wikipedia.org/wiki/Maclisp">MacLisp</a>
                                编译器比制造商的 FORTRAN 编译器，产生出更快速的代码。
                              </p>
                              <p><strong>译注:</strong> <a class="reference external"
                                  href="http://dl.acm.org/citation.cfm?doid=1086803.1086804">该篇 MacLisp 编译器在 PDP-10 可产生比
                                  Fortran 快的代码的论文在这可以找到</a></p>
                            </div>
                            <div class="section" id="notes-399">
                              <h4>备注 399 (Notes 399)<a class="headerlink" href="#notes-399"
                                  title="Permalink to this headline">¶</a></h4>
                              <p>It&#8217;s easiest to understand backquote if we suppose that backquote and comma are
                                like quote, and that <code class="docutils literal"><span class="pre">`,x</span></code>
                                simply expands into <code
                                  class="docutils literal"><span class="pre">(bq</span> <span class="pre">(comma</span> <span class="pre">x))</span></code>
                                . If this were so, we could handle backquote by augmenting <code
                                  class="docutils literal"><span class="pre">eval</span></code> as in this sketch:</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">eval2</span> <span class="p">(</span><span class="nv">expr</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">case</span> <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nb">consp</span> <span class="nv">expr</span><span class="p">)</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">expr</span><span class="p">))</span>
    <span class="p">(</span><span class="nv">comma</span> <span class="p">(</span><span class="nb">error</span> <span class="s">&quot;unmatched comma&quot;</span><span class="p">))</span>
    <span class="p">(</span><span class="nv">bq</span> <span class="p">(</span><span class="nv">eval-bq</span> <span class="p">(</span><span class="nb">second</span> <span class="nv">expr</span><span class="p">)</span> <span class="mi">1</span><span class="p">))</span>
    <span class="p">(</span><span class="no">t</span>  <span class="p">(</span><span class="nb">eval</span> <span class="nv">expr</span><span class="p">))))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">eval-bq</span> <span class="p">(</span><span class="nv">expr</span> <span class="nv">n</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nb">atom</span> <span class="nv">expr</span><span class="p">)</span>
         <span class="nv">expr</span><span class="p">)</span>
        <span class="p">((</span><span class="nb">eql</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">expr</span><span class="p">)</span> <span class="ss">&#39;comma</span><span class="p">)</span>
         <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">=</span> <span class="nv">n</span> <span class="mi">1</span><span class="p">)</span>
             <span class="p">(</span><span class="nv">eval2</span> <span class="p">(</span><span class="nb">second</span> <span class="nv">expr</span><span class="p">))</span>
             <span class="p">(</span><span class="nb">list</span> <span class="ss">&#39;comma</span> <span class="p">(</span><span class="nv">eval-bq</span> <span class="p">(</span><span class="nb">second</span> <span class="nv">expr</span><span class="p">)</span>
                                   <span class="p">(</span><span class="nb">1-</span> <span class="nv">n</span><span class="p">)))))</span>
        <span class="p">((</span><span class="nb">eql</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">expr</span><span class="p">)</span> <span class="ss">&#39;bq</span><span class="p">)</span>
         <span class="p">(</span><span class="nb">list</span> <span class="ss">&#39;bq</span> <span class="p">(</span><span class="nv">eval-bq</span> <span class="p">(</span><span class="nb">second</span> <span class="nv">expr</span><span class="p">)</span> <span class="p">(</span><span class="nb">1+</span> <span class="nv">n</span><span class="p">))))</span>
        <span class="p">(</span><span class="no">t</span>
         <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nv">eval-bq</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">expr</span><span class="p">)</span> <span class="nv">n</span><span class="p">)</span>
               <span class="p">(</span><span class="nv">eval-bq</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">expr</span><span class="p">)</span> <span class="nv">n</span><span class="p">)))))</span>
</pre>
                                </div>
                              </div>
                              <p>In <code class="docutils literal"><span class="pre">eval-bq</span></code> , the
                                parameter <code class="docutils literal"><span class="pre">n</span></code> is used to
                                determine which commas match the current backquote. Each backquote increments it, and
                                each comma decrements it. A comma encountered when n = 1 is a matching comma. Here is
                                the example from page 400:</p>
                              <div class="highlight-cl">
                                <div class="highlight">
                                  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">setf</span> <span class="nv">x</span> <span class="ss">&#39;a</span> <span class="nv">a</span> <span class="mi">1</span> <span class="nv">y</span> <span class="ss">&#39;b</span> <span class="nv">b</span> <span class="mi">2</span><span class="p">)</span>
<span class="mi">2</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="nv">eval2</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">bq</span> <span class="p">(</span><span class="nv">bq</span> <span class="p">(</span><span class="nv">w</span> <span class="p">(</span><span class="nv">comma</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nv">comma</span> <span class="p">(</span><span class="nv">comma</span> <span class="nv">y</span><span class="p">))))))</span>
<span class="p">(</span><span class="nv">BQ</span> <span class="p">(</span><span class="nv">W</span> <span class="p">(</span><span class="nv">COMMA</span> <span class="nv">X</span><span class="p">)</span> <span class="p">(</span><span class="nv">COMMA</span> <span class="nv">B</span><span class="p">)))</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="nv">eval2</span> <span class="nb">*</span><span class="p">)</span>
<span class="p">(</span><span class="nv">W</span> <span class="nv">A</span> <span class="mi">2</span><span class="p">)</span>
</pre>
                                </div>
                              </div>
                              <p>At some point a particularly remarkable molecule was formed by accident. We will call
                                it the Replicator. It may not necessarily have been the biggest or the most complex
                                molecule around, but it had the extraordinary property of being able to create copies of
                                itself.</p>
                              <p>Richard Dawkins</p>
                              <p>The Selfish Gene</p>
                              <p>We shall first define a class of symbolic expressions in terms of ordered pairs and
                                lists. Then we shall define five elementary functions and predicates, and build from
                                them by composition, conditional expressions, and recursive definitions an extensive
                                class of functions of which we shall give a number of examples. We shall then show how
                                these functions themselves can be expressed as symbolic expressions, and we shall define
                                a universal function apply that allows us to compute from the expression for a given
                                function its value for given arguments.</p>
                              <p>John McCarthy</p>
                              <p>Recursive Functions of Symbolic Expressions and their Computation by Machine, Part I
                              </p>
                            </div>
                          </div>
                        </div>
                      </div>
                    </div>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>
      </div>
    </div>
  </div>
</body>

</html>